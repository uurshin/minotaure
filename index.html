<!doctype html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        
        <style id="game_css"></style>
      <script type="module" crossorigin>
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __, __2, __1, __3;
function _mergeNamespaces(n, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e = m2[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d2 = Object.getOwnPropertyDescriptor(e, k);
          if (d2) {
            Object.defineProperty(n, k, d2.get ? d2 : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const _default = "";
const style = "";
const vueMultiselect = "";
const vueSimpleContextMenu = "";
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$2.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
const isFunction$2 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$3 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$3(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction(
  (str) => str.charAt(0).toUpperCase() + str.slice(1)
);
const toHandlerKey = cacheStringFunction(
  (str) => str ? `on${capitalize$1(str)}` : ``
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$2(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value)) {
    return value;
  } else if (isObject$3(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$2(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$3(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate$1(a);
  let bValidType = isDate$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$2(a);
  bValidType = isArray$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$3(a);
  bValidType = isObject$3(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString$1 = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$2(val) || isObject$3(val) && (val.toString === objectToString$1 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$3(val) && !isArray$2(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target2, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target2);
    if (!depsMap) {
      targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target2, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target2);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$2(target2)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$2(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$2(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target2)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target2)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$2(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a2;
  return (_a2 = targetMap.get(object)) == null ? void 0 : _a2.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$1(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target2, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target2)) {
      return target2;
    }
    const targetIsArray = isArray$2(target2);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(target2, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target2, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$3(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target2, key, value, receiver) {
    let oldValue = target2[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$2(target2) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$2(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn$1(target2, key);
    const result = Reflect.set(target2, key, value, receiver);
    if (target2 === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target2, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target2, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target2, key) {
  const hadKey = hasOwn$1(target2, key);
  target2[key];
  const result = Reflect.deleteProperty(target2, key);
  if (result && hadKey) {
    trigger(target2, "delete", key, void 0);
  }
  return result;
}
function has$1(target2, key) {
  const result = Reflect.has(target2, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target2, "has", key);
  }
  return result;
}
function ownKeys(target2) {
  track(target2, "iterate", isArray$2(target2) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target2);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target2, key) {
    return true;
  },
  deleteProperty(target2, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target2, key, isReadonly2 = false, isShallow2 = false) {
  target2 = target2["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target2.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target2.get(rawKey));
  } else if (target2 !== rawTarget) {
    target2.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target2 = this["__v_raw"];
  const rawTarget = toRaw(target2);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
}
function size(target2, isReadonly2 = false) {
  target2 = target2["__v_raw"];
  !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
  return Reflect.get(target2, "size", target2);
}
function add(value) {
  value = toRaw(value);
  const target2 = toRaw(this);
  const proto = getProto(target2);
  const hadKey = proto.has.call(target2, value);
  if (!hadKey) {
    target2.add(value);
    trigger(target2, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target2 = toRaw(this);
  const { has: has2, get: get2 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  }
  const oldValue = get2.call(target2, key);
  target2.set(key, value);
  if (!hadKey) {
    trigger(target2, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target2, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target2 = toRaw(this);
  const { has: has2, get: get2 } = getProto(target2);
  let hadKey = has2.call(target2, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target2, key);
  }
  get2 ? get2.call(target2, key) : void 0;
  const result = target2.delete(key);
  if (hadKey) {
    trigger(target2, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target2 = toRaw(this);
  const hadItems = target2.size !== 0;
  const result = target2.clear();
  if (hadItems) {
    trigger(target2, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target2 = observed["__v_raw"];
    const rawTarget = toRaw(target2);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target2.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target2 = this["__v_raw"];
    const rawTarget = toRaw(target2);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target2[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target2, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target2;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target2 ? instrumentations : target2,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target2) {
  if (isReadonly(target2)) {
    return target2;
  }
  return createReactiveObject(
    target2,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target2) {
  return createReactiveObject(
    target2,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target2) {
  return createReactiveObject(
    target2,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$3(target2)) {
    return target2;
  }
  if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
    return target2;
  }
  const existingProxy = proxyMap.get(target2);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target2);
  if (targetType === 0) {
    return target2;
  }
  const proxy = new Proxy(
    target2,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target2, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target2, key, receiver) => unref(Reflect.get(target2, key, receiver)),
  set: (target2, key, value, receiver) => {
    const oldValue = target2[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target2, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(
    source,
    key,
    defaultValue
  );
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$2(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn$1(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance2, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance2, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance2, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance2, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance2, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance2, type, args));
  }
  return values;
}
function handleError(err, instance2, type, throwInDev = true) {
  const contextVNode = instance2 ? instance2.vnode : null;
  if (instance2) {
    let cur = instance2.parent;
    const exposedInstance = instance2.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance2.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$2(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance2, event, ...rawArgs) {
  if (instance2.isUnmounted)
    return;
  const props = instance2.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance2,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance2.emitted) {
      instance2.emitted = {};
    } else if (instance2.emitted[handlerName]) {
      return;
    }
    instance2.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance2,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$3(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance2) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance2;
  currentScopeId = instance2 && instance2.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance2) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit3,
    render: render2,
    renderCache,
    data: data2,
    setupState,
    ctx,
    inheritAttrs
  } = instance2;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance2);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data2,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit3
          } : { attrs, slots, emit: emit3 }
        ) : render22(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance2, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush: flush2, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a2;
  const instance2 = getCurrentScope() === ((_a2 = currentInstance) == null ? void 0 : _a2.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$2(s)) {
        return callWithErrorHandling(s, instance2, 2);
      } else
        ;
    });
  } else if (isFunction$2(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance2, 2);
    } else {
      getter = () => {
        if (instance2 && instance2.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance2,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance2, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance2, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush2 === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v, i) => hasChanged(v, oldValue[i])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance2, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush2 === "sync") {
    scheduler = job;
  } else if (flush2 === "post") {
    scheduler = () => queuePostRenderEffect(job, instance2 && instance2.suspense);
  } else {
    job.pre = true;
    if (instance2)
      job.id = instance2.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush2 === "post") {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance2 && instance2.suspense
    );
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance2 && instance2.scope) {
      remove(instance2.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$2(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$3(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject$2(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance2 = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$2(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance: instance2,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance2, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance2, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance2 = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children2 = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children2 || !children2.length) {
        return;
      }
      let child = children2[0];
      if (children2.length > 1) {
        for (const c2 of children2) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance2
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance2.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance2
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance2.update.active !== false) {
              instance2.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance2) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance2,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance2);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children2, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children2.length; i++) {
    let child = children2[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options, extraOptions) {
  return isFunction$2(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target2) {
  registerKeepAliveHook(hook, "a", target2);
}
function onDeactivated(hook, target2) {
  registerKeepAliveHook(hook, "da", target2);
}
function registerKeepAliveHook(hook, type, target2 = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target2;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target2);
  if (target2) {
    let current = target2.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target2, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target2, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target2);
}
function injectHook(type, hook, target2 = currentInstance, prepend = false) {
  if (target2) {
    const hooks = target2[type] || (target2[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target2.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target2);
      const res = callWithAsyncErrorHandling(hook, target2, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target2 = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target2)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target2 = currentInstance) {
  injectHook("ec", hook, target2);
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance2 = currentRenderingInstance || currentInstance;
  if (instance2) {
    const Component = instance2.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance2[type] || Component[type], name) || // global registration
      resolve(instance2.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2 && cache2[index];
  if (isArray$2(source) || isString$2(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$3(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i = 0, l = keys2.length; i < l; i++) {
        const key = keys2[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance2 }, key) {
    const { ctx, setupState, data: data2, props, accessCache, type, appContext } = instance2;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data2[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
        accessCache[key] = 2;
        return data2[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance2.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance2, "get", key);
      }
      return publicGetter(instance2);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance2 }, key, value) {
    const { data: data2, setupState, ctx } = instance2;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data2 !== EMPTY_OBJ && hasOwn$1(data2, key)) {
      data2[key] = value;
      return true;
    } else if (hasOwn$1(instance2.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance2) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data: data2, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data2 !== EMPTY_OBJ && hasOwn$1(data2, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target2, key, descriptor) {
    if (descriptor.get != null) {
      target2._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target2, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target2, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$2(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance2) {
  const options = resolveMergedOptions(instance2);
  const publicThis = instance2.proxy;
  const ctx = instance2.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance2, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted: mounted2,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount: beforeUnmount2,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data2 = dataOptions.call(publicThis, publicThis);
    if (!isObject$3(data2))
      ;
    else {
      instance2.data = reactive(data2);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v) => c2.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance2, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted2);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount2);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance2.exposed || (instance2.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance2.exposed) {
      instance2.exposed = {};
    }
  }
  if (render2 && instance2.render === NOOP) {
    instance2.render = render2;
  }
  if (inheritAttrs != null) {
    instance2.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance2.components = components;
  if (directives)
    instance2.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$3(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance2, type) {
  callWithAsyncErrorHandling(
    isArray$2(hook) ? hook.map((h2) => h2.bind(instance2.proxy)) : hook.bind(instance2.proxy),
    instance2,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$2(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$3(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance2) {
  const base = instance2.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance2.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$3(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions$1(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$2(to) ? to.call(this, this) : to,
      isFunction$2(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$2(to) && isArray$2(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$3(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2))
          ;
        else if (plugin2 && isFunction$2(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app2, ...options);
        } else if (isFunction$2(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      },
      runWithContext(fn) {
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance2 = currentInstance || currentRenderingInstance;
  if (instance2 || currentApp) {
    const provides = instance2 ? instance2.parent == null ? instance2.vnode.appContext && instance2.vnode.appContext.provides : instance2.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance2 && instance2.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance2, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance2.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance2, rawProps, props, attrs);
  for (const key in instance2.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance2.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance2.type.props) {
      instance2.props = attrs;
    } else {
      instance2.props = props;
    }
  }
  instance2.attrs = attrs;
}
function updateProps(instance2, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance2;
  const rawCurrentProps = toRaw(props);
  const [options] = instance2.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance2.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance2.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance2,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance2, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance2,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance2, "set", "$attrs");
  }
}
function setFullProps(instance2, rawProps, props, attrs) {
  const [options, needCastKeys] = instance2.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance2.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance2,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance2, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance2;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance2);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$3(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$2(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$2(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance2) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance2, children2) => {
  const normalized = normalizeSlotValue(children2);
  instance2.slots.default = () => normalized;
};
const initSlots = (instance2, children2) => {
  if (instance2.vnode.shapeFlag & 32) {
    const type = children2._;
    if (type) {
      instance2.slots = toRaw(children2);
      def(children2, "_", type);
    } else {
      normalizeObjectSlots(
        children2,
        instance2.slots = {}
      );
    }
  } else {
    instance2.slots = {};
    if (children2) {
      normalizeVNodeSlots(instance2, children2);
    }
  }
  def(instance2.slots, InternalObjectKey, 1);
};
const updateSlots = (instance2, children2, optimized) => {
  const { vnode, slots } = instance2;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children2._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children2);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children2.$stable;
      normalizeObjectSlots(children2, slots);
    }
    deletionComparisonTarget = children2;
  } else if (children2) {
    normalizeVNodeSlots(instance2, children2);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$1(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$2(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$1(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn$1(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn$1(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target2 = getGlobalThis$1();
  target2.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children2.length; i++) {
      const child = children2[i] = optimized ? cloneIfMounted(children2[i]) : normalizeVNode(children2[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance2 = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance2.ctx.renderer = internals;
    }
    {
      setupComponent(instance2);
    }
    if (instance2.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance2, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance2.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance2,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance2 = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance2.asyncDep && !instance2.asyncResolved) {
        updateComponentPreRender(instance2, n2, optimized);
        return;
      } else {
        instance2.next = n2;
        invalidateJob(instance2.update);
        instance2.update();
      }
    } else {
      n2.el = n1.el;
      instance2.vnode = n2;
    }
  };
  const setupRenderEffect = (instance2, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance2.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance2;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance2, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance2, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance2.subTree = renderComponentRoot(instance2);
            hydrateNode(
              el,
              instance2.subTree,
              instance2,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance2.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance2.subTree = renderComponentRoot(instance2);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance2,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance2.a && queuePostRenderEffect(instance2.a, parentSuspense);
        }
        instance2.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance2;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance2, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance2, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance2, true);
        const nextTree = renderComponentRoot(instance2);
        const prevTree = instance2.subTree;
        instance2.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance2,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance2, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect = instance2.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update2),
      instance2.scope
      // track it in component's effect scope
    );
    const update2 = instance2.update = () => effect.run();
    update2.id = instance2.uid;
    toggleRecurse(instance2, true);
    update2();
  };
  const updateComponentPreRender = (instance2, nextVNode, optimized) => {
    nextVNode.component = instance2;
    const prevProps = instance2.vnode.props;
    instance2.vnode = nextVNode;
    instance2.next = null;
    updateProps(instance2, nextVNode.props, prevProps, optimized);
    updateSlots(instance2, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children: children2, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children2.length; i++) {
        move(children2[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref2,
      children: children2,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children2, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance2, parentSuspense, doRemove) => {
    const { bum, scope, update: update2, subTree, um } = instance2;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update2) {
      update2.active = false;
      unmount(subTree, instance2, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance2.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance2.asyncDep && !instance2.asyncResolved && instance2.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children2, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children2.length; i++) {
      unmount(children2[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function toggleRecurse({ effect, update: update2 }, allowed) {
  effect.allowRecurse = update2.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u2, v, c2;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u2 = 0;
      v = result.length - 1;
      while (u2 < v) {
        c2 = u2 + v >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i] = result[u2 - 1];
        }
        result[u2] = i;
      }
    }
  }
  u2 = result.length;
  v = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children2, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children2,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children2, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children2,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode$1(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children: children2,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children2);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children2) {
    vnode.shapeFlag |= isString$2(children2) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children2) {
      normalizeChildren(cloned, children2);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$3(style2)) {
      if (isProxy(style2) && !isArray$2(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$3(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children2,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children: children2 } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: children2,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text2 = " ", flag = 0) {
  return createVNode(Text, null, text2, flag);
}
function createCommentVNode(text2 = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children2) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children2 == null) {
    children2 = null;
  } else if (isArray$2(children2)) {
    type = 16;
  } else if (typeof children2 === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children2.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children2._;
      if (!slotFlag && !(InternalObjectKey in children2)) {
        children2._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children2._ = 1;
        } else {
          children2._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children2)) {
    children2 = { default: children2, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children2 = String(children2);
    if (shapeFlag & 64) {
      type = 16;
      children2 = [createTextVNode(children2)];
    } else {
      type = 8;
    }
  }
  vnode.children = children2;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance2, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance2, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance2 = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance2.ctx = { _: instance2 };
  }
  instance2.root = parent ? parent.root : instance2;
  instance2.emit = emit.bind(null, instance2);
  if (vnode.ce) {
    vnode.ce(instance2);
  }
  return instance2;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis$1()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis$1()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => currentInstance = i);
  internalSetCurrentInstance = (instance2) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance2));
    } else {
      globalCurrentInstanceSetters[0](instance2);
    }
  };
}
const setCurrentInstance = (instance2) => {
  internalSetCurrentInstance(instance2);
  instance2.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance2) {
  return instance2.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance2, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children: children2 } = instance2.vnode;
  const isStateful = isStatefulComponent(instance2);
  initProps(instance2, props, isStateful, isSSR);
  initSlots(instance2, children2);
  const setupResult = isStateful ? setupStatefulComponent(instance2, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance2, isSSR) {
  const Component = instance2.type;
  instance2.accessCache = /* @__PURE__ */ Object.create(null);
  instance2.proxy = markRaw(new Proxy(instance2.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance2.setupContext = setup.length > 1 ? createSetupContext(instance2) : null;
    setCurrentInstance(instance2);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance2,
      0,
      [instance2.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance2, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance2, 0);
        });
      } else {
        instance2.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance2, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance2, isSSR);
  }
}
function handleSetupResult(instance2, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance2.type.__ssrInlineRender) {
      instance2.ssrRender = setupResult;
    } else {
      instance2.render = setupResult;
    }
  } else if (isObject$3(setupResult)) {
    instance2.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance2, isSSR);
}
let compile;
function finishComponentSetup(instance2, isSSR, skipOptions) {
  const Component = instance2.type;
  if (!instance2.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance2).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance2.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance2.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance2);
    pauseTracking();
    applyOptions(instance2);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance2) {
  return instance2.attrsProxy || (instance2.attrsProxy = new Proxy(
    instance2.attrs,
    {
      get(target2, key) {
        track(instance2, "get", "$attrs");
        return target2[key];
      }
    }
  ));
}
function createSetupContext(instance2) {
  const expose = (exposed) => {
    instance2.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance2);
      },
      slots: instance2.slots,
      emit: instance2.emit,
      expose
    };
  }
}
function getExposeProxy(instance2) {
  if (instance2.exposed) {
    return instance2.exposeProxy || (instance2.exposeProxy = new Proxy(proxyRefs(markRaw(instance2.exposed)), {
      get(target2, key) {
        if (key in target2) {
          return target2[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance2);
        }
      },
      has(target2, key) {
        return key in target2 || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h$1(type, propsOrChildren, children2) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$3(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children2 = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode$1(children2)) {
      children2 = [children2];
    }
    return createVNode(type, propsOrChildren, children2);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const version = "3.3.4";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text2) => doc.createTextNode(text2),
  createComment: (text2) => doc.createComment(text2),
  setText: (node, text2) => {
    node.nodeValue = text2;
  },
  setElementText: (el, text2) => {
    el.textContent = text2;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString$2(next);
  if (next && !isCssString) {
    if (prev && !isString$2(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$2(val)) {
    val.forEach((v) => setStyle(style2, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance2) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance2 = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance2);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$2 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$2.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance2) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance2,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$2(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$2(value)) {
    return false;
  }
  return key in el;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h$1(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Transition.props = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$3(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i) => toMs(d2) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target2 = e.target;
  if (target2.composing) {
    target2.composing = false;
    target2.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim, number: number2 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number2 || el.type === "number") && looseToNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el._assign(getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number: number2 } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number2 ? looseToNumber(getValue(o)) : getValue(o)
      );
      el._assign(
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
    });
    el._assign = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$2(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray$2(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var isVue2 = false;
/*!
 * pinia v2.1.6
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$1(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app2) {
      setActivePinia(pinia);
      {
        pinia._a = app2;
        app2.provide(piniaSymbol, pinia);
        app2.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin2) => _p.push(plugin2));
        toBeInstalled = [];
      }
    },
    use(plugin2) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin2);
      } else {
        _p.push(plugin2);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia;
}
const noop$3 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$3) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
function mergeReactiveObjects(target2, patchToApply) {
  if (target2 instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target2.set(key, value));
  }
  if (target2 instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target2.add, target2);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target2[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target2.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target2[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target2[key] = subPatch;
    }
  }
  return target2;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$3 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id, options, pinia, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia.state.value[id];
  let store;
  function setup() {
    if (!initialState && true) {
      {
        pinia.state.value[id] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia.state.value[id]);
    return assign$3(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id, setup, options, pinia, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$3({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$3($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop$3
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$3({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia._s.set($id, store);
  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
  const setupStore = pinia._e.run(() => {
    scope = effectScope();
    return runWithContext(() => scope.run(setup));
  });
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign$3(store, setupStore);
    assign$3(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$3($state, state);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign$3(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const hasContext = hasInjectionContext();
    pinia = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id)) {
      if (isSetupStore) {
        createSetupStore(id, setup, options, pinia);
      } else {
        createOptionsStore(id, options, pinia);
      }
    }
    const store = pinia._s.get(id);
    return store;
  }
  useStore.$id = id;
  return useStore;
}
/*!
  * vue-router v4.2.4
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign$2 = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray$1(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop$2 = () => {
};
const isArray$1 = Array.isArray;
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return isArray$1(a) ? isEquivalentArray(a, b) : isArray$1(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return isArray$1(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position2 = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position2 > 1)
        position2--;
    } else
      break;
  }
  return fromSegments.slice(0, position2).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position2) {
  let scrollToOptions;
  if ("el" in position2) {
    const positionEl = position2.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position2);
  } else {
    scrollToOptions = position2;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position2 = history.state ? history.state.position - delta : -1;
  return position2 + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners2 = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners2.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen2(callback) {
    listeners2.push(callback);
    const teardown = () => {
      const index = listeners2.indexOf(callback);
      if (index > -1)
        listeners2.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign$2({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen: listen2,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to, data2) {
    const state = assign$2({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data2, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data2) {
    const currentState = assign$2(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign$2({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data2);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign$2({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base) {
  base = location.host ? base || location.pathname + location.search : "";
  if (!base.includes("#"))
    base += "#";
  return createWebHistory(base);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign$2(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign$2({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys2.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i = 1; i < match.length; i++) {
      const value = match[i] || "";
      const key = keys2[i - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray$1(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text2 = isArray$1(param) ? param.join("/") : param;
          if (!text2) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text2;
        }
      }
    }
    return path || "/";
  }
  return {
    re,
    score,
    keys: keys2,
    parse: parse2,
    stringify
  };
}
function compareScoreArray(a, b) {
  let i = 0;
  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i];
    if (diff)
      return diff;
    i++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign$2(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign$2({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children2 = mainNormalizedRecord.children;
        for (let i = 0; i < children2.length; i++) {
          addRoute(children2[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
      if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
        insertMatcher(matcher);
      }
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop$2;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i = 0;
    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && // Adding children with empty path should still appear before the parent
    // https://github.com/vuejs/router/issues/1124
    (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))
      i++;
    matchers.splice(i, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign$2(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // TODO: only keep optional params coming from a parent record
          matcher.keys.filter((k) => !k.optional).map((k) => k.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m2) => m2.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign$2({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key of keys2) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "object" ? props[name] : props;
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign$2(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text2) {
  return encodeURI("" + text2).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text2) {
  return commonEncode(text2).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text2) {
  return commonEncode(text2).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text2) {
  return encodeQueryValue(text2).replace(EQUAL_RE, "%3D");
}
function encodePath(text2) {
  return commonEncode(text2).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text2) {
  return text2 == null ? "" : encodePath(text2).replace(SLASH_RE, "%2F");
}
function decode(text2) {
  try {
    return decodeURIComponent("" + text2);
  } catch (err) {
  }
  return "" + text2;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray$1(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray$1(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray$1(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers = [];
  function add2(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1)
        handlers.splice(i, 1);
    };
  }
  function reset() {
    handlers = [];
  }
  return {
    add: add2,
    list: () => handlers.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to, from, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router2 = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router2.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router2[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop$2);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children2 = slots.default && slots.default(link);
      return props.custom ? children2 : h$1("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children2);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target2 = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target2))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance2, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance2;
        if (from && from !== to && instance2 && instance2 === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance2 && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance2));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h$1(ViewComponent, assign$2({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data2) {
  if (!slot)
    return null;
  const slotContent = slot(data2);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign$2({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign$2(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign$2({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign$2({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign$2({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign$2({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign$2({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign$2({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign$2(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign$2({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: "path" in newTargetLocation ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from = currentRoute.value;
    const data2 = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign$2(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign$2({}, data2, shouldRedirect.state) : data2,
          force,
          replace: replace2
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign$2({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign$2({}, data2, failure2.to.state) : data2,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data2);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app2 = installedApps.values().next().value;
    return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray$1(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data2) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign$2({
          scroll: isFirstNavigation && state && state.scroll
        }, data2));
      else
        routerHistory.push(toLocation.fullPath, data2);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router2.listening)
        return;
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign$2(shouldRedirect, { replace: true }), toLocation).catch(noop$2);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            error.to,
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop$2);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop$2);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position2) => position2 && scrollToPosition(position2)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app2) {
      const router3 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router3;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key, {
          get: () => currentRoute.value[key],
          enumerable: true
        });
      }
      app2.provide(routerKey, router3);
      app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router2;
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
/*!
  * shared v9.4.1
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign$1 = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$2 = (val) => val !== null && typeof val === "object";
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => {
  if (!isObject$2(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join(items, separator = "") {
  return items.reduce((str, item, index) => index === 0 ? str + item : str + separator + item, "");
}
function incrementer(code2) {
  let current = code2;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
/*!
  * message-compiler v9.4.1
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format(message, ...args) {
  if (args.length === 1 && isObject$1(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
const isObject$1 = (val) => val !== null && typeof val === "object";
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
const errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code2, loc, options = {}) {
  const { domain, messages: messages2, args } = options;
  const msg = format((messages2 || errorMessages)[code2] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
/*!
  * core-base v9.4.1
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
function initFeatureFlags$1() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code2 = ch.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys2 = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c2;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys2.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c2 = path[index];
    if (c2 === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c2);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c2;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys2;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$2(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$2(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$2(options.pluralRules) && isString$1(locale) && isFunction$1(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$2(options.pluralRules) && isString$1(locale) && isFunction$1(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages2) => {
    return messages2[pluralRule(pluralIndex, messages2.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index) => _list[index];
  const _named = options.named || {};
  isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction$1(options.messages) ? options.messages(key) : isObject$2(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction$1(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction$1(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$2(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign$1({}, _list, _named)
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const CoreWarnCodes = {
  NOT_FOUND_KEY: 1,
  FALLBACK_TO_TRANSLATE: 2,
  CANNOT_FORMAT_NUMBER: 3,
  FALLBACK_TO_NUMBER_FORMAT: 4,
  CANNOT_FORMAT_DATE: 5,
  FALLBACK_TO_DATE_FORMAT: 6,
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7,
  __EXTEND_POINT__: 8
};
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject$2(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$1(defaults) ? [defaults] : defaults;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString$1(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target2 = tokens.join("-");
    follow = appendItemToChain(chain, target2, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target2, blocks) {
  let follow = false;
  if (!chain.includes(target2)) {
    follow = true;
    if (target2) {
      follow = target2[target2.length - 1] !== "!";
      const locale = target2.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$1 = "9.4.1";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction$1(options.onWarn) ? options.onWarn : warn;
  const version2 = isString$1(options.version) ? options.version : VERSION$1;
  const locale = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const messages2 = isPlainObject(options.messages) ? options.messages : { [locale]: {} };
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [locale]: {} };
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : { [locale]: {} };
  const modifiers = assign$1({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction$1(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction$1(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction$1(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction$1(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$2(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$2(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$2(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$2(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages: messages2,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString$1(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
const code$2 = CompileErrorCodes.__EXTEND_POINT__;
const inc$2 = incrementer(code$2);
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$2,
  INVALID_DATE_ARGUMENT: inc$2(),
  INVALID_ISO_DATE_ARGUMENT: inc$2(),
  NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
  __EXTEND_POINT__: inc$2()
  // 22
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
const isMessageAST = (val) => isObject$2(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction$1(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages: messages2 } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages2[locale] || {}
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$1({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$2(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$1(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages: messages2, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = {};
  let targetLocale;
  let format2 = null;
  const type = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message = messages2[targetLocale] || {};
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString$1(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    const missingRet = handleMissing(
      context,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      key,
      targetLocale,
      missingWarn,
      type
    );
    if (missingRet !== key) {
      format2 = missingRet;
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format2;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};
  if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign$1(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$1(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
    __datetimeFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  let value;
  if (isString$1(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id)) {
      continue;
    }
    context.__datetimeFormatters.delete(id);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id = `${id}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
    __numberFormatters.set(id, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id)) {
      continue;
    }
    context.__numberFormatters.delete(id);
  }
}
{
  initFeatureFlags$1();
}
/*!
  * vue-i18n v9.4.1
  * (c) 2023 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.4.1";
function initFeatureFlags() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
const code$1 = CoreWarnCodes.__EXTEND_POINT__;
const inc$1 = incrementer(code$1);
({
  FALLBACK_TO_ROOT: code$1,
  NOT_SUPPORTED_PRESERVE: inc$1(),
  NOT_SUPPORTED_FORMATTER: inc$1(),
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
  NOT_FOUND_PARENT_SCOPE: inc$1(),
  IGNORE_OBJ_FLATTEN: inc$1(),
  NOTICE_DROP_ALLOW_COMPOSITION: inc$1()
  // 17
});
const code = CoreErrorCodes.__EXTEND_POINT__;
const inc = incrementer(code);
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  NOT_INSTALLED: inc(),
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // directive module errors
  REQUIRED_VALUE: inc(),
  INVALID_VALUE: inc(),
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  NOT_INSTALLED_WITH_PROVIDE: inc(),
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // for enhancement
  __EXTEND_POINT__: inc()
  // 37
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$2(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$2(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }
        if (!isObject$2(currentObj[subKeys[i]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject$2(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages: messages2, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages2) ? messages2 : isArray(__i18n) ? {} : { [locale]: {} };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
const isNotObjectOrIsArray = (val) => !isObject$2(val) || isArray(val);
function deepCopy(src2, des) {
  if (isNotObjectOrIsArray(src2) || isNotObjectOrIsArray(des)) {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
  for (const key in src2) {
    if (hasOwn(src2, key)) {
      if (isNotObjectOrIsArray(src2[key]) || isNotObjectOrIsArray(des[key])) {
        des[key] = src2[key];
      } else {
        deepCopy(src2[key], des[key]);
      }
    }
  }
}
function getComponentOptions(instance2) {
  return instance2.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages2 = isObject$2(options.messages) ? options.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages2 = getLocaleMessages(gl.locale.value, {
      messages: messages2,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages2);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages2[locale]);
    });
  }
  {
    if (isObject$2(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$2(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  };
}
const getMetaInfo = () => {
  const instance2 = getCurrentInstance();
  let meta = null;
  return instance2 && (meta = getComponentOptions(instance2)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction$1(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction$1(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages2 = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction$1(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        setAdditionalMeta(getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (__INTLIFY_PROD_DEVTOOLS__) {
        setAdditionalMeta(null);
      }
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (isNumber(ret) && ret === NOT_REOSLVED) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$2(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign$1({ resolvedMessage: true }, arg3 || {})]);
  }
  function d2(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize(values) {
    return values.map((val) => isString$1(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      () => [],
      (val) => isString$1(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      () => [],
      (val) => isString$1(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te2(key, locale2) {
    const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
    const message = getLocaleMessage(targetLocale);
    return _context.messageResolver(message, key) !== null;
  }
  function resolveMessages(key) {
    let messages3 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages3 = messageValue;
        break;
      }
    }
    return messages3;
  }
  function tm(key) {
    const messages3 = resolveMessages(key);
    return messages3 != null ? messages3 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$1(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$1(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages: messages2,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te2;
    composer.tm = tm;
    composer.d = d2;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys2) {
  if (keys2.length === 1 && keys2[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys2.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign$1({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n2 = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys2 = Object.keys(slots).filter((key) => key !== "_");
      const options = {};
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys2);
      const children2 = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$1({}, attrs);
      const tag = isString$1(props.tag) || isObject$2(props.tag) ? props.tag : getFragmentableTag();
      return h$1(tag, assignedAttrs, children2);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target2) {
  return isArray(target2) && !isString$1(target2[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = {};
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options.key = props.format;
    } else if (isObject$2(props.format)) {
      if (isString$1(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$1({}, options2, { [prop]: props.format[prop] }) : options2;
      }, {});
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children2 = [options.key];
    if (isArray(parts)) {
      children2 = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$1(parts)) {
      children2 = [parts];
    }
    const assignedAttrs = assign$1({}, attrs);
    const tag = isString$1(props.tag) || isObject$2(props.tag) ? props.tag : getFragmentableTag();
    return h$1(tag, assignedAttrs, children2);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign$1({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: "parent",
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign$1({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n2 = props.i18n || useI18n({
      useScope: "parent",
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n2[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n2, instance2) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance2) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance2);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
function vTDirective(i18n2) {
  const _process = (binding) => {
    const { instance: instance2, modifiers, value } = binding;
    if (!instance2 || !instance2.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance2.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (inBrowser && el.__i18nWatcher) {
      el.__i18nWatcher();
      el.__i18nWatcher = void 0;
      delete el.__i18nWatcher;
    }
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update2 = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update2,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString$1(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString$1(locale)) {
    options.locale = locale;
  }
  if (isNumber(choice)) {
    options.plural = choice;
  }
  if (isNumber(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app2, i18n2, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance2) {
    __instances.set(component, instance2);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n2 = {
      // mode
      get mode() {
        return "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options2) {
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject(options2[0])) {
          const opts = options2[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (__globalInjection) {
          globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
        }
        {
          apply(app2, i18n2, ...options2);
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n2.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
function useI18n(options = {}) {
  const instance2 = getCurrentInstance();
  if (instance2 == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance2.isCE && instance2.appContext.app != null && !instance2.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n2 = getI18nInstance(instance2);
  const gl = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance2);
  const scope = getScope(options, componentOptions);
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance2, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance2);
  if (composer == null) {
    const composerOptions = assign$1({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance2, composer);
    i18nInternal.__setInstance(instance2, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance2) {
  {
    const i18n2 = inject(!instance2.isCE ? instance2.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance2.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target2, useComponent = false) {
  let composer = null;
  const root = target2.root;
  let current = getParentComponentInstance(target2, useComponent);
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target2, useComponent = false) {
  if (target2 == null) {
    return null;
  }
  {
    return !useComponent ? target2.parent : target2.vnode.ctx || target2.parent;
  }
}
function setupLifeCycle(i18n2, target2, composer) {
  {
    onMounted(() => {
    }, target2);
    onUnmounted(() => {
      const _composer = composer;
      i18n2.__deleteInstance(target2);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target2);
  }
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app2.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app2.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags();
}
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target2 = getGlobalThis();
  target2.__INTLIFY__ = true;
  setDevToolsHook(target2.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
class $e8379818650e2442$export$93654d4f2d6cd524 {
  constructor() {
    this.encoder = new TextEncoder();
    this._pieces = [];
    this._parts = [];
  }
  append_buffer(data2) {
    this.flush();
    this._parts.push(data2);
  }
  append(data2) {
    this._pieces.push(data2);
  }
  flush() {
    if (this._pieces.length > 0) {
      const buf = new Uint8Array(this._pieces);
      this._parts.push(buf);
      this._pieces = [];
    }
  }
  toArrayBuffer() {
    const buffer = [];
    for (const part of this._parts)
      buffer.push(part);
    return $e8379818650e2442$var$concatArrayBuffers(buffer).buffer;
  }
}
function $e8379818650e2442$var$concatArrayBuffers(bufs) {
  let size2 = 0;
  for (const buf of bufs)
    size2 += buf.byteLength;
  const result = new Uint8Array(size2);
  let offset = 0;
  for (const buf of bufs) {
    const view = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    result.set(view, offset);
    offset += buf.byteLength;
  }
  return result;
}
function $0cfd7828ad59115f$export$417857010dc9287f(data2) {
  const unpacker = new $0cfd7828ad59115f$var$Unpacker(data2);
  return unpacker.unpack();
}
function $0cfd7828ad59115f$export$2a703dbb0cb35339(data2) {
  const packer = new $0cfd7828ad59115f$export$b9ec4b114aa40074();
  packer.pack(data2);
  return packer.getBuffer();
}
class $0cfd7828ad59115f$var$Unpacker {
  constructor(data2) {
    this.index = 0;
    this.dataBuffer = data2;
    this.dataView = new Uint8Array(this.dataBuffer);
    this.length = this.dataBuffer.byteLength;
  }
  unpack() {
    const type = this.unpack_uint8();
    if (type < 128)
      return type;
    else if ((type ^ 224) < 32)
      return (type ^ 224) - 32;
    let size2;
    if ((size2 = type ^ 160) <= 15)
      return this.unpack_raw(size2);
    else if ((size2 = type ^ 176) <= 15)
      return this.unpack_string(size2);
    else if ((size2 = type ^ 144) <= 15)
      return this.unpack_array(size2);
    else if ((size2 = type ^ 128) <= 15)
      return this.unpack_map(size2);
    switch (type) {
      case 192:
        return null;
      case 193:
        return void 0;
      case 194:
        return false;
      case 195:
        return true;
      case 202:
        return this.unpack_float();
      case 203:
        return this.unpack_double();
      case 204:
        return this.unpack_uint8();
      case 205:
        return this.unpack_uint16();
      case 206:
        return this.unpack_uint32();
      case 207:
        return this.unpack_uint64();
      case 208:
        return this.unpack_int8();
      case 209:
        return this.unpack_int16();
      case 210:
        return this.unpack_int32();
      case 211:
        return this.unpack_int64();
      case 212:
        return void 0;
      case 213:
        return void 0;
      case 214:
        return void 0;
      case 215:
        return void 0;
      case 216:
        size2 = this.unpack_uint16();
        return this.unpack_string(size2);
      case 217:
        size2 = this.unpack_uint32();
        return this.unpack_string(size2);
      case 218:
        size2 = this.unpack_uint16();
        return this.unpack_raw(size2);
      case 219:
        size2 = this.unpack_uint32();
        return this.unpack_raw(size2);
      case 220:
        size2 = this.unpack_uint16();
        return this.unpack_array(size2);
      case 221:
        size2 = this.unpack_uint32();
        return this.unpack_array(size2);
      case 222:
        size2 = this.unpack_uint16();
        return this.unpack_map(size2);
      case 223:
        size2 = this.unpack_uint32();
        return this.unpack_map(size2);
    }
  }
  unpack_uint8() {
    const byte = this.dataView[this.index] & 255;
    this.index++;
    return byte;
  }
  unpack_uint16() {
    const bytes = this.read(2);
    const uint16 = (bytes[0] & 255) * 256 + (bytes[1] & 255);
    this.index += 2;
    return uint16;
  }
  unpack_uint32() {
    const bytes = this.read(4);
    const uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];
    this.index += 4;
    return uint32;
  }
  unpack_uint64() {
    const bytes = this.read(8);
    const uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];
    this.index += 8;
    return uint64;
  }
  unpack_int8() {
    const uint8 = this.unpack_uint8();
    return uint8 < 128 ? uint8 : uint8 - 256;
  }
  unpack_int16() {
    const uint16 = this.unpack_uint16();
    return uint16 < 32768 ? uint16 : uint16 - 65536;
  }
  unpack_int32() {
    const uint32 = this.unpack_uint32();
    return uint32 < 2 ** 31 ? uint32 : uint32 - 2 ** 32;
  }
  unpack_int64() {
    const uint64 = this.unpack_uint64();
    return uint64 < 2 ** 63 ? uint64 : uint64 - 2 ** 64;
  }
  unpack_raw(size2) {
    if (this.length < this.index + size2)
      throw new Error(`BinaryPackFailure: index is out of range ${this.index} ${size2} ${this.length}`);
    const buf = this.dataBuffer.slice(this.index, this.index + size2);
    this.index += size2;
    return buf;
  }
  unpack_string(size2) {
    const bytes = this.read(size2);
    let i = 0;
    let str = "";
    let c2;
    let code2;
    while (i < size2) {
      c2 = bytes[i];
      if (c2 < 160) {
        code2 = c2;
        i++;
      } else if ((c2 ^ 192) < 32) {
        code2 = (c2 & 31) << 6 | bytes[i + 1] & 63;
        i += 2;
      } else if ((c2 ^ 224) < 16) {
        code2 = (c2 & 15) << 12 | (bytes[i + 1] & 63) << 6 | bytes[i + 2] & 63;
        i += 3;
      } else {
        code2 = (c2 & 7) << 18 | (bytes[i + 1] & 63) << 12 | (bytes[i + 2] & 63) << 6 | bytes[i + 3] & 63;
        i += 4;
      }
      str += String.fromCodePoint(code2);
    }
    this.index += size2;
    return str;
  }
  unpack_array(size2) {
    const objects = new Array(size2);
    for (let i = 0; i < size2; i++)
      objects[i] = this.unpack();
    return objects;
  }
  unpack_map(size2) {
    const map = {};
    for (let i = 0; i < size2; i++) {
      const key = this.unpack();
      map[key] = this.unpack();
    }
    return map;
  }
  unpack_float() {
    const uint32 = this.unpack_uint32();
    const sign = uint32 >> 31;
    const exp = (uint32 >> 23 & 255) - 127;
    const fraction = uint32 & 8388607 | 8388608;
    return (sign === 0 ? 1 : -1) * fraction * 2 ** (exp - 23);
  }
  unpack_double() {
    const h32 = this.unpack_uint32();
    const l32 = this.unpack_uint32();
    const sign = h32 >> 31;
    const exp = (h32 >> 20 & 2047) - 1023;
    const hfrac = h32 & 1048575 | 1048576;
    const frac = hfrac * 2 ** (exp - 20) + l32 * 2 ** (exp - 52);
    return (sign === 0 ? 1 : -1) * frac;
  }
  read(length) {
    const j = this.index;
    if (j + length <= this.length)
      return this.dataView.subarray(j, j + length);
    else
      throw new Error("BinaryPackFailure: read index out of range");
  }
}
class $0cfd7828ad59115f$export$b9ec4b114aa40074 {
  getBuffer() {
    return this._bufferBuilder.toArrayBuffer();
  }
  pack(value) {
    if (typeof value === "string")
      this.pack_string(value);
    else if (typeof value === "number") {
      if (Math.floor(value) === value)
        this.pack_integer(value);
      else
        this.pack_double(value);
    } else if (typeof value === "boolean") {
      if (value === true)
        this._bufferBuilder.append(195);
      else if (value === false)
        this._bufferBuilder.append(194);
    } else if (value === void 0)
      this._bufferBuilder.append(192);
    else if (typeof value === "object") {
      if (value === null)
        this._bufferBuilder.append(192);
      else {
        const constructor = value.constructor;
        if (value instanceof Array)
          this.pack_array(value);
        else if (value instanceof ArrayBuffer)
          this.pack_bin(new Uint8Array(value));
        else if ("BYTES_PER_ELEMENT" in value) {
          const v = value;
          this.pack_bin(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));
        } else if (value instanceof Date)
          this.pack_string(value.toString());
        else if (constructor == Object || constructor.toString().startsWith("class"))
          this.pack_object(value);
        else
          throw new Error(`Type "${constructor.toString()}" not yet supported`);
      }
    } else
      throw new Error(`Type "${typeof value}" not yet supported`);
    this._bufferBuilder.flush();
  }
  pack_bin(blob) {
    const length = blob.length;
    if (length <= 15)
      this.pack_uint8(160 + length);
    else if (length <= 65535) {
      this._bufferBuilder.append(218);
      this.pack_uint16(length);
    } else if (length <= 4294967295) {
      this._bufferBuilder.append(219);
      this.pack_uint32(length);
    } else
      throw new Error("Invalid length");
    this._bufferBuilder.append_buffer(blob);
  }
  pack_string(str) {
    const encoded = this._textEncoder.encode(str);
    const length = encoded.length;
    if (length <= 15)
      this.pack_uint8(176 + length);
    else if (length <= 65535) {
      this._bufferBuilder.append(216);
      this.pack_uint16(length);
    } else if (length <= 4294967295) {
      this._bufferBuilder.append(217);
      this.pack_uint32(length);
    } else
      throw new Error("Invalid length");
    this._bufferBuilder.append_buffer(encoded);
  }
  pack_array(ary) {
    const length = ary.length;
    if (length <= 15)
      this.pack_uint8(144 + length);
    else if (length <= 65535) {
      this._bufferBuilder.append(220);
      this.pack_uint16(length);
    } else if (length <= 4294967295) {
      this._bufferBuilder.append(221);
      this.pack_uint32(length);
    } else
      throw new Error("Invalid length");
    for (let i = 0; i < length; i++)
      this.pack(ary[i]);
  }
  pack_integer(num) {
    if (num >= -32 && num <= 127)
      this._bufferBuilder.append(num & 255);
    else if (num >= 0 && num <= 255) {
      this._bufferBuilder.append(204);
      this.pack_uint8(num);
    } else if (num >= -128 && num <= 127) {
      this._bufferBuilder.append(208);
      this.pack_int8(num);
    } else if (num >= 0 && num <= 65535) {
      this._bufferBuilder.append(205);
      this.pack_uint16(num);
    } else if (num >= -32768 && num <= 32767) {
      this._bufferBuilder.append(209);
      this.pack_int16(num);
    } else if (num >= 0 && num <= 4294967295) {
      this._bufferBuilder.append(206);
      this.pack_uint32(num);
    } else if (num >= -2147483648 && num <= 2147483647) {
      this._bufferBuilder.append(210);
      this.pack_int32(num);
    } else if (num >= -9223372036854776e3 && num <= 9223372036854776e3) {
      this._bufferBuilder.append(211);
      this.pack_int64(num);
    } else if (num >= 0 && num <= 18446744073709552e3) {
      this._bufferBuilder.append(207);
      this.pack_uint64(num);
    } else
      throw new Error("Invalid integer");
  }
  pack_double(num) {
    let sign = 0;
    if (num < 0) {
      sign = 1;
      num = -num;
    }
    const exp = Math.floor(Math.log(num) / Math.LN2);
    const frac0 = num / 2 ** exp - 1;
    const frac1 = Math.floor(frac0 * 2 ** 52);
    const b32 = 2 ** 32;
    const h32 = sign << 31 | exp + 1023 << 20 | frac1 / b32 & 1048575;
    const l32 = frac1 % b32;
    this._bufferBuilder.append(203);
    this.pack_int32(h32);
    this.pack_int32(l32);
  }
  pack_object(obj) {
    const keys2 = Object.keys(obj);
    const length = keys2.length;
    if (length <= 15)
      this.pack_uint8(128 + length);
    else if (length <= 65535) {
      this._bufferBuilder.append(222);
      this.pack_uint16(length);
    } else if (length <= 4294967295) {
      this._bufferBuilder.append(223);
      this.pack_uint32(length);
    } else
      throw new Error("Invalid length");
    for (const prop in obj)
      if (obj.hasOwnProperty(prop)) {
        this.pack(prop);
        this.pack(obj[prop]);
      }
  }
  pack_uint8(num) {
    this._bufferBuilder.append(num);
  }
  pack_uint16(num) {
    this._bufferBuilder.append(num >> 8);
    this._bufferBuilder.append(num & 255);
  }
  pack_uint32(num) {
    const n = num & 4294967295;
    this._bufferBuilder.append((n & 4278190080) >>> 24);
    this._bufferBuilder.append((n & 16711680) >>> 16);
    this._bufferBuilder.append((n & 65280) >>> 8);
    this._bufferBuilder.append(n & 255);
  }
  pack_uint64(num) {
    const high = num / 2 ** 32;
    const low = num % 2 ** 32;
    this._bufferBuilder.append((high & 4278190080) >>> 24);
    this._bufferBuilder.append((high & 16711680) >>> 16);
    this._bufferBuilder.append((high & 65280) >>> 8);
    this._bufferBuilder.append(high & 255);
    this._bufferBuilder.append((low & 4278190080) >>> 24);
    this._bufferBuilder.append((low & 16711680) >>> 16);
    this._bufferBuilder.append((low & 65280) >>> 8);
    this._bufferBuilder.append(low & 255);
  }
  pack_int8(num) {
    this._bufferBuilder.append(num & 255);
  }
  pack_int16(num) {
    this._bufferBuilder.append((num & 65280) >> 8);
    this._bufferBuilder.append(num & 255);
  }
  pack_int32(num) {
    this._bufferBuilder.append(num >>> 24 & 255);
    this._bufferBuilder.append((num & 16711680) >>> 16);
    this._bufferBuilder.append((num & 65280) >>> 8);
    this._bufferBuilder.append(num & 255);
  }
  pack_int64(num) {
    const high = Math.floor(num / 2 ** 32);
    const low = num % 2 ** 32;
    this._bufferBuilder.append((high & 4278190080) >>> 24);
    this._bufferBuilder.append((high & 16711680) >>> 16);
    this._bufferBuilder.append((high & 65280) >>> 8);
    this._bufferBuilder.append(high & 255);
    this._bufferBuilder.append((low & 4278190080) >>> 24);
    this._bufferBuilder.append((low & 16711680) >>> 16);
    this._bufferBuilder.append((low & 65280) >>> 8);
    this._bufferBuilder.append(low & 255);
  }
  constructor() {
    this._bufferBuilder = new $e8379818650e2442$export$93654d4f2d6cd524();
    this._textEncoder = new TextEncoder();
  }
}
let logDisabled_ = true;
let deprecationWarnings_ = true;
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}
function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = (e) => {
      const modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [
      nativeEventName,
      wrappedCallback
    ]);
  };
  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [
      nativeEventName,
      unwrappedCb
    ]);
  };
  Object.defineProperty(proto, "on" + eventNameToWrap, {
    get() {
      return this["_on" + eventNameToWrap];
    },
    set(cb) {
      if (this["_on" + eventNameToWrap]) {
        this.removeEventListener(
          eventNameToWrap,
          this["_on" + eventNameToWrap]
        );
        delete this["_on" + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(
          eventNameToWrap,
          this["_on" + eventNameToWrap] = cb
        );
      }
    },
    enumerable: true,
    configurable: true
  });
}
function disableLog(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  logDisabled_ = bool;
  return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
function disableWarnings(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  deprecationWarnings_ = !bool;
  return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
function log() {
  if (typeof window === "object") {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, arguments);
    }
  }
}
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
function detectBrowser(window2) {
  const result = { browser: null, version: null };
  if (typeof window2 === "undefined" || !window2.navigator || !window2.navigator.userAgent) {
    result.browser = "Not a browser.";
    return result;
  }
  const { navigator: navigator2 } = window2;
  if (navigator2.mozGetUserMedia) {
    result.browser = "firefox";
    result.version = extractVersion(
      navigator2.userAgent,
      /Firefox\/(\d+)\./,
      1
    );
  } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {
    result.browser = "chrome";
    result.version = extractVersion(
      navigator2.userAgent,
      /Chrom(e|ium)\/(\d+)\./,
      2
    );
  } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    result.browser = "safari";
    result.version = extractVersion(
      navigator2.userAgent,
      /AppleWebKit\/(\d+)\./,
      1
    );
    result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
  } else {
    result.browser = "Not a supported browser.";
    return result;
  }
  return result;
}
function isObject(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function compactObject(data2) {
  if (!isObject(data2)) {
    return data2;
  }
  return Object.keys(data2).reduce(function(accumulator, key) {
    const isObj = isObject(data2[key]);
    const value = isObj ? compactObject(data2[key]) : data2[key];
    const isEmptyObject2 = isObj && !Object.keys(value).length;
    if (value === void 0 || isEmptyObject2) {
      return accumulator;
    }
    return Object.assign(accumulator, { [key]: value });
  }, {});
}
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach((name) => {
    if (name.endsWith("Id")) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith("Ids")) {
      base[name].forEach((id) => {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}
function filterStats(result, track2, outbound) {
  const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
  const filteredResult = /* @__PURE__ */ new Map();
  if (track2 === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach((value) => {
    if (value.type === "track" && value.trackIdentifier === track2.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach((trackStat) => {
    result.forEach((stats) => {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}
const logging = log;
function shimGetUserMedia$2(window2, browserDetails) {
  const navigator2 = window2 && window2.navigator;
  if (!navigator2.mediaDevices) {
    return;
  }
  const constraintsToChrome_ = function(c2) {
    if (typeof c2 !== "object" || c2.mandatory || c2.optional) {
      return c2;
    }
    const cc = {};
    Object.keys(c2).forEach((key) => {
      if (key === "require" || key === "advanced" || key === "mediaSource") {
        return;
      }
      const r = typeof c2[key] === "object" ? c2[key] : { ideal: c2[key] };
      if (r.exact !== void 0 && typeof r.exact === "number") {
        r.min = r.max = r.exact;
      }
      const oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name === "deviceId" ? "sourceId" : name;
      };
      if (r.ideal !== void 0) {
        cc.optional = cc.optional || [];
        let oc = {};
        if (typeof r.ideal === "number") {
          oc[oldname_("min", key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_("max", key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_("", key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== void 0 && typeof r.exact !== "number") {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_("", key)] = r.exact;
      } else {
        ["min", "max"].forEach((mix) => {
          if (r[mix] !== void 0) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c2.advanced) {
      cc.optional = (cc.optional || []).concat(c2.advanced);
    }
    return cc;
  };
  const shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === "object") {
      const remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, "autoGainControl", "googAutoGainControl");
      remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === "object") {
      let face = constraints.video.facingMode;
      face = face && (typeof face === "object" ? face : { ideal: face });
      const getSupportedFacingModeLies = browserDetails.version < 66;
      if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches;
        if (face.exact === "environment" || face.ideal === "environment") {
          matches = ["back", "rear"];
        } else if (face.exact === "user" || face.ideal === "user") {
          matches = ["front"];
        }
        if (matches) {
          return navigator2.mediaDevices.enumerateDevices().then((devices) => {
            devices = devices.filter((d2) => d2.kind === "videoinput");
            let dev = devices.find((d2) => matches.some((match) => d2.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches.includes("back")) {
              dev = devices[devices.length - 1];
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging("chrome: " + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging("chrome: " + JSON.stringify(constraints));
    return func(constraints);
  };
  const shimError_ = function(e) {
    if (browserDetails.version >= 64) {
      return e;
    }
    return {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  };
  const getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, (c2) => {
      navigator2.webkitGetUserMedia(c2, onSuccess, (e) => {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };
  navigator2.getUserMedia = getUserMedia_.bind(navigator2);
  if (navigator2.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, (c2) => origGetUserMedia(c2).then((stream) => {
        if (c2.audio && !stream.getAudioTracks().length || c2.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach((track2) => {
            track2.stop();
          });
          throw new DOMException("", "NotFoundError");
        }
        return stream;
      }, (e) => Promise.reject(shimError_(e))));
    };
  }
}
function shimGetDisplayMedia$1(window2, getSourceId) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  if (typeof getSourceId !== "function") {
    console.error("shimGetDisplayMedia: getSourceId argument is not a function");
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then((sourceId) => {
      const widthSpecified = constraints.video && constraints.video.width;
      const heightSpecified = constraints.video && constraints.video.height;
      const frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}
function shimMediaStream(window2) {
  window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
}
function shimOnTrack$1(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(f2) {
        if (this._ontrack) {
          this.removeEventListener("track", this._ontrack);
        }
        this.addEventListener("track", this._ontrack = f2);
      },
      enumerable: true,
      configurable: true
    });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      if (!this._ontrackpoly) {
        this._ontrackpoly = (e) => {
          e.stream.addEventListener("addtrack", (te2) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r) => r.track && r.track.id === te2.track.id);
            } else {
              receiver = { track: te2.track };
            }
            const event = new Event("track");
            event.track = te2.track;
            event.receiver = receiver;
            event.transceiver = { receiver };
            event.streams = [e.stream];
            this.dispatchEvent(event);
          });
          e.stream.getTracks().forEach((track2) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r) => r.track && r.track.id === track2.id);
            } else {
              receiver = { track: track2 };
            }
            const event = new Event("track");
            event.track = track2;
            event.receiver = receiver;
            event.transceiver = { receiver };
            event.streams = [e.stream];
            this.dispatchEvent(event);
          });
        };
        this.addEventListener("addstream", this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    wrapPeerConnectionEvent(window2, "track", (e) => {
      if (!e.transceiver) {
        Object.defineProperty(
          e,
          "transceiver",
          { value: { receiver: e.receiver } }
        );
      }
      return e;
    });
  }
}
function shimGetSendersWithDtmf(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = function(pc, track2) {
      return {
        track: track2,
        get dtmf() {
          if (this._dtmf === void 0) {
            if (track2.kind === "audio") {
              this._dtmf = pc.createDTMFSender(track2);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    };
    if (!window2.RTCPeerConnection.prototype.getSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice();
      };
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addTrack = function addTrack(track2, stream) {
        let sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track2);
          this._senders.push(sender);
        }
        return sender;
      };
      const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
      window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        const idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach((track2) => {
        this._senders.push(shimSenderWithDtmf(this, track2));
      });
    };
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);
      stream.getTracks().forEach((track2) => {
        const sender = this._senders.find((s) => s.track === track2);
        if (sender) {
          this._senders.splice(this._senders.indexOf(sender), 1);
        }
      });
    };
  } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
    Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
      get() {
        if (this._dtmf === void 0) {
          if (this.track.kind === "audio") {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}
function shimGetStats(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    if (arguments.length > 0 && typeof selector === "function") {
      return origGetStats.apply(this, arguments);
    }
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {
      return origGetStats.apply(this, []);
    }
    const fixChromeStats_ = function(response) {
      const standardReport = {};
      const reports = response.result();
      reports.forEach((report) => {
        const standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[report.type] || report.type
        };
        report.names().forEach((name) => {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });
      return standardReport;
    };
    const makeMapStats = function(stats) {
      return new Map(Object.keys(stats).map((key) => [key, stats[key]]));
    };
    if (arguments.length >= 2) {
      const successCallbackWrapper_ = function(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };
      return origGetStats.apply(this, [
        successCallbackWrapper_,
        selector
      ]);
    }
    return new Promise((resolve2, reject) => {
      origGetStats.apply(this, [
        function(response) {
          resolve2(makeMapStats(fixChromeStats_(response)));
        },
        reject
      ]);
    }).then(onSucc, onErr);
  };
}
function shimSenderReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
    return;
  }
  if (!("getStats" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window2.RTCRtpSender.prototype.getStats = function getStats() {
      const sender = this;
      return this._pc.getStats().then((result) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(result, sender.track, true)
      ));
    };
  }
  if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window2, "track", (e) => {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window2.RTCRtpReceiver.prototype.getStats = function getStats() {
      const receiver = this;
      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
    };
  }
  if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
      const track2 = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach((s) => {
        if (s.track === track2) {
          if (sender) {
            err = true;
          } else {
            sender = s;
          }
        }
      });
      this.getReceivers().forEach((r) => {
        if (r.track === track2) {
          if (receiver) {
            err = true;
          } else {
            receiver = r;
          }
        }
        return r.track === track2;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException(
          "There are more than one sender or receiver for the track.",
          "InvalidAccessError"
        ));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException(
        "There is no sender or receiver for the track.",
        "InvalidAccessError"
      ));
    }
    return origGetStats.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(window2) {
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
  };
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track2, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    stream.getTracks().forEach((track2) => {
      const alreadyExists = this.getSenders().find((s) => s.track === track2);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };
  const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          this._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (this._shimmedLocalStreams[streamId].length === 1) {
          delete this._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (window2.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window2);
  }
  const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
  window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    const nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
  };
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    stream.getTracks().forEach((track2) => {
      const alreadyExists = this.getSenders().find((s) => s.track === track2);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
    });
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window2.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };
  window2.RTCPeerConnection.prototype.addTrack = function addTrack(track2, stream) {
    if (this.signalingState === "closed") {
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    }
    const streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find((t) => t === track2)) {
      throw new DOMException(
        "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
        "NotSupportedError"
      );
    }
    const alreadyExists = this.getSenders().find((s) => s.track === track2);
    if (alreadyExists) {
      throw new DOMException(
        "Track already exists.",
        "InvalidAccessError"
      );
    }
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    const oldStream = this._streams[stream.id];
    if (oldStream) {
      oldStream.addTrack(track2);
      Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    } else {
      const newStream = new window2.MediaStream([track2]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find((s) => s.track === track2);
  };
  function replaceInternalStreamId(pc, description) {
    let sdp2 = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(
        new RegExp(internalStream.id, "g"),
        externalStream.id
      );
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  function replaceExternalStreamId(pc, description) {
    let sdp2 = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(
        new RegExp(externalStream.id, "g"),
        internalStream.id
      );
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  ["createOffer", "createAnswer"].forEach(function(method) {
    const nativeMethod = window2.RTCPeerConnection.prototype[method];
    const methodObj = { [method]() {
      const args = arguments;
      const isLegacyCall = arguments.length && typeof arguments[0] === "function";
      if (isLegacyCall) {
        return nativeMethod.apply(this, [
          (description) => {
            const desc = replaceInternalStreamId(this, description);
            args[0].apply(null, [desc]);
          },
          (err) => {
            if (args[1]) {
              args[1].apply(null, err);
            }
          },
          arguments[2]
        ]);
      }
      return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
    } };
    window2.RTCPeerConnection.prototype[method] = methodObj[method];
  });
  const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };
  const origLocalDescription = Object.getOwnPropertyDescriptor(
    window2.RTCPeerConnection.prototype,
    "localDescription"
  );
  Object.defineProperty(
    window2.RTCPeerConnection.prototype,
    "localDescription",
    {
      get() {
        const description = origLocalDescription.get.apply(this);
        if (description.type === "") {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    }
  );
  window2.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    if (this.signalingState === "closed") {
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    }
    if (!sender._pc) {
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    }
    const isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException(
        "Sender was not created by this connection.",
        "InvalidAccessError"
      );
    }
    this._streams = this._streams || {};
    let stream;
    Object.keys(this._streams).forEach((streamid) => {
      const hasTrack = this._streams[streamid].getTracks().find((track2) => sender.track === track2);
      if (hasTrack) {
        stream = this._streams[streamid];
      }
    });
    if (stream) {
      if (stream.getTracks().length === 1) {
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event("negotiationneeded"));
    }
  };
}
function shimPeerConnection$1(window2, browserDetails) {
  if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
    window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
  }
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
}
function fixNegotiationNeeded(window2, browserDetails) {
  wrapPeerConnectionEvent(window2, "negotiationneeded", (e) => {
    const pc = e.target;
    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
      if (pc.signalingState !== "stable") {
        return;
      }
    }
    return e;
  });
}
const chromeShim = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: shimGetDisplayMedia$1,
  shimGetSendersWithDtmf,
  shimGetStats,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
}, Symbol.toStringTag, { value: "Module" }));
function shimGetUserMedia$1(window2, browserDetails) {
  const navigator2 = window2 && window2.navigator;
  const MediaStreamTrack = window2 && window2.MediaStreamTrack;
  navigator2.getUserMedia = function(constraints, onSuccess, onError) {
    deprecated(
      "navigator.getUserMedia",
      "navigator.mediaDevices.getUserMedia"
    );
    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
  if (!(browserDetails.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
    const remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };
    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c2) {
      if (typeof c2 === "object" && typeof c2.audio === "object") {
        c2 = JSON.parse(JSON.stringify(c2));
        remap(c2.audio, "autoGainControl", "mozAutoGainControl");
        remap(c2.audio, "noiseSuppression", "mozNoiseSuppression");
      }
      return nativeGetUserMedia(c2);
    };
    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, "mozAutoGainControl", "autoGainControl");
        remap(obj, "mozNoiseSuppression", "noiseSuppression");
        return obj;
      };
    }
    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c2) {
        if (this.kind === "audio" && typeof c2 === "object") {
          c2 = JSON.parse(JSON.stringify(c2));
          remap(c2, "autoGainControl", "mozAutoGainControl");
          remap(c2, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeApplyConstraints.apply(this, [c2]);
      };
    }
  }
}
function shimGetDisplayMedia(window2, preferredMediaSource) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      const err = new DOMException("getDisplayMedia without video constraints is undefined");
      err.name = "NotFoundError";
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window2.navigator.mediaDevices.getUserMedia(constraints);
  };
}
function shimOnTrack(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      }
    });
  }
}
function shimPeerConnection(window2, browserDetails) {
  if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
    return;
  }
  if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
    window2.RTCPeerConnection = window2.mozRTCPeerConnection;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
  const modernStatsTypes = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  };
  const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null]).then((stats) => {
      if (browserDetails.version < 53 && !onSucc) {
        try {
          stats.forEach((stat) => {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e) {
          if (e.name !== "TypeError") {
            throw e;
          }
          stats.forEach((stat, i) => {
            stats.set(i, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}
function shimSenderGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window2.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
  }
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window2.RTCPeerConnection.prototype.addTrack = function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window2.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window2.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach((receiver) => receiver._pc = this);
      return receivers;
    };
  }
  wrapPeerConnectionEvent(window2, "track", (e) => {
    e.receiver._pc = e.srcElement;
    return e;
  });
  window2.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(window2) {
  if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
    return;
  }
  window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    deprecated("removeStream", "removeTrack");
    this.getSenders().forEach((sender) => {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        this.removeTrack(sender);
      }
    });
  };
}
function shimRTCDataChannel(window2) {
  if (window2.DataChannel && !window2.RTCDataChannel) {
    window2.RTCDataChannel = window2.DataChannel;
  }
}
function shimAddTransceiver(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window2.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      let sendEncodings = arguments[1] && arguments[1].sendEncodings;
      if (sendEncodings === void 0) {
        sendEncodings = [];
      }
      sendEncodings = [...sendEncodings];
      const shouldPerformCheck = sendEncodings.length > 0;
      if (shouldPerformCheck) {
        sendEncodings.forEach((encodingParam) => {
          if ("rid" in encodingParam) {
            const ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError("Invalid RID value provided.");
            }
          }
          if ("scaleResolutionDownBy" in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            }
          }
          if ("maxFramerate" in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError("max_framerate must be >= 0.0");
            }
          }
        });
      }
      const transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        const { sender } = transceiver;
        const params = sender.getParameters();
        if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = sendEncodings;
          sender.sendEncodings = sendEncodings;
          this.setParametersPromises.push(
            sender.setParameters(params).then(() => {
              delete sender.sendEncodings;
            }).catch(() => {
              delete sender.sendEncodings;
            })
          );
        }
      }
      return transceiver;
    };
  }
}
function shimGetParameters(window2) {
  if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window2.RTCRtpSender.prototype.getParameters = function getParameters() {
      const params = origGetParameters.apply(this, arguments);
      if (!("encodings" in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    };
  }
}
function shimCreateOffer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateOffer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimCreateAnswer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
  window2.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateAnswer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}
const firefoxShim = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
}, Symbol.toStringTag, { value: "Module" }));
function shimLocalStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!("addStream" in window2.RTCPeerConnection.prototype)) {
    const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      stream.getAudioTracks().forEach((track2) => _addTrack.call(
        this,
        track2,
        stream
      ));
      stream.getVideoTracks().forEach((track2) => _addTrack.call(
        this,
        track2,
        stream
      ));
    };
    window2.RTCPeerConnection.prototype.addTrack = function addTrack(track2, ...streams) {
      if (streams) {
        streams.forEach((stream) => {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      const index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      const tracks = stream.getTracks();
      this.getSenders().forEach((sender) => {
        if (tracks.includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
}
function shimRemoteStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(f2) {
        if (this._onaddstream) {
          this.removeEventListener("addstream", this._onaddstream);
          this.removeEventListener("track", this._onaddstreampoly);
        }
        this.addEventListener("addstream", this._onaddstream = f2);
        this.addEventListener("track", this._onaddstreampoly = (e) => {
          e.streams.forEach((stream) => {
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.includes(stream)) {
              return;
            }
            this._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            this.dispatchEvent(event);
          });
        });
      }
    });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      const pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener("track", this._onaddstreampoly = function(e) {
          e.streams.forEach((stream) => {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            pc.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    };
  }
}
function shimCallbacksAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  const prototype = window2.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;
  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  let withCallback = function(description, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;
  withCallback = function(description, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;
  withCallback = function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}
function shimGetUserMedia(window2) {
  const navigator2 = window2 && window2.navigator;
  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    const mediaDevices = navigator2.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator2.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }
  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    navigator2.getUserMedia = (function getUserMedia(constraints, cb, errcb) {
      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }).bind(navigator2);
  }
}
function shimConstraints(constraints) {
  if (constraints && constraints.video !== void 0) {
    return Object.assign(
      {},
      constraints,
      { video: compactObject(constraints.video) }
    );
  }
  return constraints;
}
function shimRTCIceServerUrls(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const OrigPeerConnection = window2.RTCPeerConnection;
  window2.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      const newIceServers = [];
      for (let i = 0; i < pcConfig.iceServers.length; i++) {
        let server = pcConfig.iceServers[i];
        if (server.urls === void 0 && server.url) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  if ("generateCertificate" in OrigPeerConnection) {
    Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
      get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}
function shimTrackEventTransceiver(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      }
    });
  }
}
function shimCreateOfferLegacy(window2) {
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === "sendrecv") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("sendonly");
          } else {
            audioTransceiver.direction = "sendonly";
          }
        } else if (audioTransceiver.direction === "recvonly") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("inactive");
          } else {
            audioTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver("audio", { direction: "recvonly" });
      }
      if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === "sendrecv") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("sendonly");
          } else {
            videoTransceiver.direction = "sendonly";
          }
        } else if (videoTransceiver.direction === "recvonly") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("inactive");
          } else {
            videoTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver("video", { direction: "recvonly" });
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimAudioContext(window2) {
  if (typeof window2 !== "object" || window2.AudioContext) {
    return;
  }
  window2.AudioContext = window2.webkitAudioContext;
}
const safariShim = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var sdp$1 = { exports: {} };
(function(module) {
  const SDPUtils2 = {};
  SDPUtils2.generateIdentifier = function() {
    return Math.random().toString(36).substring(2, 12);
  };
  SDPUtils2.localCName = SDPUtils2.generateIdentifier();
  SDPUtils2.splitLines = function(blob) {
    return blob.trim().split("\n").map((line) => line.trim());
  };
  SDPUtils2.splitSections = function(blob) {
    const parts = blob.split("\nm=");
    return parts.map((part, index) => (index > 0 ? "m=" + part : part).trim() + "\r\n");
  };
  SDPUtils2.getDescription = function(blob) {
    const sections = SDPUtils2.splitSections(blob);
    return sections && sections[0];
  };
  SDPUtils2.getMediaSections = function(blob) {
    const sections = SDPUtils2.splitSections(blob);
    sections.shift();
    return sections;
  };
  SDPUtils2.matchPrefix = function(blob, prefix) {
    return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
  };
  SDPUtils2.parseCandidate = function(line) {
    let parts;
    if (line.indexOf("a=candidate:") === 0) {
      parts = line.substring(12).split(" ");
    } else {
      parts = line.substring(10).split(" ");
    }
    const candidate = {
      foundation: parts[0],
      component: { 1: "rtp", 2: "rtcp" }[parts[1]] || parts[1],
      protocol: parts[2].toLowerCase(),
      priority: parseInt(parts[3], 10),
      ip: parts[4],
      address: parts[4],
      // address is an alias for ip.
      port: parseInt(parts[5], 10),
      // skip parts[6] == 'typ'
      type: parts[7]
    };
    for (let i = 8; i < parts.length; i += 2) {
      switch (parts[i]) {
        case "raddr":
          candidate.relatedAddress = parts[i + 1];
          break;
        case "rport":
          candidate.relatedPort = parseInt(parts[i + 1], 10);
          break;
        case "tcptype":
          candidate.tcpType = parts[i + 1];
          break;
        case "ufrag":
          candidate.ufrag = parts[i + 1];
          candidate.usernameFragment = parts[i + 1];
          break;
        default:
          if (candidate[parts[i]] === void 0) {
            candidate[parts[i]] = parts[i + 1];
          }
          break;
      }
    }
    return candidate;
  };
  SDPUtils2.writeCandidate = function(candidate) {
    const sdp2 = [];
    sdp2.push(candidate.foundation);
    const component = candidate.component;
    if (component === "rtp") {
      sdp2.push(1);
    } else if (component === "rtcp") {
      sdp2.push(2);
    } else {
      sdp2.push(component);
    }
    sdp2.push(candidate.protocol.toUpperCase());
    sdp2.push(candidate.priority);
    sdp2.push(candidate.address || candidate.ip);
    sdp2.push(candidate.port);
    const type = candidate.type;
    sdp2.push("typ");
    sdp2.push(type);
    if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
      sdp2.push("raddr");
      sdp2.push(candidate.relatedAddress);
      sdp2.push("rport");
      sdp2.push(candidate.relatedPort);
    }
    if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
      sdp2.push("tcptype");
      sdp2.push(candidate.tcpType);
    }
    if (candidate.usernameFragment || candidate.ufrag) {
      sdp2.push("ufrag");
      sdp2.push(candidate.usernameFragment || candidate.ufrag);
    }
    return "candidate:" + sdp2.join(" ");
  };
  SDPUtils2.parseIceOptions = function(line) {
    return line.substring(14).split(" ");
  };
  SDPUtils2.parseRtpMap = function(line) {
    let parts = line.substring(9).split(" ");
    const parsed = {
      payloadType: parseInt(parts.shift(), 10)
      // was: id
    };
    parts = parts[0].split("/");
    parsed.name = parts[0];
    parsed.clockRate = parseInt(parts[1], 10);
    parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
    parsed.numChannels = parsed.channels;
    return parsed;
  };
  SDPUtils2.writeRtpMap = function(codec) {
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    const channels = codec.channels || codec.numChannels || 1;
    return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
  };
  SDPUtils2.parseExtmap = function(line) {
    const parts = line.substring(9).split(" ");
    return {
      id: parseInt(parts[0], 10),
      direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
      uri: parts[1],
      attributes: parts.slice(2).join(" ")
    };
  };
  SDPUtils2.writeExtmap = function(headerExtension) {
    return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
  };
  SDPUtils2.parseFmtp = function(line) {
    const parsed = {};
    let kv;
    const parts = line.substring(line.indexOf(" ") + 1).split(";");
    for (let j = 0; j < parts.length; j++) {
      kv = parts[j].trim().split("=");
      parsed[kv[0].trim()] = kv[1];
    }
    return parsed;
  };
  SDPUtils2.writeFmtp = function(codec) {
    let line = "";
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    if (codec.parameters && Object.keys(codec.parameters).length) {
      const params = [];
      Object.keys(codec.parameters).forEach((param) => {
        if (codec.parameters[param] !== void 0) {
          params.push(param + "=" + codec.parameters[param]);
        } else {
          params.push(param);
        }
      });
      line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
    }
    return line;
  };
  SDPUtils2.parseRtcpFb = function(line) {
    const parts = line.substring(line.indexOf(" ") + 1).split(" ");
    return {
      type: parts.shift(),
      parameter: parts.join(" ")
    };
  };
  SDPUtils2.writeRtcpFb = function(codec) {
    let lines = "";
    let pt = codec.payloadType;
    if (codec.preferredPayloadType !== void 0) {
      pt = codec.preferredPayloadType;
    }
    if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
      codec.rtcpFeedback.forEach((fb) => {
        lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
      });
    }
    return lines;
  };
  SDPUtils2.parseSsrcMedia = function(line) {
    const sp = line.indexOf(" ");
    const parts = {
      ssrc: parseInt(line.substring(7, sp), 10)
    };
    const colon = line.indexOf(":", sp);
    if (colon > -1) {
      parts.attribute = line.substring(sp + 1, colon);
      parts.value = line.substring(colon + 1);
    } else {
      parts.attribute = line.substring(sp + 1);
    }
    return parts;
  };
  SDPUtils2.parseSsrcGroup = function(line) {
    const parts = line.substring(13).split(" ");
    return {
      semantics: parts.shift(),
      ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
    };
  };
  SDPUtils2.getMid = function(mediaSection) {
    const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
    if (mid) {
      return mid.substring(6);
    }
  };
  SDPUtils2.parseFingerprint = function(line) {
    const parts = line.substring(14).split(" ");
    return {
      algorithm: parts[0].toLowerCase(),
      // algorithm is case-sensitive in Edge.
      value: parts[1].toUpperCase()
      // the definition is upper-case in RFC 4572.
    };
  };
  SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.matchPrefix(
      mediaSection + sessionpart,
      "a=fingerprint:"
    );
    return {
      role: "auto",
      fingerprints: lines.map(SDPUtils2.parseFingerprint)
    };
  };
  SDPUtils2.writeDtlsParameters = function(params, setupType) {
    let sdp2 = "a=setup:" + setupType + "\r\n";
    params.fingerprints.forEach((fp) => {
      sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
    });
    return sdp2;
  };
  SDPUtils2.parseCryptoLine = function(line) {
    const parts = line.substring(9).split(" ");
    return {
      tag: parseInt(parts[0], 10),
      cryptoSuite: parts[1],
      keyParams: parts[2],
      sessionParams: parts.slice(3)
    };
  };
  SDPUtils2.writeCryptoLine = function(parameters) {
    return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
  };
  SDPUtils2.parseCryptoKeyParams = function(keyParams) {
    if (keyParams.indexOf("inline:") !== 0) {
      return null;
    }
    const parts = keyParams.substring(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: parts[0],
      lifeTime: parts[1],
      mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
      mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
    };
  };
  SDPUtils2.writeCryptoKeyParams = function(keyParams) {
    return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
  };
  SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.matchPrefix(
      mediaSection + sessionpart,
      "a=crypto:"
    );
    return lines.map(SDPUtils2.parseCryptoLine);
  };
  SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
    const ufrag = SDPUtils2.matchPrefix(
      mediaSection + sessionpart,
      "a=ice-ufrag:"
    )[0];
    const pwd = SDPUtils2.matchPrefix(
      mediaSection + sessionpart,
      "a=ice-pwd:"
    )[0];
    if (!(ufrag && pwd)) {
      return null;
    }
    return {
      usernameFragment: ufrag.substring(12),
      password: pwd.substring(10)
    };
  };
  SDPUtils2.writeIceParameters = function(params) {
    let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
    if (params.iceLite) {
      sdp2 += "a=ice-lite\r\n";
    }
    return sdp2;
  };
  SDPUtils2.parseRtpParameters = function(mediaSection) {
    const description = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    };
    const lines = SDPUtils2.splitLines(mediaSection);
    const mline = lines[0].split(" ");
    description.profile = mline[2];
    for (let i = 3; i < mline.length; i++) {
      const pt = mline[i];
      const rtpmapline = SDPUtils2.matchPrefix(
        mediaSection,
        "a=rtpmap:" + pt + " "
      )[0];
      if (rtpmapline) {
        const codec = SDPUtils2.parseRtpMap(rtpmapline);
        const fmtps = SDPUtils2.matchPrefix(
          mediaSection,
          "a=fmtp:" + pt + " "
        );
        codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
        codec.rtcpFeedback = SDPUtils2.matchPrefix(
          mediaSection,
          "a=rtcp-fb:" + pt + " "
        ).map(SDPUtils2.parseRtcpFb);
        description.codecs.push(codec);
        switch (codec.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            description.fecMechanisms.push(codec.name.toUpperCase());
            break;
        }
      }
    }
    SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
      description.headerExtensions.push(SDPUtils2.parseExtmap(line));
    });
    const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils2.parseRtcpFb);
    description.codecs.forEach((codec) => {
      wildcardRtcpFb.forEach((fb) => {
        const duplicate = codec.rtcpFeedback.find((existingFeedback) => {
          return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
        });
        if (!duplicate) {
          codec.rtcpFeedback.push(fb);
        }
      });
    });
    return description;
  };
  SDPUtils2.writeRtpDescription = function(kind, caps) {
    let sdp2 = "";
    sdp2 += "m=" + kind + " ";
    sdp2 += caps.codecs.length > 0 ? "9" : "0";
    sdp2 += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
    sdp2 += caps.codecs.map((codec) => {
      if (codec.preferredPayloadType !== void 0) {
        return codec.preferredPayloadType;
      }
      return codec.payloadType;
    }).join(" ") + "\r\n";
    sdp2 += "c=IN IP4 0.0.0.0\r\n";
    sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
    caps.codecs.forEach((codec) => {
      sdp2 += SDPUtils2.writeRtpMap(codec);
      sdp2 += SDPUtils2.writeFmtp(codec);
      sdp2 += SDPUtils2.writeRtcpFb(codec);
    });
    let maxptime = 0;
    caps.codecs.forEach((codec) => {
      if (codec.maxptime > maxptime) {
        maxptime = codec.maxptime;
      }
    });
    if (maxptime > 0) {
      sdp2 += "a=maxptime:" + maxptime + "\r\n";
    }
    if (caps.headerExtensions) {
      caps.headerExtensions.forEach((extension) => {
        sdp2 += SDPUtils2.writeExtmap(extension);
      });
    }
    return sdp2;
  };
  SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
    const encodingParameters = [];
    const description = SDPUtils2.parseRtpParameters(mediaSection);
    const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
    const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
    const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
    const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
    let secondarySsrc;
    const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
      const parts = line.substring(17).split(" ");
      return parts.map((part) => parseInt(part, 10));
    });
    if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
      secondarySsrc = flows[0][1];
    }
    description.codecs.forEach((codec) => {
      if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
        let encParam = {
          ssrc: primarySsrc,
          codecPayloadType: parseInt(codec.parameters.apt, 10)
        };
        if (primarySsrc && secondarySsrc) {
          encParam.rtx = { ssrc: secondarySsrc };
        }
        encodingParameters.push(encParam);
        if (hasRed) {
          encParam = JSON.parse(JSON.stringify(encParam));
          encParam.fec = {
            ssrc: primarySsrc,
            mechanism: hasUlpfec ? "red+ulpfec" : "red"
          };
          encodingParameters.push(encParam);
        }
      }
    });
    if (encodingParameters.length === 0 && primarySsrc) {
      encodingParameters.push({
        ssrc: primarySsrc
      });
    }
    let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
    if (bandwidth.length) {
      if (bandwidth[0].indexOf("b=TIAS:") === 0) {
        bandwidth = parseInt(bandwidth[0].substring(7), 10);
      } else if (bandwidth[0].indexOf("b=AS:") === 0) {
        bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
      } else {
        bandwidth = void 0;
      }
      encodingParameters.forEach((params) => {
        params.maxBitrate = bandwidth;
      });
    }
    return encodingParameters;
  };
  SDPUtils2.parseRtcpParameters = function(mediaSection) {
    const rtcpParameters = {};
    const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
    if (remoteSsrc) {
      rtcpParameters.cname = remoteSsrc.value;
      rtcpParameters.ssrc = remoteSsrc.ssrc;
    }
    const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
    rtcpParameters.reducedSize = rsize.length > 0;
    rtcpParameters.compound = rsize.length === 0;
    const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
    rtcpParameters.mux = mux.length > 0;
    return rtcpParameters;
  };
  SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
    let sdp2 = "";
    if (rtcpParameters.reducedSize) {
      sdp2 += "a=rtcp-rsize\r\n";
    }
    if (rtcpParameters.mux) {
      sdp2 += "a=rtcp-mux\r\n";
    }
    if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
      sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
    }
    return sdp2;
  };
  SDPUtils2.parseMsid = function(mediaSection) {
    let parts;
    const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
    if (spec.length === 1) {
      parts = spec[0].substring(7).split(" ");
      return { stream: parts[0], track: parts[1] };
    }
    const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
    if (planB.length > 0) {
      parts = planB[0].value.split(" ");
      return { stream: parts[0], track: parts[1] };
    }
  };
  SDPUtils2.parseSctpDescription = function(mediaSection) {
    const mline = SDPUtils2.parseMLine(mediaSection);
    const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
    let maxMessageSize;
    if (maxSizeLine.length > 0) {
      maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
    }
    if (isNaN(maxMessageSize)) {
      maxMessageSize = 65536;
    }
    const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
    if (sctpPort.length > 0) {
      return {
        port: parseInt(sctpPort[0].substring(12), 10),
        protocol: mline.fmt,
        maxMessageSize
      };
    }
    const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
    if (sctpMapLines.length > 0) {
      const parts = sctpMapLines[0].substring(10).split(" ");
      return {
        port: parseInt(parts[0], 10),
        protocol: parts[1],
        maxMessageSize
      };
    }
  };
  SDPUtils2.writeSctpDescription = function(media, sctp) {
    let output = [];
    if (media.protocol !== "DTLS/SCTP") {
      output = [
        "m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n",
        "c=IN IP4 0.0.0.0\r\n",
        "a=sctp-port:" + sctp.port + "\r\n"
      ];
    } else {
      output = [
        "m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n",
        "c=IN IP4 0.0.0.0\r\n",
        "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"
      ];
    }
    if (sctp.maxMessageSize !== void 0) {
      output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
    }
    return output.join("");
  };
  SDPUtils2.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  };
  SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
    let sessionId;
    const version2 = sessVer !== void 0 ? sessVer : 2;
    if (sessId) {
      sessionId = sessId;
    } else {
      sessionId = SDPUtils2.generateSessionId();
    }
    const user = sessUser || "thisisadapterortc";
    return "v=0\r\no=" + user + " " + sessionId + " " + version2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
  };
  SDPUtils2.getDirection = function(mediaSection, sessionpart) {
    const lines = SDPUtils2.splitLines(mediaSection);
    for (let i = 0; i < lines.length; i++) {
      switch (lines[i]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return lines[i].substring(2);
      }
    }
    if (sessionpart) {
      return SDPUtils2.getDirection(sessionpart);
    }
    return "sendrecv";
  };
  SDPUtils2.getKind = function(mediaSection) {
    const lines = SDPUtils2.splitLines(mediaSection);
    const mline = lines[0].split(" ");
    return mline[0].substring(2);
  };
  SDPUtils2.isRejected = function(mediaSection) {
    return mediaSection.split(" ", 2)[1] === "0";
  };
  SDPUtils2.parseMLine = function(mediaSection) {
    const lines = SDPUtils2.splitLines(mediaSection);
    const parts = lines[0].substring(2).split(" ");
    return {
      kind: parts[0],
      port: parseInt(parts[1], 10),
      protocol: parts[2],
      fmt: parts.slice(3).join(" ")
    };
  };
  SDPUtils2.parseOLine = function(mediaSection) {
    const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
    const parts = line.substring(2).split(" ");
    return {
      username: parts[0],
      sessionId: parts[1],
      sessionVersion: parseInt(parts[2], 10),
      netType: parts[3],
      addressType: parts[4],
      address: parts[5]
    };
  };
  SDPUtils2.isValidSDP = function(blob) {
    if (typeof blob !== "string" || blob.length === 0) {
      return false;
    }
    const lines = SDPUtils2.splitLines(blob);
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].length < 2 || lines[i].charAt(1) !== "=") {
        return false;
      }
    }
    return true;
  };
  {
    module.exports = SDPUtils2;
  }
})(sdp$1);
var sdpExports = sdp$1.exports;
const SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports);
const sdp = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
    return;
  }
  const NativeRTCIceCandidate = window2.RTCIceCandidate;
  window2.RTCIceCandidate = function RTCIceCandidate(args) {
    if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substring(2);
    }
    if (args.candidate && args.candidate.length) {
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = SDPUtils.parseCandidate(args.candidate);
      for (const key in parsedCandidate) {
        if (!(key in nativeCandidate)) {
          Object.defineProperty(
            nativeCandidate,
            key,
            { value: parsedCandidate[key] }
          );
        }
      }
      nativeCandidate.toJSON = function toJSON() {
        return {
          candidate: nativeCandidate.candidate,
          sdpMid: nativeCandidate.sdpMid,
          sdpMLineIndex: nativeCandidate.sdpMLineIndex,
          usernameFragment: nativeCandidate.usernameFragment
        };
      };
      return nativeCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  wrapPeerConnectionEvent(window2, "icecandidate", (e) => {
    if (e.candidate) {
      Object.defineProperty(e, "candidate", {
        value: new window2.RTCIceCandidate(e.candidate),
        writable: "false"
      });
    }
    return e;
  });
}
function shimRTCIceCandidateRelayProtocol(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "relayProtocol" in window2.RTCIceCandidate.prototype) {
    return;
  }
  wrapPeerConnectionEvent(window2, "icecandidate", (e) => {
    if (e.candidate) {
      const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);
      if (parsedCandidate.type === "relay") {
        e.candidate.relayProtocol = {
          0: "tls",
          1: "tcp",
          2: "udp"
        }[parsedCandidate.priority >> 24];
      }
    }
    return e;
  });
}
function shimMaxMessageSize(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (!("sctp" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
      get() {
        return typeof this._sctp === "undefined" ? null : this._sctp;
      }
    });
  }
  const sctpInDescription = function(description) {
    if (!description || !description.sdp) {
      return false;
    }
    const sections = SDPUtils.splitSections(description.sdp);
    sections.shift();
    return sections.some((mediaSection) => {
      const mLine = SDPUtils.parseMLine(mediaSection);
      return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
    });
  };
  const getRemoteFirefoxVersion = function(description) {
    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version2 = parseInt(match[1], 10);
    return version2 !== version2 ? -1 : version2;
  };
  const getCanSendMaxMessageSize = function(remoteIsFirefox) {
    let canSendMaxMessageSize = 65536;
    if (browserDetails.browser === "firefox") {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          canSendMaxMessageSize = 16384;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };
  const getMaxMessageSize = function(description, remoteIsFirefox) {
    let maxMessageSize = 65536;
    if (browserDetails.browser === "firefox" && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }
    const match = SDPUtils.matchPrefix(
      description.sdp,
      "a=max-message-size:"
    );
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substring(19), 10);
    } else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) {
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };
  const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
      const { sdpSemantics } = this.getConfiguration();
      if (sdpSemantics === "plan-b") {
        Object.defineProperty(this, "sctp", {
          get() {
            return typeof this._sctp === "undefined" ? null : this._sctp;
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    if (sctpInDescription(arguments[0])) {
      const isFirefox = getRemoteFirefoxVersion(arguments[0]);
      const canSendMMS = getCanSendMaxMessageSize(isFirefox);
      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
      let maxMessageSize;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }
      const sctp = {};
      Object.defineProperty(sctp, "maxMessageSize", {
        get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }
    return origSetRemoteDescription.apply(this, arguments);
  };
}
function shimSendThrowTypeError(window2) {
  if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
    return;
  }
  function wrapDcSend(dc, pc) {
    const origDataChannelSend = dc.send;
    dc.send = function send() {
      const data2 = arguments[0];
      const length = data2.length || data2.size || data2.byteLength;
      if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
      }
      return origDataChannelSend.apply(dc, arguments);
    };
  }
  const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
  window2.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    const dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  wrapPeerConnectionEvent(window2, "datachannel", (e) => {
    wrapDcSend(e.channel, e.target);
    return e;
  });
}
function shimConnectionState(window2) {
  if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  Object.defineProperty(proto, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener(
          "connectionstatechange",
          this._onconnectionstatechange
        );
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener(
          "connectionstatechange",
          this._onconnectionstatechange = cb
        );
      }
    },
    enumerable: true,
    configurable: true
  });
  ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = (e) => {
          const pc = e.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            const newEvent = new Event("connectionstatechange", e);
            pc.dispatchEvent(newEvent);
          }
          return e;
        };
        this.addEventListener(
          "iceconnectionstatechange",
          this._connectionstatechangepoly
        );
      }
      return origMethod.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails.browser === "chrome" && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === "safari" && browserDetails.version >= 605) {
    return;
  }
  const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
      const sdp2 = desc.sdp.split("\n").filter((line) => {
        return line.trim() !== "a=extmap-allow-mixed";
      }).join("\n");
      if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
        arguments[0] = new window2.RTCSessionDescription({
          type: desc.type,
          sdp: sdp2
        });
      } else {
        desc.sdp = sdp2;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(window2, browserDetails) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}
function shimParameterlessSetLocalDescription(window2, browserDetails) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    let desc = arguments[0] || {};
    if (typeof desc !== "object" || desc.type && desc.sdp) {
      return nativeSetLocalDescription.apply(this, arguments);
    }
    desc = { type: desc.type, sdp: desc.sdp };
    if (!desc.type) {
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          desc.type = "offer";
          break;
        default:
          desc.type = "answer";
          break;
      }
    }
    if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
      return nativeSetLocalDescription.apply(this, [desc]);
    }
    const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
    return func.apply(this).then((d2) => nativeSetLocalDescription.apply(this, [d2]));
  };
}
const commonShim = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError
}, Symbol.toStringTag, { value: "Module" }));
function adapterFactory({ window: window2 } = {}, options = {
  shimChrome: true,
  shimFirefox: true,
  shimSafari: true
}) {
  const logging2 = log;
  const browserDetails = detectBrowser(window2);
  const adapter2 = {
    browserDetails,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (browserDetails.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {
        logging2("Chrome shim is not included in this adapter release.");
        return adapter2;
      }
      if (browserDetails.version === null) {
        logging2("Chrome shim can not determine version, not shimming.");
        return adapter2;
      }
      logging2("adapter.js shimming chrome.");
      adapter2.browserShim = chromeShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$2(window2, browserDetails);
      shimMediaStream(window2);
      shimPeerConnection$1(window2, browserDetails);
      shimOnTrack$1(window2);
      shimAddTrackRemoveTrack(window2, browserDetails);
      shimGetSendersWithDtmf(window2);
      shimGetStats(window2);
      shimSenderReceiverGetStats(window2);
      fixNegotiationNeeded(window2, browserDetails);
      shimRTCIceCandidate(window2);
      shimRTCIceCandidateRelayProtocol(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {
        logging2("Firefox shim is not included in this adapter release.");
        return adapter2;
      }
      logging2("adapter.js shimming firefox.");
      adapter2.browserShim = firefoxShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimGetUserMedia$1(window2, browserDetails);
      shimPeerConnection(window2, browserDetails);
      shimOnTrack(window2);
      shimRemoveStream(window2);
      shimSenderGetStats(window2);
      shimReceiverGetStats(window2);
      shimRTCDataChannel(window2);
      shimAddTransceiver(window2);
      shimGetParameters(window2);
      shimCreateOffer(window2);
      shimCreateAnswer(window2);
      shimRTCIceCandidate(window2);
      shimConnectionState(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      break;
    case "safari":
      if (!safariShim || !options.shimSafari) {
        logging2("Safari shim is not included in this adapter release.");
        return adapter2;
      }
      logging2("adapter.js shimming safari.");
      adapter2.browserShim = safariShim;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2);
      shimRTCIceServerUrls(window2);
      shimCreateOfferLegacy(window2);
      shimCallbacksAPI(window2);
      shimLocalStreamsAPI(window2);
      shimRemoteStreamsAPI(window2);
      shimTrackEventTransceiver(window2);
      shimGetUserMedia(window2);
      shimAudioContext(window2);
      shimRTCIceCandidate(window2);
      shimRTCIceCandidateRelayProtocol(window2);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2);
      removeExtmapAllowMixed(window2, browserDetails);
      break;
    default:
      logging2("Unsupported browser!");
      break;
  }
  return adapter2;
}
const adapter = adapterFactory({ window: typeof window === "undefined" ? void 0 : window });
let decoder;
try {
  decoder = new TextDecoder();
} catch (error) {
}
let src;
let srcEnd;
let position$1 = 0;
const LEGACY_RECORD_INLINE_ID = 105;
const RECORD_DEFINITIONS_ID = 57342;
const RECORD_INLINE_ID = 57343;
const BUNDLED_STRINGS_ID = 57337;
const PACKED_REFERENCE_TAG_ID = 6;
const STOP_CODE = {};
let currentDecoder = {};
let currentStructures;
let srcString;
let srcStringStart = 0;
let srcStringEnd = 0;
let bundledStrings$1;
let referenceMap;
let currentExtensions = [];
let currentExtensionRanges = [];
let packedValues;
let dataView;
let restoreMapsAsObject;
let defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
let sequentialMode = false;
let inlineObjectReadThreshold = 2;
try {
  new Function("");
} catch (error) {
  inlineObjectReadThreshold = Infinity;
}
class Decoder {
  constructor(options) {
    if (options) {
      if ((options.keyMap || options._keyMap) && !options.useRecords) {
        options.useRecords = false;
        options.mapsAsObjects = true;
      }
      if (options.useRecords === false && options.mapsAsObjects === void 0)
        options.mapsAsObjects = true;
      if (options.getStructures)
        options.getShared = options.getStructures;
      if (options.getShared && !options.structures)
        (options.structures = []).uninitialized = true;
      if (options.keyMap) {
        this.mapKey = /* @__PURE__ */ new Map();
        for (let [k, v] of Object.entries(options.keyMap))
          this.mapKey.set(v, k);
      }
    }
    Object.assign(this, options);
  }
  /*
  decodeKey(key) {
  	return this.keyMap
  		? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key
  		: key
  }
  */
  decodeKey(key) {
    return this.keyMap ? this.mapKey.get(key) || key : key;
  }
  encodeKey(key) {
    return this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key;
  }
  encodeKeys(rec) {
    if (!this._keyMap)
      return rec;
    let map = /* @__PURE__ */ new Map();
    for (let [k, v] of Object.entries(rec))
      map.set(this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k, v);
    return map;
  }
  decodeKeys(map) {
    if (!this._keyMap || map.constructor.name != "Map")
      return map;
    if (!this._mapKey) {
      this._mapKey = /* @__PURE__ */ new Map();
      for (let [k, v] of Object.entries(this._keyMap))
        this._mapKey.set(v, k);
    }
    let res = {};
    map.forEach((v, k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] = v);
    return res;
  }
  mapDecode(source, end) {
    let res = this.decode(source);
    if (this._keyMap) {
      switch (res.constructor.name) {
        case "Array":
          return res.map((r) => this.decodeKeys(r));
      }
    }
    return res;
  }
  decode(source, end) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);
      });
    }
    srcEnd = end > -1 ? end : source.length;
    position$1 = 0;
    srcStringEnd = 0;
    srcString = null;
    bundledStrings$1 = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error) {
      src = null;
      if (source instanceof Uint8Array)
        throw error;
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof Decoder) {
      currentDecoder = this;
      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead();
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentDecoder = defaultOptions;
      if (!currentStructures || currentStructures.length > 0)
        currentStructures = [];
      packedValues = null;
    }
    return checkedRead();
  }
  decodeMultiple(source, forEach) {
    let values, lastPosition = 0;
    try {
      let size2 = source.length;
      sequentialMode = true;
      let value = this ? this.decode(source, size2) : defaultDecoder.decode(source, size2);
      if (forEach) {
        if (forEach(value) === false) {
          return;
        }
        while (position$1 < size2) {
          lastPosition = position$1;
          if (forEach(checkedRead()) === false) {
            return;
          }
        }
      } else {
        values = [value];
        while (position$1 < size2) {
          lastPosition = position$1;
          values.push(checkedRead());
        }
        return values;
      }
    } catch (error) {
      error.lastPosition = lastPosition;
      error.values = values;
      throw error;
    } finally {
      sequentialMode = false;
      clearSource();
    }
  }
}
function checkedRead() {
  try {
    let result = read();
    if (bundledStrings$1) {
      if (position$1 >= bundledStrings$1.postBundlePosition) {
        let error = new Error("Unexpected bundle position");
        error.incomplete = true;
        throw error;
      }
      position$1 = bundledStrings$1.postBundlePosition;
      bundledStrings$1 = null;
    }
    if (position$1 == srcEnd) {
      currentStructures = null;
      src = null;
      if (referenceMap)
        referenceMap = null;
    } else if (position$1 > srcEnd) {
      let error = new Error("Unexpected end of CBOR data");
      error.incomplete = true;
      throw error;
    } else if (!sequentialMode) {
      throw new Error("Data read, but end of buffer not reached");
    }
    return result;
  } catch (error) {
    clearSource();
    if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer")) {
      error.incomplete = true;
    }
    throw error;
  }
}
function read() {
  let token = src[position$1++];
  let majorType = token >> 5;
  token = token & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position$1++];
        break;
      case 25:
        if (majorType == 7) {
          return getFloat16();
        }
        token = dataView.getUint16(position$1);
        position$1 += 2;
        break;
      case 26:
        if (majorType == 7) {
          let value = dataView.getFloat32(position$1);
          if (currentDecoder.useFloat32 > 2) {
            let multiplier = mult10[(src[position$1] & 127) << 1 | src[position$1 + 1] >> 7];
            position$1 += 4;
            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position$1 += 4;
          return value;
        }
        token = dataView.getUint32(position$1);
        position$1 += 4;
        break;
      case 27:
        if (majorType == 7) {
          let value = dataView.getFloat64(position$1);
          position$1 += 8;
          return value;
        }
        if (majorType > 1) {
          if (dataView.getUint32(position$1) > 0)
            throw new Error("JavaScript does not support arrays, maps, or strings with length over 4294967295");
          token = dataView.getUint32(position$1 + 4);
        } else if (currentDecoder.int64AsNumber) {
          token = dataView.getUint32(position$1) * 4294967296;
          token += dataView.getUint32(position$1 + 4);
        } else
          token = dataView.getBigUint64(position$1);
        position$1 += 8;
        break;
      case 31:
        switch (majorType) {
          case 2:
          case 3:
            throw new Error("Indefinite length not supported for byte or text strings");
          case 4:
            let array = [];
            let value, i = 0;
            while ((value = read()) != STOP_CODE) {
              array[i++] = value;
            }
            return majorType == 4 ? array : majorType == 3 ? array.join("") : Buffer.concat(array);
          case 5:
            let key;
            if (currentDecoder.mapsAsObjects) {
              let object = {};
              if (currentDecoder.keyMap)
                while ((key = read()) != STOP_CODE)
                  object[safeKey(currentDecoder.decodeKey(key))] = read();
              else
                while ((key = read()) != STOP_CODE)
                  object[safeKey(key)] = read();
              return object;
            } else {
              if (restoreMapsAsObject) {
                currentDecoder.mapsAsObjects = true;
                restoreMapsAsObject = false;
              }
              let map = /* @__PURE__ */ new Map();
              if (currentDecoder.keyMap)
                while ((key = read()) != STOP_CODE)
                  map.set(currentDecoder.decodeKey(key), read());
              else
                while ((key = read()) != STOP_CODE)
                  map.set(key, read());
              return map;
            }
          case 7:
            return STOP_CODE;
          default:
            throw new Error("Invalid major type for indefinite length " + majorType);
        }
      default:
        throw new Error("Unknown token " + token);
    }
  }
  switch (majorType) {
    case 0:
      return token;
    case 1:
      return ~token;
    case 2:
      return readBin(token);
    case 3:
      if (srcStringEnd >= position$1) {
        return srcString.slice(position$1 - srcStringStart, (position$1 += token) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {
        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);
        if (string != null)
          return string;
      }
      return readFixedString(token);
    case 4:
      let array = new Array(token);
      for (let i = 0; i < token; i++)
        array[i] = read();
      return array;
    case 5:
      if (currentDecoder.mapsAsObjects) {
        let object = {};
        if (currentDecoder.keyMap)
          for (let i = 0; i < token; i++)
            object[safeKey(currentDecoder.decodeKey(read()))] = read();
        else
          for (let i = 0; i < token; i++)
            object[safeKey(read())] = read();
        return object;
      } else {
        if (restoreMapsAsObject) {
          currentDecoder.mapsAsObjects = true;
          restoreMapsAsObject = false;
        }
        let map = /* @__PURE__ */ new Map();
        if (currentDecoder.keyMap)
          for (let i = 0; i < token; i++)
            map.set(currentDecoder.decodeKey(read()), read());
        else
          for (let i = 0; i < token; i++)
            map.set(read(), read());
        return map;
      }
    case 6:
      if (token >= BUNDLED_STRINGS_ID) {
        let structure = currentStructures[token & 8191];
        if (structure) {
          if (!structure.read)
            structure.read = createStructureReader(structure);
          return structure.read();
        }
        if (token < 65536) {
          if (token == RECORD_INLINE_ID) {
            let length = readJustLength();
            let id = read();
            let structure2 = read();
            recordDefinition(id, structure2);
            let object = {};
            if (currentDecoder.keyMap)
              for (let i = 2; i < length; i++) {
                let key = currentDecoder.decodeKey(structure2[i - 2]);
                object[safeKey(key)] = read();
              }
            else
              for (let i = 2; i < length; i++) {
                let key = structure2[i - 2];
                object[safeKey(key)] = read();
              }
            return object;
          } else if (token == RECORD_DEFINITIONS_ID) {
            let length = readJustLength();
            let id = read();
            for (let i = 2; i < length; i++) {
              recordDefinition(id++, read());
            }
            return read();
          } else if (token == BUNDLED_STRINGS_ID) {
            return readBundleExt();
          }
          if (currentDecoder.getShared) {
            loadShared();
            structure = currentStructures[token & 8191];
            if (structure) {
              if (!structure.read)
                structure.read = createStructureReader(structure);
              return structure.read();
            }
          }
        }
      }
      let extension = currentExtensions[token];
      if (extension) {
        if (extension.handlesRead)
          return extension(read);
        else
          return extension(read());
      } else {
        let input = read();
        for (let i = 0; i < currentExtensionRanges.length; i++) {
          let value = currentExtensionRanges[i](token, input);
          if (value !== void 0)
            return value;
        }
        return new Tag(input, token);
      }
    case 7:
      switch (token) {
        case 20:
          return false;
        case 21:
          return true;
        case 22:
          return null;
        case 23:
          return;
        case 31:
        default:
          let packedValue = (packedValues || getPackedValues())[token];
          if (packedValue !== void 0)
            return packedValue;
          throw new Error("Unknown token " + token);
      }
    default:
      if (isNaN(token)) {
        let error = new Error("Unexpected end of CBOR data");
        error.incomplete = true;
        throw error;
      }
      throw new Error("Unknown CBOR token " + token);
  }
}
const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure) {
  function readObject() {
    let length = src[position$1++];
    length = length & 31;
    if (length > 23) {
      switch (length) {
        case 24:
          length = src[position$1++];
          break;
        case 25:
          length = dataView.getUint16(position$1);
          position$1 += 2;
          break;
        case 26:
          length = dataView.getUint32(position$1);
          position$1 += 4;
          break;
        default:
          throw new Error("Expected array header, but got " + src[position$1 - 1]);
      }
    }
    let compiledReader = this.compiledReader;
    while (compiledReader) {
      if (compiledReader.propertyCount === length)
        return compiledReader(read);
      compiledReader = compiledReader.next;
    }
    if (this.slowReads++ >= inlineObjectReadThreshold) {
      let array = this.length == length ? this : this.slice(0, length);
      compiledReader = currentDecoder.keyMap ? new Function("r", "return {" + array.map((k) => currentDecoder.decodeKey(k)).map((k) => validName.test(k) ? safeKey(k) + ":r()" : "[" + JSON.stringify(k) + "]:r()").join(",") + "}") : new Function("r", "return {" + array.map((key) => validName.test(key) ? safeKey(key) + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "}");
      if (this.compiledReader)
        compiledReader.next = this.compiledReader;
      compiledReader.propertyCount = length;
      this.compiledReader = compiledReader;
      return compiledReader(read);
    }
    let object = {};
    if (currentDecoder.keyMap)
      for (let i = 0; i < length; i++)
        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();
    else
      for (let i = 0; i < length; i++) {
        object[safeKey(this[i])] = read();
      }
    return object;
  }
  structure.slowReads = 0;
  return readObject;
}
function safeKey(key) {
  return key === "__proto__" ? "__proto_" : key;
}
let readFixedString = readStringJS;
function readStringJS(length) {
  let result;
  if (length < 16) {
    if (result = shortStringInJS(length))
      return result;
  }
  if (length > 64 && decoder)
    return decoder.decode(src.subarray(position$1, position$1 += length));
  const end = position$1 + length;
  const units = [];
  result = "";
  while (position$1 < end) {
    const byte1 = src[position$1++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position$1++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position$1++] & 63;
      const byte3 = src[position$1++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position$1++] & 63;
      const byte3 = src[position$1++] & 63;
      const byte4 = src[position$1++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
let fromCharCode = String.fromCharCode;
function longStringInJS(length) {
  let start = position$1;
  let bytes = new Array(length);
  for (let i = 0; i < length; i++) {
    const byte = src[position$1++];
    if ((byte & 128) > 0) {
      position$1 = start;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
function shortStringInJS(length) {
  if (length < 4) {
    if (length < 2) {
      if (length === 0)
        return "";
      else {
        let a = src[position$1++];
        if ((a & 128) > 1) {
          position$1 -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position$1++];
      let b = src[position$1++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position$1 -= 2;
        return;
      }
      if (length < 3)
        return fromCharCode(a, b);
      let c2 = src[position$1++];
      if ((c2 & 128) > 0) {
        position$1 -= 3;
        return;
      }
      return fromCharCode(a, b, c2);
    }
  } else {
    let a = src[position$1++];
    let b = src[position$1++];
    let c2 = src[position$1++];
    let d2 = src[position$1++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c2 & 128) > 0 || (d2 & 128) > 0) {
      position$1 -= 4;
      return;
    }
    if (length < 6) {
      if (length === 4)
        return fromCharCode(a, b, c2, d2);
      else {
        let e = src[position$1++];
        if ((e & 128) > 0) {
          position$1 -= 5;
          return;
        }
        return fromCharCode(a, b, c2, d2, e);
      }
    } else if (length < 8) {
      let e = src[position$1++];
      let f2 = src[position$1++];
      if ((e & 128) > 0 || (f2 & 128) > 0) {
        position$1 -= 6;
        return;
      }
      if (length < 7)
        return fromCharCode(a, b, c2, d2, e, f2);
      let g = src[position$1++];
      if ((g & 128) > 0) {
        position$1 -= 7;
        return;
      }
      return fromCharCode(a, b, c2, d2, e, f2, g);
    } else {
      let e = src[position$1++];
      let f2 = src[position$1++];
      let g = src[position$1++];
      let h2 = src[position$1++];
      if ((e & 128) > 0 || (f2 & 128) > 0 || (g & 128) > 0 || (h2 & 128) > 0) {
        position$1 -= 8;
        return;
      }
      if (length < 10) {
        if (length === 8)
          return fromCharCode(a, b, c2, d2, e, f2, g, h2);
        else {
          let i = src[position$1++];
          if ((i & 128) > 0) {
            position$1 -= 9;
            return;
          }
          return fromCharCode(a, b, c2, d2, e, f2, g, h2, i);
        }
      } else if (length < 12) {
        let i = src[position$1++];
        let j = src[position$1++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position$1 -= 10;
          return;
        }
        if (length < 11)
          return fromCharCode(a, b, c2, d2, e, f2, g, h2, i, j);
        let k = src[position$1++];
        if ((k & 128) > 0) {
          position$1 -= 11;
          return;
        }
        return fromCharCode(a, b, c2, d2, e, f2, g, h2, i, j, k);
      } else {
        let i = src[position$1++];
        let j = src[position$1++];
        let k = src[position$1++];
        let l = src[position$1++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position$1 -= 12;
          return;
        }
        if (length < 14) {
          if (length === 12)
            return fromCharCode(a, b, c2, d2, e, f2, g, h2, i, j, k, l);
          else {
            let m2 = src[position$1++];
            if ((m2 & 128) > 0) {
              position$1 -= 13;
              return;
            }
            return fromCharCode(a, b, c2, d2, e, f2, g, h2, i, j, k, l, m2);
          }
        } else {
          let m2 = src[position$1++];
          let n = src[position$1++];
          if ((m2 & 128) > 0 || (n & 128) > 0) {
            position$1 -= 14;
            return;
          }
          if (length < 15)
            return fromCharCode(a, b, c2, d2, e, f2, g, h2, i, j, k, l, m2, n);
          let o = src[position$1++];
          if ((o & 128) > 0) {
            position$1 -= 15;
            return;
          }
          return fromCharCode(a, b, c2, d2, e, f2, g, h2, i, j, k, l, m2, n, o);
        }
      }
    }
  }
}
function readBin(length) {
  return currentDecoder.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position$1, position$1 += length)
  ) : src.subarray(position$1, position$1 += length);
}
let f32Array = new Float32Array(1);
let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function getFloat16() {
  let byte0 = src[position$1++];
  let byte1 = src[position$1++];
  let exponent = (byte0 & 127) >> 2;
  if (exponent === 31) {
    if (byte1 || byte0 & 3)
      return NaN;
    return byte0 & 128 ? -Infinity : Infinity;
  }
  if (exponent === 0) {
    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);
    return byte0 & 128 ? -abs : abs;
  }
  u8Array[3] = byte0 & 128 | // sign bit
  (exponent >> 1) + 56;
  u8Array[2] = (byte0 & 7) << 5 | // last exponent bit and first two mantissa bits
  byte1 >> 3;
  u8Array[1] = byte1 << 5;
  u8Array[0] = 0;
  return f32Array[0];
}
new Array(4096);
class Tag {
  constructor(value, tag) {
    this.value = value;
    this.tag = tag;
  }
}
currentExtensions[0] = (dateString) => {
  return new Date(dateString);
};
currentExtensions[1] = (epochSec) => {
  return new Date(Math.round(epochSec * 1e3));
};
currentExtensions[2] = (buffer) => {
  let value = BigInt(0);
  for (let i = 0, l = buffer.byteLength; i < l; i++) {
    value = BigInt(buffer[i]) + value << BigInt(8);
  }
  return value;
};
currentExtensions[3] = (buffer) => {
  return BigInt(-1) - currentExtensions[2](buffer);
};
currentExtensions[4] = (fraction) => {
  return +(fraction[1] + "e" + fraction[0]);
};
currentExtensions[5] = (fraction) => {
  return fraction[1] * Math.exp(fraction[0] * Math.log(2));
};
const recordDefinition = (id, structure) => {
  id = id - 57344;
  let existingStructure = currentStructures[id];
  if (existingStructure && existingStructure.isShared) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
  }
  currentStructures[id] = structure;
  structure.read = createStructureReader(structure);
};
currentExtensions[LEGACY_RECORD_INLINE_ID] = (data2) => {
  let length = data2.length;
  let structure = data2[1];
  recordDefinition(data2[0], structure);
  let object = {};
  for (let i = 2; i < length; i++) {
    let key = structure[i - 2];
    object[safeKey(key)] = data2[i];
  }
  return object;
};
currentExtensions[14] = (value) => {
  if (bundledStrings$1)
    return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 += value);
  return new Tag(value, 14);
};
currentExtensions[15] = (value) => {
  if (bundledStrings$1)
    return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value);
  return new Tag(value, 15);
};
let glbl = { Error, RegExp };
currentExtensions[27] = (data2) => {
  return (glbl[data2[0]] || Error)(data2[1], data2[2]);
};
const packedTable = (read2) => {
  if (src[position$1++] != 132)
    throw new Error("Packed values structure must be followed by a 4 element array");
  let newPackedValues = read2();
  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;
  packedValues.prefixes = read2();
  packedValues.suffixes = read2();
  return read2();
};
packedTable.handlesRead = true;
currentExtensions[51] = packedTable;
currentExtensions[PACKED_REFERENCE_TAG_ID] = (data2) => {
  if (!packedValues) {
    if (currentDecoder.getShared)
      loadShared();
    else
      return new Tag(data2, PACKED_REFERENCE_TAG_ID);
  }
  if (typeof data2 == "number")
    return packedValues[16 + (data2 >= 0 ? 2 * data2 : -2 * data2 - 1)];
  throw new Error("No support for non-integer packed references yet");
};
currentExtensions[28] = (read2) => {
  if (!referenceMap) {
    referenceMap = /* @__PURE__ */ new Map();
    referenceMap.id = 0;
  }
  let id = referenceMap.id++;
  let token = src[position$1];
  let target2;
  if (token >> 5 == 4)
    target2 = [];
  else
    target2 = {};
  let refEntry = { target: target2 };
  referenceMap.set(id, refEntry);
  let targetProperties = read2();
  if (refEntry.used)
    return Object.assign(target2, targetProperties);
  refEntry.target = targetProperties;
  return targetProperties;
};
currentExtensions[28].handlesRead = true;
currentExtensions[29] = (id) => {
  let refEntry = referenceMap.get(id);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[258] = (array) => new Set(array);
(currentExtensions[259] = (read2) => {
  if (currentDecoder.mapsAsObjects) {
    currentDecoder.mapsAsObjects = false;
    restoreMapsAsObject = true;
  }
  return read2();
}).handlesRead = true;
function combine(a, b) {
  if (typeof a === "string")
    return a + b;
  if (a instanceof Array)
    return a.concat(b);
  return Object.assign({}, a, b);
}
function getPackedValues() {
  if (!packedValues) {
    if (currentDecoder.getShared)
      loadShared();
    else
      throw new Error("No packed values available");
  }
  return packedValues;
}
const SHARED_DATA_TAG_ID = 1399353956;
currentExtensionRanges.push((tag, input) => {
  if (tag >= 225 && tag <= 255)
    return combine(getPackedValues().prefixes[tag - 224], input);
  if (tag >= 28704 && tag <= 32767)
    return combine(getPackedValues().prefixes[tag - 28672], input);
  if (tag >= 1879052288 && tag <= 2147483647)
    return combine(getPackedValues().prefixes[tag - 1879048192], input);
  if (tag >= 216 && tag <= 223)
    return combine(input, getPackedValues().suffixes[tag - 216]);
  if (tag >= 27647 && tag <= 28671)
    return combine(input, getPackedValues().suffixes[tag - 27639]);
  if (tag >= 1811940352 && tag <= 1879048191)
    return combine(input, getPackedValues().suffixes[tag - 1811939328]);
  if (tag == SHARED_DATA_TAG_ID) {
    return {
      packedValues,
      structures: currentStructures.slice(0),
      version: input
    };
  }
  if (tag == 55799)
    return input;
});
const isLittleEndianMachine$1 = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
const typedArrays = [
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  typeof BigUint64Array == "undefined" ? { name: "BigUint64Array" } : BigUint64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  typeof BigInt64Array == "undefined" ? { name: "BigInt64Array" } : BigInt64Array,
  Float32Array,
  Float64Array
];
const typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86];
for (let i = 0; i < typedArrays.length; i++) {
  registerTypedArray(typedArrays[i], typedArrayTags[i]);
}
function registerTypedArray(TypedArray, tag) {
  let dvMethod = "get" + TypedArray.name.slice(0, -5);
  let bytesPerElement;
  if (typeof TypedArray === "function")
    bytesPerElement = TypedArray.BYTES_PER_ELEMENT;
  else
    TypedArray = null;
  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {
    if (!littleEndian && bytesPerElement == 1)
      continue;
    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;
    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine$1 ? (buffer) => {
      if (!TypedArray)
        throw new Error("Could not find typed array for code " + tag);
      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);
    } : (buffer) => {
      if (!TypedArray)
        throw new Error("Could not find typed array for code " + tag);
      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      let elements = buffer.length >> sizeShift;
      let ta = new TypedArray(elements);
      let method = dv[dvMethod];
      for (let i = 0; i < elements; i++) {
        ta[i] = method.call(dv, i << sizeShift, littleEndian);
      }
      return ta;
    };
  }
}
function readBundleExt() {
  let length = readJustLength();
  let bundlePosition = position$1 + read();
  for (let i = 2; i < length; i++) {
    let bundleLength = readJustLength();
    position$1 += bundleLength;
  }
  let dataPosition = position$1;
  position$1 = bundlePosition;
  bundledStrings$1 = [readStringJS(readJustLength()), readStringJS(readJustLength())];
  bundledStrings$1.position0 = 0;
  bundledStrings$1.position1 = 0;
  bundledStrings$1.postBundlePosition = position$1;
  position$1 = dataPosition;
  return read();
}
function readJustLength() {
  let token = src[position$1++] & 31;
  if (token > 23) {
    switch (token) {
      case 24:
        token = src[position$1++];
        break;
      case 25:
        token = dataView.getUint16(position$1);
        position$1 += 2;
        break;
      case 26:
        token = dataView.getUint32(position$1);
        position$1 += 4;
        break;
    }
  }
  return token;
}
function loadShared() {
  if (currentDecoder.getShared) {
    let sharedData = saveState(() => {
      src = null;
      return currentDecoder.getShared();
    }) || {};
    let updatedStructures = sharedData.structures || [];
    currentDecoder.sharedVersion = sharedData.version;
    packedValues = currentDecoder.sharedValues = sharedData.packedValues;
    if (currentStructures === true)
      currentDecoder.structures = currentStructures = updatedStructures;
    else
      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));
  }
}
function saveState(callback) {
  let savedSrcEnd = srcEnd;
  let savedPosition = position$1;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings$1;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedDecoder = currentDecoder;
  let savedSequentialMode = sequentialMode;
  let value = callback();
  srcEnd = savedSrcEnd;
  position$1 = savedPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  referenceMap = savedReferenceMap;
  bundledStrings$1 = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentDecoder = savedDecoder;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value;
}
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
const mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
}
let defaultDecoder = new Decoder({ useRecords: false });
defaultDecoder.decode;
defaultDecoder.decodeMultiple;
let textEncoder;
try {
  textEncoder = new TextEncoder();
} catch (error) {
}
let extensions, extensionClasses;
const Buffer$1 = typeof globalThis === "object" && globalThis.Buffer;
const hasNodeBuffer = typeof Buffer$1 !== "undefined";
const ByteArrayAllocate = hasNodeBuffer ? Buffer$1.allocUnsafeSlow : Uint8Array;
const ByteArray = hasNodeBuffer ? Buffer$1 : Uint8Array;
const MAX_STRUCTURES = 256;
const MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
let throwOnIterable;
let target;
let targetView;
let position = 0;
let safeEnd;
let bundledStrings = null;
const MAX_BUNDLE_SIZE = 61440;
const hasNonLatin = /[\u0080-\uFFFF]/;
const RECORD_SYMBOL = Symbol("record-id");
class Encoder extends Decoder {
  constructor(options) {
    super(options);
    this.offset = 0;
    let start;
    let sharedStructures;
    let hasSharedUpdate;
    let structures;
    let referenceMap2;
    options = options || {};
    let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position2, maxBytes) {
      return target.utf8Write(string, position2, maxBytes);
    } : textEncoder && textEncoder.encodeInto ? function(string, position2) {
      return textEncoder.encodeInto(string, target.subarray(position2)).written;
    } : false;
    let encoder = this;
    let hasSharedStructures = options.structures || options.saveStructures;
    let maxSharedStructures = options.maxSharedStructures;
    if (maxSharedStructures == null)
      maxSharedStructures = hasSharedStructures ? 128 : 0;
    if (maxSharedStructures > 8190)
      throw new Error("Maximum maxSharedStructure is 8190");
    let isSequential = options.sequential;
    if (isSequential) {
      maxSharedStructures = 0;
    }
    if (!this.structures)
      this.structures = [];
    if (this.saveStructures)
      this.saveShared = this.saveStructures;
    let samplingPackedValues, packedObjectMap2, sharedValues = options.sharedValues;
    let sharedPackedObjectMap2;
    if (sharedValues) {
      sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
      for (let i = 0, l = sharedValues.length; i < l; i++) {
        sharedPackedObjectMap2[sharedValues[i]] = i;
      }
    }
    let recordIdsToRemove = [];
    let transitionsCount = 0;
    let serializationsSinceTransitionRebuild = 0;
    this.mapEncode = function(value, encodeOptions) {
      if (this._keyMap && !this._mapped) {
        switch (value.constructor.name) {
          case "Array":
            value = value.map((r) => this.encodeKeys(r));
            break;
        }
      }
      return this.encode(value, encodeOptions);
    };
    this.encode = function(value, encodeOptions) {
      if (!target) {
        target = new ByteArrayAllocate(8192);
        targetView = new DataView(target.buffer, 0, 8192);
        position = 0;
      }
      safeEnd = target.length - 10;
      if (safeEnd - position < 2048) {
        target = new ByteArrayAllocate(target.length);
        targetView = new DataView(target.buffer, 0, target.length);
        safeEnd = target.length - 10;
        position = 0;
      } else if (encodeOptions === REUSE_BUFFER_MODE)
        position = position + 7 & 2147483640;
      start = position;
      if (encoder.useSelfDescribedHeader) {
        targetView.setUint32(position, 3654940416);
        position += 3;
      }
      referenceMap2 = encoder.structuredClone ? /* @__PURE__ */ new Map() : null;
      if (encoder.bundleStrings && typeof value !== "string") {
        bundledStrings = [];
        bundledStrings.size = Infinity;
      } else
        bundledStrings = null;
      sharedStructures = encoder.structures;
      if (sharedStructures) {
        if (sharedStructures.uninitialized) {
          let sharedData = encoder.getShared() || {};
          encoder.structures = sharedStructures = sharedData.structures || [];
          encoder.sharedVersion = sharedData.version;
          let sharedValues2 = encoder.sharedValues = sharedData.packedValues;
          if (sharedValues2) {
            sharedPackedObjectMap2 = {};
            for (let i = 0, l = sharedValues2.length; i < l; i++)
              sharedPackedObjectMap2[sharedValues2[i]] = i;
          }
        }
        let sharedStructuresLength = sharedStructures.length;
        if (sharedStructuresLength > maxSharedStructures && !isSequential)
          sharedStructuresLength = maxSharedStructures;
        if (!sharedStructures.transitions) {
          sharedStructures.transitions = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < sharedStructuresLength; i++) {
            let keys2 = sharedStructures[i];
            if (!keys2)
              continue;
            let nextTransition, transition = sharedStructures.transitions;
            for (let j = 0, l = keys2.length; j < l; j++) {
              if (transition[RECORD_SYMBOL] === void 0)
                transition[RECORD_SYMBOL] = i;
              let key = keys2[j];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              }
              transition = nextTransition;
            }
            transition[RECORD_SYMBOL] = i | 1048576;
          }
        }
        if (!isSequential)
          sharedStructures.nextId = sharedStructuresLength;
      }
      if (hasSharedUpdate)
        hasSharedUpdate = false;
      structures = sharedStructures || [];
      packedObjectMap2 = sharedPackedObjectMap2;
      if (options.pack) {
        let packedValues2 = /* @__PURE__ */ new Map();
        packedValues2.values = [];
        packedValues2.encoder = encoder;
        packedValues2.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap2 ? 16 : Infinity);
        packedValues2.objectMap = sharedPackedObjectMap2 || false;
        packedValues2.samplingPackedValues = samplingPackedValues;
        findRepetitiveStrings(value, packedValues2);
        if (packedValues2.values.length > 0) {
          target[position++] = 216;
          target[position++] = 51;
          writeArrayHeader(4);
          let valuesArray = packedValues2.values;
          encode(valuesArray);
          writeArrayHeader(0);
          writeArrayHeader(0);
          packedObjectMap2 = Object.create(sharedPackedObjectMap2 || null);
          for (let i = 0, l = valuesArray.length; i < l; i++) {
            packedObjectMap2[valuesArray[i]] = i;
          }
        }
      }
      throwOnIterable = encodeOptions & THROW_ON_ITERABLE;
      try {
        if (throwOnIterable)
          return;
        encode(value);
        if (bundledStrings) {
          writeBundles(start, encode);
        }
        encoder.offset = position;
        if (referenceMap2 && referenceMap2.idsToInsert) {
          position += referenceMap2.idsToInsert.length * 2;
          if (position > safeEnd)
            makeRoom(position);
          encoder.offset = position;
          let serialized = insertIds(target.subarray(start, position), referenceMap2.idsToInsert);
          referenceMap2 = null;
          return serialized;
        }
        if (encodeOptions & REUSE_BUFFER_MODE) {
          target.start = start;
          target.end = position;
          return target;
        }
        return target.subarray(start, position);
      } finally {
        if (sharedStructures) {
          if (serializationsSinceTransitionRebuild < 10)
            serializationsSinceTransitionRebuild++;
          if (sharedStructures.length > maxSharedStructures)
            sharedStructures.length = maxSharedStructures;
          if (transitionsCount > 1e4) {
            sharedStructures.transitions = null;
            serializationsSinceTransitionRebuild = 0;
            transitionsCount = 0;
            if (recordIdsToRemove.length > 0)
              recordIdsToRemove = [];
          } else if (recordIdsToRemove.length > 0 && !isSequential) {
            for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
              recordIdsToRemove[i][RECORD_SYMBOL] = void 0;
            }
            recordIdsToRemove = [];
          }
        }
        if (hasSharedUpdate && encoder.saveShared) {
          if (encoder.structures.length > maxSharedStructures) {
            encoder.structures = encoder.structures.slice(0, maxSharedStructures);
          }
          let returnBuffer = target.subarray(start, position);
          if (encoder.updateSharedData() === false)
            return encoder.encode(value);
          return returnBuffer;
        }
        if (encodeOptions & RESET_BUFFER_MODE)
          position = start;
      }
    };
    this.findCommonStringsToPack = () => {
      samplingPackedValues = /* @__PURE__ */ new Map();
      if (!sharedPackedObjectMap2)
        sharedPackedObjectMap2 = /* @__PURE__ */ Object.create(null);
      return (options2) => {
        let threshold = options2 && options2.threshold || 4;
        let position2 = this.pack ? options2.maxPrivatePackedValues || 16 : 0;
        if (!sharedValues)
          sharedValues = this.sharedValues = [];
        for (let [key, status] of samplingPackedValues) {
          if (status.count > threshold) {
            sharedPackedObjectMap2[key] = position2++;
            sharedValues.push(key);
            hasSharedUpdate = true;
          }
        }
        while (this.saveShared && this.updateSharedData() === false) {
        }
        samplingPackedValues = null;
      };
    };
    const encode = (value) => {
      if (position > safeEnd)
        target = makeRoom(position);
      var type = typeof value;
      var length;
      if (type === "string") {
        if (packedObjectMap2) {
          let packedPosition = packedObjectMap2[value];
          if (packedPosition >= 0) {
            if (packedPosition < 16)
              target[position++] = packedPosition + 224;
            else {
              target[position++] = 198;
              if (packedPosition & 1)
                encode(15 - packedPosition >> 1);
              else
                encode(packedPosition - 16 >> 1);
            }
            return;
          } else if (samplingPackedValues && !options.pack) {
            let status = samplingPackedValues.get(value);
            if (status)
              status.count++;
            else
              samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
        let strLength = value.length;
        if (bundledStrings && strLength >= 4 && strLength < 1024) {
          if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
            let extStart;
            let maxBytes2 = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;
            if (position + maxBytes2 > safeEnd)
              target = makeRoom(position + maxBytes2);
            target[position++] = 217;
            target[position++] = 223;
            target[position++] = 249;
            target[position++] = bundledStrings.position ? 132 : 130;
            target[position++] = 26;
            extStart = position - start;
            position += 4;
            if (bundledStrings.position) {
              writeBundles(start, encode);
            }
            bundledStrings = ["", ""];
            bundledStrings.size = 0;
            bundledStrings.position = extStart;
          }
          let twoByte = hasNonLatin.test(value);
          bundledStrings[twoByte ? 0 : 1] += value;
          target[position++] = twoByte ? 206 : 207;
          encode(strLength);
          return;
        }
        let headerSize;
        if (strLength < 32) {
          headerSize = 1;
        } else if (strLength < 256) {
          headerSize = 2;
        } else if (strLength < 65536) {
          headerSize = 3;
        } else {
          headerSize = 5;
        }
        let maxBytes = strLength * 3;
        if (position + maxBytes > safeEnd)
          target = makeRoom(position + maxBytes);
        if (strLength < 64 || !encodeUtf8) {
          let i, c1, c2, strPosition = position + headerSize;
          for (i = 0; i < strLength; i++) {
            c1 = value.charCodeAt(i);
            if (c1 < 128) {
              target[strPosition++] = c1;
            } else if (c1 < 2048) {
              target[strPosition++] = c1 >> 6 | 192;
              target[strPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target[strPosition++] = c1 >> 18 | 240;
              target[strPosition++] = c1 >> 12 & 63 | 128;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            } else {
              target[strPosition++] = c1 >> 12 | 224;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            }
          }
          length = strPosition - position - headerSize;
        } else {
          length = encodeUtf8(value, position + headerSize, maxBytes);
        }
        if (length < 24) {
          target[position++] = 96 | length;
        } else if (length < 256) {
          if (headerSize < 2) {
            target.copyWithin(position + 2, position + 1, position + 1 + length);
          }
          target[position++] = 120;
          target[position++] = length;
        } else if (length < 65536) {
          if (headerSize < 3) {
            target.copyWithin(position + 3, position + 2, position + 2 + length);
          }
          target[position++] = 121;
          target[position++] = length >> 8;
          target[position++] = length & 255;
        } else {
          if (headerSize < 5) {
            target.copyWithin(position + 5, position + 3, position + 3 + length);
          }
          target[position++] = 122;
          targetView.setUint32(position, length);
          position += 4;
        }
        position += length;
      } else if (type === "number") {
        if (!this.alwaysUseFloat && value >>> 0 === value) {
          if (value < 24) {
            target[position++] = value;
          } else if (value < 256) {
            target[position++] = 24;
            target[position++] = value;
          } else if (value < 65536) {
            target[position++] = 25;
            target[position++] = value >> 8;
            target[position++] = value & 255;
          } else {
            target[position++] = 26;
            targetView.setUint32(position, value);
            position += 4;
          }
        } else if (!this.alwaysUseFloat && value >> 0 === value) {
          if (value >= -24) {
            target[position++] = 31 - value;
          } else if (value >= -256) {
            target[position++] = 56;
            target[position++] = ~value;
          } else if (value >= -65536) {
            target[position++] = 57;
            targetView.setUint16(position, ~value);
            position += 2;
          } else {
            target[position++] = 58;
            targetView.setUint32(position, ~value);
            position += 4;
          }
        } else {
          let useFloat32;
          if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
            target[position++] = 250;
            targetView.setFloat32(position, value);
            let xShifted;
            if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
            (xShifted = value * mult10[(target[position] & 127) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {
              position += 4;
              return;
            } else
              position--;
          }
          target[position++] = 251;
          targetView.setFloat64(position, value);
          position += 8;
        }
      } else if (type === "object") {
        if (!value)
          target[position++] = 246;
        else {
          if (referenceMap2) {
            let referee = referenceMap2.get(value);
            if (referee) {
              target[position++] = 216;
              target[position++] = 29;
              target[position++] = 25;
              if (!referee.references) {
                let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                referee.references = [];
                idsToInsert.push(referee);
              }
              referee.references.push(position - start);
              position += 2;
              return;
            } else
              referenceMap2.set(value, { offset: position - start });
          }
          let constructor = value.constructor;
          if (constructor === Object) {
            writeObject(value, true);
          } else if (constructor === Array) {
            length = value.length;
            if (length < 24) {
              target[position++] = 128 | length;
            } else {
              writeArrayHeader(length);
            }
            for (let i = 0; i < length; i++) {
              encode(value[i]);
            }
          } else if (constructor === Map) {
            if (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {
              target[position++] = 217;
              target[position++] = 1;
              target[position++] = 3;
            }
            length = value.size;
            if (length < 24) {
              target[position++] = 160 | length;
            } else if (length < 256) {
              target[position++] = 184;
              target[position++] = length;
            } else if (length < 65536) {
              target[position++] = 185;
              target[position++] = length >> 8;
              target[position++] = length & 255;
            } else {
              target[position++] = 186;
              targetView.setUint32(position, length);
              position += 4;
            }
            if (encoder.keyMap) {
              for (let [key, entryValue] of value) {
                encode(encoder.encodeKey(key));
                encode(entryValue);
              }
            } else {
              for (let [key, entryValue] of value) {
                encode(key);
                encode(entryValue);
              }
            }
          } else {
            for (let i = 0, l = extensions.length; i < l; i++) {
              let extensionClass = extensionClasses[i];
              if (value instanceof extensionClass) {
                let extension = extensions[i];
                let tag = extension.tag;
                if (tag == void 0)
                  tag = extension.getTag && extension.getTag.call(this, value);
                if (tag < 24) {
                  target[position++] = 192 | tag;
                } else if (tag < 256) {
                  target[position++] = 216;
                  target[position++] = tag;
                } else if (tag < 65536) {
                  target[position++] = 217;
                  target[position++] = tag >> 8;
                  target[position++] = tag & 255;
                } else if (tag > -1) {
                  target[position++] = 218;
                  targetView.setUint32(position, tag);
                  position += 4;
                }
                extension.encode.call(this, value, encode, makeRoom);
                return;
              }
            }
            if (value[Symbol.iterator]) {
              if (throwOnIterable) {
                let error = new Error("Iterable should be serialized as iterator");
                error.iteratorNotHandled = true;
                throw error;
              }
              target[position++] = 159;
              for (let entry of value) {
                encode(entry);
              }
              target[position++] = 255;
              return;
            }
            if (value[Symbol.asyncIterator] || isBlob(value)) {
              let error = new Error("Iterable/blob should be serialized as iterator");
              error.iteratorNotHandled = true;
              throw error;
            }
            if (this.useToJSON && value.toJSON) {
              const json = value.toJSON();
              if (json !== value)
                return encode(json);
            }
            writeObject(value, !value.hasOwnProperty);
          }
        }
      } else if (type === "boolean") {
        target[position++] = value ? 245 : 244;
      } else if (type === "bigint") {
        if (value < BigInt(1) << BigInt(64) && value >= 0) {
          target[position++] = 27;
          targetView.setBigUint64(position, value);
        } else if (value > -(BigInt(1) << BigInt(64)) && value < 0) {
          target[position++] = 59;
          targetView.setBigUint64(position, -value - BigInt(1));
        } else {
          if (this.largeBigIntToFloat) {
            target[position++] = 251;
            targetView.setFloat64(position, Number(value));
          } else {
            throw new RangeError(value + " was too large to fit in CBOR 64-bit integer format, set largeBigIntToFloat to convert to float-64");
          }
        }
        position += 8;
      } else if (type === "undefined") {
        target[position++] = 247;
      } else {
        throw new Error("Unknown type: " + type);
      }
    };
    const writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {
      let keys2 = Object.keys(object);
      let vals = Object.values(object);
      let length = keys2.length;
      if (length < 24) {
        target[position++] = 160 | length;
      } else if (length < 256) {
        target[position++] = 184;
        target[position++] = length;
      } else if (length < 65536) {
        target[position++] = 185;
        target[position++] = length >> 8;
        target[position++] = length & 255;
      } else {
        target[position++] = 186;
        targetView.setUint32(position, length);
        position += 4;
      }
      if (encoder.keyMap) {
        for (let i = 0; i < length; i++) {
          encode(encoder.encodeKey(keys2[i]));
          encode(vals[i]);
        }
      } else {
        for (let i = 0; i < length; i++) {
          encode(keys2[i]);
          encode(vals[i]);
        }
      }
    } : (object, safePrototype) => {
      target[position++] = 185;
      let objectOffset = position - start;
      position += 2;
      let size2 = 0;
      if (encoder.keyMap) {
        for (let key in object)
          if (safePrototype || object.hasOwnProperty(key)) {
            encode(encoder.encodeKey(key));
            encode(object[key]);
            size2++;
          }
      } else {
        for (let key in object)
          if (safePrototype || object.hasOwnProperty(key)) {
            encode(key);
            encode(object[key]);
            size2++;
          }
      }
      target[objectOffset++ + start] = size2 >> 8;
      target[objectOffset + start] = size2 & 255;
    } : (object, safePrototype) => {
      let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
      let newTransitions = 0;
      let length = 0;
      let parentRecordId;
      let keys2;
      if (this.keyMap) {
        keys2 = Object.keys(object).map((k) => this.encodeKey(k));
        length = keys2.length;
        for (let i = 0; i < length; i++) {
          let key = keys2[i];
          nextTransition = transition[key];
          if (!nextTransition) {
            nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
            newTransitions++;
          }
          transition = nextTransition;
        }
      } else {
        for (let key in object)
          if (safePrototype || object.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (!nextTransition) {
              if (transition[RECORD_SYMBOL] & 1048576) {
                parentRecordId = transition[RECORD_SYMBOL] & 65535;
              }
              nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
            length++;
          }
      }
      let recordId = transition[RECORD_SYMBOL];
      if (recordId !== void 0) {
        recordId &= 65535;
        target[position++] = 217;
        target[position++] = recordId >> 8 | 224;
        target[position++] = recordId & 255;
      } else {
        if (!keys2)
          keys2 = transition.__keys__ || (transition.__keys__ = Object.keys(object));
        if (parentRecordId === void 0) {
          recordId = structures.nextId++;
          if (!recordId) {
            recordId = 0;
            structures.nextId = 1;
          }
          if (recordId >= MAX_STRUCTURES) {
            structures.nextId = (recordId = maxSharedStructures) + 1;
          }
        } else {
          recordId = parentRecordId;
        }
        structures[recordId] = keys2;
        if (recordId < maxSharedStructures) {
          target[position++] = 217;
          target[position++] = recordId >> 8 | 224;
          target[position++] = recordId & 255;
          transition = structures.transitions;
          for (let i = 0; i < length; i++) {
            if (transition[RECORD_SYMBOL] === void 0 || transition[RECORD_SYMBOL] & 1048576)
              transition[RECORD_SYMBOL] = recordId;
            transition = transition[keys2[i]];
          }
          transition[RECORD_SYMBOL] = recordId | 1048576;
          hasSharedUpdate = true;
        } else {
          transition[RECORD_SYMBOL] = recordId;
          targetView.setUint32(position, 3655335680);
          position += 3;
          if (newTransitions)
            transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
          if (recordIdsToRemove.length >= MAX_STRUCTURES - maxSharedStructures)
            recordIdsToRemove.shift()[RECORD_SYMBOL] = void 0;
          recordIdsToRemove.push(transition);
          writeArrayHeader(length + 2);
          encode(57344 + recordId);
          encode(keys2);
          if (safePrototype === null)
            return;
          for (let key in object)
            if (safePrototype || object.hasOwnProperty(key))
              encode(object[key]);
          return;
        }
      }
      if (length < 24) {
        target[position++] = 128 | length;
      } else {
        writeArrayHeader(length);
      }
      if (safePrototype === null)
        return;
      for (let key in object)
        if (safePrototype || object.hasOwnProperty(key))
          encode(object[key]);
    };
    const makeRoom = (end) => {
      let newSize;
      if (end > 16777216) {
        if (end - start > MAX_BUFFER_SIZE)
          throw new Error("Encoded buffer would be larger than maximum buffer size");
        newSize = Math.min(
          MAX_BUFFER_SIZE,
          Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
        );
      } else
        newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
      let newBuffer = new ByteArrayAllocate(newSize);
      targetView = new DataView(newBuffer.buffer, 0, newSize);
      if (target.copy)
        target.copy(newBuffer, 0, start, end);
      else
        newBuffer.set(target.slice(start, end));
      position -= start;
      start = 0;
      safeEnd = newBuffer.length - 10;
      return target = newBuffer;
    };
    let chunkThreshold = 100;
    let continuedChunkThreshold = 1e3;
    this.encodeAsIterable = function(value, options2) {
      return startEncoding(value, options2, encodeObjectAsIterable);
    };
    this.encodeAsAsyncIterable = function(value, options2) {
      return startEncoding(value, options2, encodeObjectAsAsyncIterable);
    };
    function* encodeObjectAsIterable(object, iterateProperties, finalIterable) {
      let constructor = object.constructor;
      if (constructor === Object) {
        let useRecords = encoder.useRecords !== false;
        if (useRecords)
          writeObject(object, null);
        else
          writeEntityLength(Object.keys(object).length, 160);
        for (let key in object) {
          let value = object[key];
          if (!useRecords)
            encode(key);
          if (value && typeof value === "object") {
            if (iterateProperties[key])
              yield* encodeObjectAsIterable(value, iterateProperties[key]);
            else
              yield* tryEncode(value, iterateProperties, key);
          } else
            encode(value);
        }
      } else if (constructor === Array) {
        let length = object.length;
        writeArrayHeader(length);
        for (let i = 0; i < length; i++) {
          let value = object[i];
          if (value && (typeof value === "object" || position - start > chunkThreshold)) {
            if (iterateProperties.element)
              yield* encodeObjectAsIterable(value, iterateProperties.element);
            else
              yield* tryEncode(value, iterateProperties, "element");
          } else
            encode(value);
        }
      } else if (object[Symbol.iterator]) {
        target[position++] = 159;
        for (let value of object) {
          if (value && (typeof value === "object" || position - start > chunkThreshold)) {
            if (iterateProperties.element)
              yield* encodeObjectAsIterable(value, iterateProperties.element);
            else
              yield* tryEncode(value, iterateProperties, "element");
          } else
            encode(value);
        }
        target[position++] = 255;
      } else if (isBlob(object)) {
        writeEntityLength(object.size, 64);
        yield target.subarray(start, position);
        yield object;
        restartEncoding();
      } else if (object[Symbol.asyncIterator]) {
        target[position++] = 159;
        yield target.subarray(start, position);
        yield object;
        restartEncoding();
        target[position++] = 255;
      } else {
        encode(object);
      }
      if (finalIterable && position > start)
        yield target.subarray(start, position);
      else if (position - start > chunkThreshold) {
        yield target.subarray(start, position);
        restartEncoding();
      }
    }
    function* tryEncode(value, iterateProperties, key) {
      let restart = position - start;
      try {
        encode(value);
        if (position - start > chunkThreshold) {
          yield target.subarray(start, position);
          restartEncoding();
        }
      } catch (error) {
        if (error.iteratorNotHandled) {
          iterateProperties[key] = {};
          position = start + restart;
          yield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);
        } else
          throw error;
      }
    }
    function restartEncoding() {
      chunkThreshold = continuedChunkThreshold;
      encoder.encode(null, THROW_ON_ITERABLE);
    }
    function startEncoding(value, options2, encodeIterable) {
      if (options2 && options2.chunkThreshold)
        chunkThreshold = continuedChunkThreshold = options2.chunkThreshold;
      else
        chunkThreshold = 100;
      if (value && typeof value === "object") {
        encoder.encode(null, THROW_ON_ITERABLE);
        return encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);
      }
      return [encoder.encode(value)];
    }
    async function* encodeObjectAsAsyncIterable(value, iterateProperties) {
      for (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {
        let constructor = encodedValue.constructor;
        if (constructor === ByteArray || constructor === Uint8Array)
          yield encodedValue;
        else if (isBlob(encodedValue)) {
          let reader = encodedValue.stream().getReader();
          let next;
          while (!(next = await reader.read()).done) {
            yield next.value;
          }
        } else if (encodedValue[Symbol.asyncIterator]) {
          for await (let asyncValue of encodedValue) {
            restartEncoding();
            if (asyncValue)
              yield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));
            else
              yield encoder.encode(asyncValue);
          }
        } else {
          yield encodedValue;
        }
      }
    }
  }
  useBuffer(buffer) {
    target = buffer;
    targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
    position = 0;
  }
  clearSharedData() {
    if (this.structures)
      this.structures = [];
    if (this.sharedValues)
      this.sharedValues = void 0;
  }
  updateSharedData() {
    let lastVersion = this.sharedVersion || 0;
    this.sharedVersion = lastVersion + 1;
    let structuresCopy = this.structures.slice(0);
    let sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion);
    let saveResults = this.saveShared(
      sharedData,
      (existingShared) => (existingShared && existingShared.version || 0) == lastVersion
    );
    if (saveResults === false) {
      sharedData = this.getShared() || {};
      this.structures = sharedData.structures || [];
      this.sharedValues = sharedData.packedValues;
      this.sharedVersion = sharedData.version;
      this.structures.nextId = this.structures.length;
    } else {
      structuresCopy.forEach((structure, i) => this.structures[i] = structure);
    }
    return saveResults;
  }
}
function writeEntityLength(length, majorValue) {
  if (length < 24)
    target[position++] = majorValue | length;
  else if (length < 256) {
    target[position++] = majorValue | 24;
    target[position++] = length;
  } else if (length < 65536) {
    target[position++] = majorValue | 25;
    target[position++] = length >> 8;
    target[position++] = length & 255;
  } else {
    target[position++] = majorValue | 26;
    targetView.setUint32(position, length);
    position += 4;
  }
}
class SharedData {
  constructor(structures, values, version2) {
    this.structures = structures;
    this.packedValues = values;
    this.version = version2;
  }
}
function writeArrayHeader(length) {
  if (length < 24)
    target[position++] = 128 | length;
  else if (length < 256) {
    target[position++] = 152;
    target[position++] = length;
  } else if (length < 65536) {
    target[position++] = 153;
    target[position++] = length >> 8;
    target[position++] = length & 255;
  } else {
    target[position++] = 154;
    targetView.setUint32(position, length);
    position += 4;
  }
}
const BlobConstructor = typeof Blob === "undefined" ? function() {
} : Blob;
function isBlob(object) {
  if (object instanceof BlobConstructor)
    return true;
  let tag = object[Symbol.toStringTag];
  return tag === "Blob" || tag === "File";
}
function findRepetitiveStrings(value, packedValues2) {
  switch (typeof value) {
    case "string":
      if (value.length > 3) {
        if (packedValues2.objectMap[value] > -1 || packedValues2.values.length >= packedValues2.maxValues)
          return;
        let packedStatus = packedValues2.get(value);
        if (packedStatus) {
          if (++packedStatus.count == 2) {
            packedValues2.values.push(value);
          }
        } else {
          packedValues2.set(value, {
            count: 1
          });
          if (packedValues2.samplingPackedValues) {
            let status = packedValues2.samplingPackedValues.get(value);
            if (status)
              status.count++;
            else
              packedValues2.samplingPackedValues.set(value, {
                count: 1
              });
          }
        }
      }
      break;
    case "object":
      if (value) {
        if (value instanceof Array) {
          for (let i = 0, l = value.length; i < l; i++) {
            findRepetitiveStrings(value[i], packedValues2);
          }
        } else {
          let includeKeys = !packedValues2.encoder.useRecords;
          for (var key in value) {
            if (value.hasOwnProperty(key)) {
              if (includeKeys)
                findRepetitiveStrings(key, packedValues2);
              findRepetitiveStrings(value[key], packedValues2);
            }
          }
        }
      }
      break;
    case "function":
      console.log(value);
  }
}
const isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;
extensionClasses = [
  Date,
  Set,
  Error,
  RegExp,
  Tag,
  ArrayBuffer,
  Uint8Array,
  Uint8ClampedArray,
  Uint16Array,
  Uint32Array,
  typeof BigUint64Array == "undefined" ? function() {
  } : BigUint64Array,
  Int8Array,
  Int16Array,
  Int32Array,
  typeof BigInt64Array == "undefined" ? function() {
  } : BigInt64Array,
  Float32Array,
  Float64Array,
  SharedData
];
extensions = [
  {
    // Date
    tag: 1,
    encode(date, encode) {
      let seconds = date.getTime() / 1e3;
      if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
        target[position++] = 26;
        targetView.setUint32(position, seconds);
        position += 4;
      } else {
        target[position++] = 251;
        targetView.setFloat64(position, seconds);
        position += 8;
      }
    }
  },
  {
    // Set
    tag: 258,
    // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
    encode(set2, encode) {
      let array = Array.from(set2);
      encode(array);
    }
  },
  {
    // Error
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(error, encode) {
      encode([error.name, error.message]);
    }
  },
  {
    // RegExp
    tag: 27,
    // http://cbor.schmorp.de/generic-object
    encode(regex, encode) {
      encode(["RegExp", regex.source, regex.flags]);
    }
  },
  {
    // Tag
    getTag(tag) {
      return tag.tag;
    },
    encode(tag, encode) {
      encode(tag.value);
    }
  },
  {
    // ArrayBuffer
    encode(arrayBuffer, encode, makeRoom) {
      writeBuffer(arrayBuffer, makeRoom);
    }
  },
  {
    // Uint8Array
    getTag(typedArray) {
      if (typedArray.constructor === Uint8Array) {
        if (this.tagUint8Array || hasNodeBuffer && this.tagUint8Array !== false)
          return 64;
      }
    },
    encode(typedArray, encode, makeRoom) {
      writeBuffer(typedArray, makeRoom);
    }
  },
  typedArrayEncoder(68, 1),
  typedArrayEncoder(69, 2),
  typedArrayEncoder(70, 4),
  typedArrayEncoder(71, 8),
  typedArrayEncoder(72, 1),
  typedArrayEncoder(77, 2),
  typedArrayEncoder(78, 4),
  typedArrayEncoder(79, 8),
  typedArrayEncoder(85, 4),
  typedArrayEncoder(86, 8),
  {
    encode(sharedData, encode) {
      let packedValues2 = sharedData.packedValues || [];
      let sharedStructures = sharedData.structures || [];
      if (packedValues2.values.length > 0) {
        target[position++] = 216;
        target[position++] = 51;
        writeArrayHeader(4);
        let valuesArray = packedValues2.values;
        encode(valuesArray);
        writeArrayHeader(0);
        writeArrayHeader(0);
        packedObjectMap = Object.create(sharedPackedObjectMap || null);
        for (let i = 0, l = valuesArray.length; i < l; i++) {
          packedObjectMap[valuesArray[i]] = i;
        }
      }
      if (sharedStructures) {
        targetView.setUint32(position, 3655335424);
        position += 3;
        let definitions = sharedStructures.slice(0);
        definitions.unshift(57344);
        definitions.push(new Tag(sharedData.version, 1399353956));
        encode(definitions);
      } else
        encode(new Tag(sharedData.version, 1399353956));
    }
  }
];
function typedArrayEncoder(tag, size2) {
  if (!isLittleEndianMachine && size2 > 1)
    tag -= 4;
  return {
    tag,
    encode: function writeExtBuffer(typedArray, encode) {
      let length = typedArray.byteLength;
      let offset = typedArray.byteOffset || 0;
      let buffer = typedArray.buffer || typedArray;
      encode(hasNodeBuffer ? Buffer$1.from(buffer, offset, length) : new Uint8Array(buffer, offset, length));
    }
  };
}
function writeBuffer(buffer, makeRoom) {
  let length = buffer.byteLength;
  if (length < 24) {
    target[position++] = 64 + length;
  } else if (length < 256) {
    target[position++] = 88;
    target[position++] = length;
  } else if (length < 65536) {
    target[position++] = 89;
    target[position++] = length >> 8;
    target[position++] = length & 255;
  } else {
    target[position++] = 90;
    targetView.setUint32(position, length);
    position += 4;
  }
  if (position + length >= target.length) {
    makeRoom(position + length);
  }
  target.set(buffer.buffer ? buffer : new Uint8Array(buffer), position);
  position += length;
}
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 2;
  let lastEnd = serialized.length - distanceToMove;
  idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
  for (let id = 0; id < idsToInsert.length; id++) {
    let referee = idsToInsert[id];
    referee.id = id;
    for (let position2 of referee.references) {
      serialized[position2++] = id >> 8;
      serialized[position2] = id & 255;
    }
  }
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 2;
    let position2 = offset + distanceToMove;
    serialized[position2++] = 216;
    serialized[position2++] = 28;
    lastEnd = offset;
  }
  return serialized;
}
function writeBundles(start, encode) {
  targetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1);
  let writeStrings = bundledStrings;
  bundledStrings = null;
  encode(writeStrings[0]);
  encode(writeStrings[1]);
}
let defaultEncoder = new Encoder({ useRecords: false });
defaultEncoder.encode;
defaultEncoder.encodeAsIterable;
defaultEncoder.encodeAsAsyncIterable;
const REUSE_BUFFER_MODE = 512;
const RESET_BUFFER_MODE = 1024;
const THROW_ON_ITERABLE = 2048;
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
class $fcbcc7538a6776d5$export$f1c5f4c9cb95390b {
  constructor() {
    this.chunkedMTU = 16300;
    this._dataCount = 1;
    this.chunk = (blob) => {
      const chunks = [];
      const size2 = blob.byteLength;
      const total = Math.ceil(size2 / this.chunkedMTU);
      let index = 0;
      let start = 0;
      while (start < size2) {
        const end = Math.min(size2, start + this.chunkedMTU);
        const b = blob.slice(start, end);
        const chunk = {
          __peerData: this._dataCount,
          n: index,
          data: b,
          total
        };
        chunks.push(chunk);
        start = end;
        index++;
      }
      this._dataCount++;
      return chunks;
    };
  }
}
function $fcbcc7538a6776d5$export$52c89ebcdc4f53f2(bufs) {
  let size2 = 0;
  for (const buf of bufs)
    size2 += buf.byteLength;
  const result = new Uint8Array(size2);
  let offset = 0;
  for (const buf of bufs) {
    result.set(buf, offset);
    offset += buf.byteLength;
  }
  return result;
}
const $fb63e766cfafaab9$var$webRTCAdapter = (
  //@ts-ignore
  adapter.default || adapter
);
const $fb63e766cfafaab9$export$25be9502477c137d = new class {
  isWebRTCSupported() {
    return typeof RTCPeerConnection !== "undefined";
  }
  isBrowserSupported() {
    const browser = this.getBrowser();
    const version2 = this.getVersion();
    const validBrowser = this.supportedBrowsers.includes(browser);
    if (!validBrowser)
      return false;
    if (browser === "chrome")
      return version2 >= this.minChromeVersion;
    if (browser === "firefox")
      return version2 >= this.minFirefoxVersion;
    if (browser === "safari")
      return !this.isIOS && version2 >= this.minSafariVersion;
    return false;
  }
  getBrowser() {
    return $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.browser;
  }
  getVersion() {
    return $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.version || 0;
  }
  isUnifiedPlanSupported() {
    const browser = this.getBrowser();
    const version2 = $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.version || 0;
    if (browser === "chrome" && version2 < this.minChromeVersion)
      return false;
    if (browser === "firefox" && version2 >= this.minFirefoxVersion)
      return true;
    if (!window.RTCRtpTransceiver || !("currentDirection" in RTCRtpTransceiver.prototype))
      return false;
    let tempPc;
    let supported = false;
    try {
      tempPc = new RTCPeerConnection();
      tempPc.addTransceiver("audio");
      supported = true;
    } catch (e) {
    } finally {
      if (tempPc)
        tempPc.close();
    }
    return supported;
  }
  toString() {
    return `Supports:
    browser:${this.getBrowser()}
    version:${this.getVersion()}
    isIOS:${this.isIOS}
    isWebRTCSupported:${this.isWebRTCSupported()}
    isBrowserSupported:${this.isBrowserSupported()}
    isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;
  }
  constructor() {
    this.isIOS = [
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform);
    this.supportedBrowsers = [
      "firefox",
      "chrome",
      "safari"
    ];
    this.minFirefoxVersion = 59;
    this.minChromeVersion = 72;
    this.minSafariVersion = 605;
  }
}();
const $9a84a32bf0bf36bb$export$f35f128fd59ea256 = (id) => {
  return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);
};
const $0e5fd1585784c252$export$4e61f672936bec77 = () => Math.random().toString(36).slice(2);
const $4f4134156c446392$var$DEFAULT_CONFIG = {
  iceServers: [
    {
      urls: "stun:stun.l.google.com:19302"
    },
    {
      urls: [
        "turn:eu-0.turn.peerjs.com:3478",
        "turn:us-0.turn.peerjs.com:3478"
      ],
      username: "peerjs",
      credential: "peerjsp"
    }
  ],
  sdpSemantics: "unified-plan"
};
class $4f4134156c446392$export$f8f26dd395d7e1bd extends $fcbcc7538a6776d5$export$f1c5f4c9cb95390b {
  noop() {
  }
  blobToArrayBuffer(blob, cb) {
    const fr = new FileReader();
    fr.onload = function(evt) {
      if (evt.target)
        cb(evt.target.result);
    };
    fr.readAsArrayBuffer(blob);
    return fr;
  }
  binaryStringToArrayBuffer(binary) {
    const byteArray = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++)
      byteArray[i] = binary.charCodeAt(i) & 255;
    return byteArray.buffer;
  }
  isSecure() {
    return location.protocol === "https:";
  }
  constructor(...args) {
    super(...args);
    this.CLOUD_HOST = "0.peerjs.com";
    this.CLOUD_PORT = 443;
    this.chunkedBrowsers = {
      Chrome: 1,
      chrome: 1
    };
    this.defaultConfig = $4f4134156c446392$var$DEFAULT_CONFIG;
    this.browser = $fb63e766cfafaab9$export$25be9502477c137d.getBrowser();
    this.browserVersion = $fb63e766cfafaab9$export$25be9502477c137d.getVersion();
    this.pack = $0cfd7828ad59115f$export$2a703dbb0cb35339;
    this.unpack = $0cfd7828ad59115f$export$417857010dc9287f;
    this.supports = function() {
      const supported = {
        browser: $fb63e766cfafaab9$export$25be9502477c137d.isBrowserSupported(),
        webRTC: $fb63e766cfafaab9$export$25be9502477c137d.isWebRTCSupported(),
        audioVideo: false,
        data: false,
        binaryBlob: false,
        reliable: false
      };
      if (!supported.webRTC)
        return supported;
      let pc;
      try {
        pc = new RTCPeerConnection($4f4134156c446392$var$DEFAULT_CONFIG);
        supported.audioVideo = true;
        let dc;
        try {
          dc = pc.createDataChannel("_PEERJSTEST", {
            ordered: true
          });
          supported.data = true;
          supported.reliable = !!dc.ordered;
          try {
            dc.binaryType = "blob";
            supported.binaryBlob = !(0, $fb63e766cfafaab9$export$25be9502477c137d).isIOS;
          } catch (e) {
          }
        } catch (e) {
        } finally {
          if (dc)
            dc.close();
        }
      } catch (e) {
      } finally {
        if (pc)
          pc.close();
      }
      return supported;
    }();
    this.validateId = $9a84a32bf0bf36bb$export$f35f128fd59ea256;
    this.randomToken = $0e5fd1585784c252$export$4e61f672936bec77;
  }
}
const $4f4134156c446392$export$7debb50ef11d5e0b = new $4f4134156c446392$export$f8f26dd395d7e1bd();
const $257947e92926277a$var$LOG_PREFIX = "PeerJS: ";
var $257947e92926277a$export$243e62d78d3b544d;
(function(LogLevel) {
  LogLevel[LogLevel[
    /**
    * Prints no logs.
    */
    "Disabled"
  ] = 0] = "Disabled";
  LogLevel[LogLevel[
    /**
    * Prints only errors.
    */
    "Errors"
  ] = 1] = "Errors";
  LogLevel[LogLevel[
    /**
    * Prints errors and warnings.
    */
    "Warnings"
  ] = 2] = "Warnings";
  LogLevel[LogLevel[
    /**
    * Prints all logs.
    */
    "All"
  ] = 3] = "All";
})($257947e92926277a$export$243e62d78d3b544d || ($257947e92926277a$export$243e62d78d3b544d = {}));
class $257947e92926277a$var$Logger {
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(logLevel) {
    this._logLevel = logLevel;
  }
  log(...args) {
    if (this._logLevel >= $257947e92926277a$export$243e62d78d3b544d.All)
      this._print($257947e92926277a$export$243e62d78d3b544d.All, ...args);
  }
  warn(...args) {
    if (this._logLevel >= $257947e92926277a$export$243e62d78d3b544d.Warnings)
      this._print($257947e92926277a$export$243e62d78d3b544d.Warnings, ...args);
  }
  error(...args) {
    if (this._logLevel >= $257947e92926277a$export$243e62d78d3b544d.Errors)
      this._print($257947e92926277a$export$243e62d78d3b544d.Errors, ...args);
  }
  setLogFunction(fn) {
    this._print = fn;
  }
  _print(logLevel, ...rest) {
    const copy = [
      $257947e92926277a$var$LOG_PREFIX,
      ...rest
    ];
    for (const i in copy)
      if (copy[i] instanceof Error)
        copy[i] = "(" + copy[i].name + ") " + copy[i].message;
    if (logLevel >= $257947e92926277a$export$243e62d78d3b544d.All)
      console.log(...copy);
    else if (logLevel >= $257947e92926277a$export$243e62d78d3b544d.Warnings)
      console.warn("WARNING", ...copy);
    else if (logLevel >= $257947e92926277a$export$243e62d78d3b544d.Errors)
      console.error("ERROR", ...copy);
  }
  constructor() {
    this._logLevel = $257947e92926277a$export$243e62d78d3b544d.Disabled;
  }
}
var $257947e92926277a$export$2e2bcd8739ae039 = new $257947e92926277a$var$Logger();
var $c4dcfd1d1ea86647$exports = {};
var $c4dcfd1d1ea86647$var$has = Object.prototype.hasOwnProperty, $c4dcfd1d1ea86647$var$prefix = "~";
function $c4dcfd1d1ea86647$var$Events() {
}
if (Object.create) {
  $c4dcfd1d1ea86647$var$Events.prototype = /* @__PURE__ */ Object.create(null);
  if (!new $c4dcfd1d1ea86647$var$Events().__proto__)
    $c4dcfd1d1ea86647$var$prefix = false;
}
function $c4dcfd1d1ea86647$var$EE(fn, context, once2) {
  this.fn = fn;
  this.context = context;
  this.once = once2 || false;
}
function $c4dcfd1d1ea86647$var$addListener(emitter, event, fn, context, once2) {
  if (typeof fn !== "function")
    throw new TypeError("The listener must be a function");
  var listener = new $c4dcfd1d1ea86647$var$EE(fn, context || emitter, once2), evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;
  if (!emitter._events[evt])
    emitter._events[evt] = listener, emitter._eventsCount++;
  else if (!emitter._events[evt].fn)
    emitter._events[evt].push(listener);
  else
    emitter._events[evt] = [
      emitter._events[evt],
      listener
    ];
  return emitter;
}
function $c4dcfd1d1ea86647$var$clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0)
    emitter._events = new $c4dcfd1d1ea86647$var$Events();
  else
    delete emitter._events[evt];
}
function $c4dcfd1d1ea86647$var$EventEmitter() {
  this._events = new $c4dcfd1d1ea86647$var$Events();
  this._eventsCount = 0;
}
$c4dcfd1d1ea86647$var$EventEmitter.prototype.eventNames = function eventNames() {
  var names = [], events, name;
  if (this._eventsCount === 0)
    return names;
  for (name in events = this._events)
    if ($c4dcfd1d1ea86647$var$has.call(events, name))
      names.push($c4dcfd1d1ea86647$var$prefix ? name.slice(1) : name);
  if (Object.getOwnPropertySymbols)
    return names.concat(Object.getOwnPropertySymbols(events));
  return names;
};
$c4dcfd1d1ea86647$var$EventEmitter.prototype.listeners = function listeners(event) {
  var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event, handlers = this._events[evt];
  if (!handlers)
    return [];
  if (handlers.fn)
    return [
      handlers.fn
    ];
  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)
    ee[i] = handlers[i].fn;
  return ee;
};
$c4dcfd1d1ea86647$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event, listeners2 = this._events[evt];
  if (!listeners2)
    return 0;
  if (listeners2.fn)
    return 1;
  return listeners2.length;
};
$c4dcfd1d1ea86647$var$EventEmitter.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
  var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;
  if (!this._events[evt])
    return false;
  var listeners2 = this._events[evt], len = arguments.length, args, i;
  if (listeners2.fn) {
    if (listeners2.once)
      this.removeListener(event, listeners2.fn, void 0, true);
    switch (len) {
      case 1:
        return listeners2.fn.call(listeners2.context), true;
      case 2:
        return listeners2.fn.call(listeners2.context, a1), true;
      case 3:
        return listeners2.fn.call(listeners2.context, a1, a2), true;
      case 4:
        return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
      case 5:
        return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
      case 6:
        return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
    }
    for (i = 1, args = new Array(len - 1); i < len; i++)
      args[i - 1] = arguments[i];
    listeners2.fn.apply(listeners2.context, args);
  } else {
    var length = listeners2.length, j;
    for (i = 0; i < length; i++) {
      if (listeners2[i].once)
        this.removeListener(event, listeners2[i].fn, void 0, true);
      switch (len) {
        case 1:
          listeners2[i].fn.call(listeners2[i].context);
          break;
        case 2:
          listeners2[i].fn.call(listeners2[i].context, a1);
          break;
        case 3:
          listeners2[i].fn.call(listeners2[i].context, a1, a2);
          break;
        case 4:
          listeners2[i].fn.call(listeners2[i].context, a1, a2, a3);
          break;
        default:
          if (!args)
            for (j = 1, args = new Array(len - 1); j < len; j++)
              args[j - 1] = arguments[j];
          listeners2[i].fn.apply(listeners2[i].context, args);
      }
    }
  }
  return true;
};
$c4dcfd1d1ea86647$var$EventEmitter.prototype.on = function on(event, fn, context) {
  return $c4dcfd1d1ea86647$var$addListener(this, event, fn, context, false);
};
$c4dcfd1d1ea86647$var$EventEmitter.prototype.once = function once(event, fn, context) {
  return $c4dcfd1d1ea86647$var$addListener(this, event, fn, context, true);
};
$c4dcfd1d1ea86647$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once2) {
  var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;
  if (!this._events[evt])
    return this;
  if (!fn) {
    $c4dcfd1d1ea86647$var$clearEvent(this, evt);
    return this;
  }
  var listeners2 = this._events[evt];
  if (listeners2.fn) {
    if (listeners2.fn === fn && (!once2 || listeners2.once) && (!context || listeners2.context === context))
      $c4dcfd1d1ea86647$var$clearEvent(this, evt);
  } else {
    for (var i = 0, events = [], length = listeners2.length; i < length; i++)
      if (listeners2[i].fn !== fn || once2 && !listeners2[i].once || context && listeners2[i].context !== context)
        events.push(listeners2[i]);
    if (events.length)
      this._events[evt] = events.length === 1 ? events[0] : events;
    else
      $c4dcfd1d1ea86647$var$clearEvent(this, evt);
  }
  return this;
};
$c4dcfd1d1ea86647$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;
  if (event) {
    evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;
    if (this._events[evt])
      $c4dcfd1d1ea86647$var$clearEvent(this, evt);
  } else {
    this._events = new $c4dcfd1d1ea86647$var$Events();
    this._eventsCount = 0;
  }
  return this;
};
$c4dcfd1d1ea86647$var$EventEmitter.prototype.off = $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeListener;
$c4dcfd1d1ea86647$var$EventEmitter.prototype.addListener = $c4dcfd1d1ea86647$var$EventEmitter.prototype.on;
$c4dcfd1d1ea86647$var$EventEmitter.prefixed = $c4dcfd1d1ea86647$var$prefix;
$c4dcfd1d1ea86647$var$EventEmitter.EventEmitter = $c4dcfd1d1ea86647$var$EventEmitter;
$c4dcfd1d1ea86647$exports = $c4dcfd1d1ea86647$var$EventEmitter;
var $78455e22dea96b8c$exports = {};
$parcel$export($78455e22dea96b8c$exports, "ConnectionType", () => $78455e22dea96b8c$export$3157d57b4135e3bc);
$parcel$export($78455e22dea96b8c$exports, "PeerErrorType", () => $78455e22dea96b8c$export$9547aaa2e39030ff);
$parcel$export($78455e22dea96b8c$exports, "BaseConnectionErrorType", () => $78455e22dea96b8c$export$7974935686149686);
$parcel$export($78455e22dea96b8c$exports, "DataConnectionErrorType", () => $78455e22dea96b8c$export$49ae800c114df41d);
$parcel$export($78455e22dea96b8c$exports, "SerializationType", () => $78455e22dea96b8c$export$89f507cf986a947);
$parcel$export($78455e22dea96b8c$exports, "SocketEventType", () => $78455e22dea96b8c$export$3b5c4a4b6354f023);
$parcel$export($78455e22dea96b8c$exports, "ServerMessageType", () => $78455e22dea96b8c$export$adb4a1754da6f10d);
var $78455e22dea96b8c$export$3157d57b4135e3bc;
(function(ConnectionType) {
  ConnectionType["Data"] = "data";
  ConnectionType["Media"] = "media";
})($78455e22dea96b8c$export$3157d57b4135e3bc || ($78455e22dea96b8c$export$3157d57b4135e3bc = {}));
var $78455e22dea96b8c$export$9547aaa2e39030ff;
(function(PeerErrorType) {
  PeerErrorType[
    /**
    * The client's browser does not support some or all WebRTC features that you are trying to use.
    */
    "BrowserIncompatible"
  ] = "browser-incompatible";
  PeerErrorType[
    /**
    * You've already disconnected this peer from the server and can no longer make any new connections on it.
    */
    "Disconnected"
  ] = "disconnected";
  PeerErrorType[
    /**
    * The ID passed into the Peer constructor contains illegal characters.
    */
    "InvalidID"
  ] = "invalid-id";
  PeerErrorType[
    /**
    * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).
    */
    "InvalidKey"
  ] = "invalid-key";
  PeerErrorType[
    /**
    * Lost or cannot establish a connection to the signalling server.
    */
    "Network"
  ] = "network";
  PeerErrorType[
    /**
    * The peer you're trying to connect to does not exist.
    */
    "PeerUnavailable"
  ] = "peer-unavailable";
  PeerErrorType[
    /**
    * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.
    */
    "SslUnavailable"
  ] = "ssl-unavailable";
  PeerErrorType[
    /**
    * Unable to reach the server.
    */
    "ServerError"
  ] = "server-error";
  PeerErrorType[
    /**
    * An error from the underlying socket.
    */
    "SocketError"
  ] = "socket-error";
  PeerErrorType[
    /**
    * The underlying socket closed unexpectedly.
    */
    "SocketClosed"
  ] = "socket-closed";
  PeerErrorType[
    /**
    * The ID passed into the Peer constructor is already taken.
    *
    * :::caution
    * This error is not fatal if your peer has open peer-to-peer connections.
    * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,
    * but its old ID has now been taken.
    * :::
    */
    "UnavailableID"
  ] = "unavailable-id";
  PeerErrorType[
    /**
    * Native WebRTC errors.
    */
    "WebRTC"
  ] = "webrtc";
})($78455e22dea96b8c$export$9547aaa2e39030ff || ($78455e22dea96b8c$export$9547aaa2e39030ff = {}));
var $78455e22dea96b8c$export$7974935686149686;
(function(BaseConnectionErrorType) {
  BaseConnectionErrorType["NegotiationFailed"] = "negotiation-failed";
  BaseConnectionErrorType["ConnectionClosed"] = "connection-closed";
})($78455e22dea96b8c$export$7974935686149686 || ($78455e22dea96b8c$export$7974935686149686 = {}));
var $78455e22dea96b8c$export$49ae800c114df41d;
(function(DataConnectionErrorType) {
  DataConnectionErrorType["NotOpenYet"] = "not-open-yet";
  DataConnectionErrorType["MessageToBig"] = "message-too-big";
})($78455e22dea96b8c$export$49ae800c114df41d || ($78455e22dea96b8c$export$49ae800c114df41d = {}));
var $78455e22dea96b8c$export$89f507cf986a947;
(function(SerializationType) {
  SerializationType["Binary"] = "binary";
  SerializationType["BinaryUTF8"] = "binary-utf8";
  SerializationType["JSON"] = "json";
  SerializationType["None"] = "raw";
})($78455e22dea96b8c$export$89f507cf986a947 || ($78455e22dea96b8c$export$89f507cf986a947 = {}));
var $78455e22dea96b8c$export$3b5c4a4b6354f023;
(function(SocketEventType) {
  SocketEventType["Message"] = "message";
  SocketEventType["Disconnected"] = "disconnected";
  SocketEventType["Error"] = "error";
  SocketEventType["Close"] = "close";
})($78455e22dea96b8c$export$3b5c4a4b6354f023 || ($78455e22dea96b8c$export$3b5c4a4b6354f023 = {}));
var $78455e22dea96b8c$export$adb4a1754da6f10d;
(function(ServerMessageType) {
  ServerMessageType["Heartbeat"] = "HEARTBEAT";
  ServerMessageType["Candidate"] = "CANDIDATE";
  ServerMessageType["Offer"] = "OFFER";
  ServerMessageType["Answer"] = "ANSWER";
  ServerMessageType["Open"] = "OPEN";
  ServerMessageType["Error"] = "ERROR";
  ServerMessageType["IdTaken"] = "ID-TAKEN";
  ServerMessageType["InvalidKey"] = "INVALID-KEY";
  ServerMessageType["Leave"] = "LEAVE";
  ServerMessageType["Expire"] = "EXPIRE";
})($78455e22dea96b8c$export$adb4a1754da6f10d || ($78455e22dea96b8c$export$adb4a1754da6f10d = {}));
var $f5f881ec4575f1fc$exports = {};
$f5f881ec4575f1fc$exports = JSON.parse('{"name":"peerjs","version":"1.5.1","keywords":["peerjs","webrtc","p2p","rtc"],"description":"PeerJS client","homepage":"https://peerjs.com","bugs":{"url":"https://github.com/peers/peerjs/issues"},"repository":{"type":"git","url":"https://github.com/peers/peerjs"},"license":"MIT","contributors":["Michelle Bu <michelle@michellebu.com>","afrokick <devbyru@gmail.com>","ericz <really.ez@gmail.com>","Jairo <kidandcat@gmail.com>","Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>","Jairo Caro-Accino Viciana <jairo@galax.be>","Carlos Caballero <carlos.caballero.gonzalez@gmail.com>","hc <hheennrryy@gmail.com>","Muhammad Asif <capripio@gmail.com>","PrashoonB <prashoonbhattacharjee@gmail.com>","Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>","akotynski <aleksanderkotbury@gmail.com>","lmb <i@lmb.io>","Jairooo <jairocaro@msn.com>","Moritz Stckler <moritz.stueckler@gmail.com>","Simon <crydotsnakegithub@gmail.com>","Denis Lukov <denismassters@gmail.com>","Philipp Hancke <fippo@andyet.net>","Hans Oksendahl <hansoksendahl@gmail.com>","Jess <jessachandler@gmail.com>","khankuan <khankuan@gmail.com>","DUODVK <kurmanov.work@gmail.com>","XiZhao <kwang1imsa@gmail.com>","Matthias Lohr <matthias@lohr.me>","=frank tree <=frnktrb@googlemail.com>","Andre Eckardt <aeckardt@outlook.com>","Chris Cowan <agentme49@gmail.com>","Alex Chuev <alex@chuev.com>","alxnull <alxnull@e.mail.de>","Yemel Jardi <angel.jardi@gmail.com>","Ben Parnell <benjaminparnell.94@gmail.com>","Benny Lichtner <bennlich@gmail.com>","fresheneesz <bitetrudpublic@gmail.com>","bob.barstead@exaptive.com <bob.barstead@exaptive.com>","chandika <chandika@gmail.com>","emersion <contact@emersion.fr>","Christopher Van <cvan@users.noreply.github.com>","eddieherm <edhermoso@gmail.com>","Eduardo Pinho <enet4mikeenet@gmail.com>","Evandro Zanatta <ezanatta@tray.net.br>","Gardner Bickford <gardner@users.noreply.github.com>","Gian Luca <gianluca.cecchi@cynny.com>","PatrickJS <github@gdi2290.com>","jonnyf <github@jonathanfoss.co.uk>","Hizkia Felix <hizkifw@gmail.com>","Hristo Oskov <hristo.oskov@gmail.com>","Isaac Madwed <i.madwed@gmail.com>","Ilya Konanykhin <ilya.konanykhin@gmail.com>","jasonbarry <jasbarry@me.com>","Jonathan Burke <jonathan.burke.1311@googlemail.com>","Josh Hamit <josh.hamit@gmail.com>","Jordan Austin <jrax86@gmail.com>","Joel Wetzell <jwetzell@yahoo.com>","xizhao <kevin.wang@cloudera.com>","Alberto Torres <kungfoobar@gmail.com>","Jonathan Mayol <mayoljonathan@gmail.com>","Jefferson Felix <me@jsfelix.dev>","Rolf Erik Lekang <me@rolflekang.com>","Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>","Pepijn de Vos <pepijndevos@gmail.com>","JooYoung <qkdlql@naver.com>","Tobias Speicher <rootcommander@gmail.com>","Steve Blaurock <sblaurock@gmail.com>","Kyrylo Shegeda <shegeda@ualberta.ca>","Diwank Singh Tomer <singh@diwank.name>","Soren Balko <Soeren.Balko@gmail.com>","Arpit Solanki <solankiarpit1997@gmail.com>","Yuki Ito <yuki@gnnk.net>","Artur Zayats <zag2art@gmail.com>"],"funding":{"type":"opencollective","url":"https://opencollective.com/peer"},"collective":{"type":"opencollective","url":"https://opencollective.com/peer"},"files":["dist/*"],"sideEffects":["lib/global.ts","lib/supports.ts"],"main":"dist/bundler.cjs","module":"dist/bundler.mjs","browser-minified":"dist/peerjs.min.js","browser-unminified":"dist/peerjs.js","browser-minified-cbor":"dist/serializer.cbor.mjs","browser-minified-msgpack":"dist/serializer.msgpack.mjs","types":"dist/types.d.ts","engines":{"node":">= 14"},"targets":{"types":{"source":"lib/exports.ts"},"main":{"source":"lib/exports.ts","sourceMap":{"inlineSources":true}},"module":{"source":"lib/exports.ts","includeNodeModules":["eventemitter3"],"sourceMap":{"inlineSources":true}},"browser-minified":{"context":"browser","outputFormat":"global","optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15"},"source":"lib/global.ts"},"browser-unminified":{"context":"browser","outputFormat":"global","optimize":false,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15"},"source":"lib/global.ts"},"browser-minified-cbor":{"context":"browser","outputFormat":"esmodule","isLibrary":true,"optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 102, safari >= 15"},"source":"lib/dataconnection/StreamConnection/Cbor.ts"},"browser-minified-msgpack":{"context":"browser","outputFormat":"esmodule","isLibrary":true,"optimize":true,"engines":{"browsers":"chrome >= 83, edge >= 83, firefox >= 102, safari >= 15"},"source":"lib/dataconnection/StreamConnection/MsgPack.ts"}},"scripts":{"contributors":"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\"chore(contributors): update and sort contributors list\\"","check":"tsc --noEmit && tsc -p e2e/tsconfig.json --noEmit","watch":"parcel watch","build":"rm -rf dist && parcel build","prepublishOnly":"npm run build","test":"jest","test:watch":"jest --watch","coverage":"jest --coverage --collectCoverageFrom=\\"./lib/**\\"","format":"prettier --write .","format:check":"prettier --check .","semantic-release":"semantic-release","e2e":"wdio run e2e/wdio.local.conf.ts","e2e:bstack":"wdio run e2e/wdio.bstack.conf.ts"},"devDependencies":{"@parcel/config-default":"^2.9.3","@parcel/packager-ts":"^2.9.3","@parcel/transformer-typescript-tsc":"^2.9.3","@parcel/transformer-typescript-types":"^2.9.3","@semantic-release/changelog":"^6.0.1","@semantic-release/git":"^10.0.1","@swc/core":"^1.3.27","@swc/jest":"^0.2.24","@types/jasmine":"^4.3.4","@wdio/browserstack-service":"^8.11.2","@wdio/cli":"^8.11.2","@wdio/globals":"^8.11.2","@wdio/jasmine-framework":"^8.11.2","@wdio/local-runner":"^8.11.2","@wdio/spec-reporter":"^8.11.2","@wdio/types":"^8.10.4","http-server":"^14.1.1","jest":"^29.3.1","jest-environment-jsdom":"^29.3.1","mock-socket":"^9.0.0","parcel":"^2.9.3","prettier":"^3.0.0","semantic-release":"^21.0.0","ts-node":"^10.9.1","typescript":"^5.0.0","wdio-geckodriver-service":"^5.0.1"},"dependencies":{"@msgpack/msgpack":"^2.8.0","cbor-x":"^1.5.3","eventemitter3":"^4.0.7","peerjs-js-binarypack":"^2.0.0","webrtc-adapter":"^8.0.0"},"alias":{"process":false,"buffer":false}}');
class $8f5bfa60836d261d$export$4798917dbf149b79 extends $c4dcfd1d1ea86647$exports.EventEmitter {
  constructor(secure, host, port, path, key, pingInterval = 5e3) {
    super();
    this.pingInterval = pingInterval;
    this._disconnected = true;
    this._messagesQueue = [];
    const wsProtocol = secure ? "wss://" : "ws://";
    this._baseUrl = wsProtocol + host + ":" + port + path + "peerjs?key=" + key;
  }
  start(id, token) {
    this._id = id;
    const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;
    if (!!this._socket || !this._disconnected)
      return;
    this._socket = new WebSocket(wsUrl + "&version=" + $f5f881ec4575f1fc$exports.version);
    this._disconnected = false;
    this._socket.onmessage = (event) => {
      let data2;
      try {
        data2 = JSON.parse(event.data);
        (0, $257947e92926277a$export$2e2bcd8739ae039).log("Server message received:", data2);
      } catch (e) {
        $257947e92926277a$export$2e2bcd8739ae039.log("Invalid server message", event.data);
        return;
      }
      this.emit($78455e22dea96b8c$export$3b5c4a4b6354f023.Message, data2);
    };
    this._socket.onclose = (event) => {
      if (this._disconnected)
        return;
      $257947e92926277a$export$2e2bcd8739ae039.log("Socket closed.", event);
      this._cleanup();
      this._disconnected = true;
      this.emit($78455e22dea96b8c$export$3b5c4a4b6354f023.Disconnected);
    };
    this._socket.onopen = () => {
      if (this._disconnected)
        return;
      this._sendQueuedMessages();
      $257947e92926277a$export$2e2bcd8739ae039.log("Socket open");
      this._scheduleHeartbeat();
    };
  }
  _scheduleHeartbeat() {
    this._wsPingTimer = setTimeout(() => {
      this._sendHeartbeat();
    }, this.pingInterval);
  }
  _sendHeartbeat() {
    if (!this._wsOpen()) {
      $257947e92926277a$export$2e2bcd8739ae039.log(`Cannot send heartbeat, because socket closed`);
      return;
    }
    const message = JSON.stringify({
      type: $78455e22dea96b8c$export$adb4a1754da6f10d.Heartbeat
    });
    this._socket.send(message);
    this._scheduleHeartbeat();
  }
  /** Is the websocket currently open? */
  _wsOpen() {
    return !!this._socket && this._socket.readyState === 1;
  }
  /** Send queued messages. */
  _sendQueuedMessages() {
    const copiedQueue = [
      ...this._messagesQueue
    ];
    this._messagesQueue = [];
    for (const message of copiedQueue)
      this.send(message);
  }
  /** Exposed send for DC & Peer. */
  send(data2) {
    if (this._disconnected)
      return;
    if (!this._id) {
      this._messagesQueue.push(data2);
      return;
    }
    if (!data2.type) {
      this.emit($78455e22dea96b8c$export$3b5c4a4b6354f023.Error, "Invalid message");
      return;
    }
    if (!this._wsOpen())
      return;
    const message = JSON.stringify(data2);
    this._socket.send(message);
  }
  close() {
    if (this._disconnected)
      return;
    this._cleanup();
    this._disconnected = true;
  }
  _cleanup() {
    if (this._socket) {
      this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;
      this._socket.close();
      this._socket = void 0;
    }
    clearTimeout(this._wsPingTimer);
  }
}
class $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a {
  constructor(connection) {
    this.connection = connection;
  }
  /** Returns a PeerConnection object set up correctly (for data, media). */
  startConnection(options) {
    const peerConnection = this._startPeerConnection();
    this.connection.peerConnection = peerConnection;
    if (this.connection.type === $78455e22dea96b8c$export$3157d57b4135e3bc.Media && options._stream)
      this._addTracksToConnection(options._stream, peerConnection);
    if (options.originator) {
      const dataConnection = this.connection;
      const config = {
        ordered: !!options.reliable
      };
      const dataChannel = peerConnection.createDataChannel(dataConnection.label, config);
      dataConnection._initializeDataChannel(dataChannel);
      this._makeOffer();
    } else
      this.handleSDP("OFFER", options.sdp);
  }
  /** Start a PC. */
  _startPeerConnection() {
    $257947e92926277a$export$2e2bcd8739ae039.log("Creating RTCPeerConnection.");
    const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);
    this._setupListeners(peerConnection);
    return peerConnection;
  }
  /** Set up various WebRTC listeners. */
  _setupListeners(peerConnection) {
    const peerId = this.connection.peer;
    const connectionId = this.connection.connectionId;
    const connectionType = this.connection.type;
    const provider = this.connection.provider;
    $257947e92926277a$export$2e2bcd8739ae039.log("Listening for ICE candidates.");
    peerConnection.onicecandidate = (evt) => {
      if (!evt.candidate || !evt.candidate.candidate)
        return;
      $257947e92926277a$export$2e2bcd8739ae039.log(`Received ICE candidates for ${peerId}:`, evt.candidate);
      provider.socket.send({
        type: $78455e22dea96b8c$export$adb4a1754da6f10d.Candidate,
        payload: {
          candidate: evt.candidate,
          type: connectionType,
          connectionId
        },
        dst: peerId
      });
    };
    peerConnection.oniceconnectionstatechange = () => {
      switch (peerConnection.iceConnectionState) {
        case "failed":
          $257947e92926277a$export$2e2bcd8739ae039.log("iceConnectionState is failed, closing connections to " + peerId);
          this.connection.emitError($78455e22dea96b8c$export$7974935686149686.NegotiationFailed, "Negotiation of connection to " + peerId + " failed.");
          this.connection.close();
          break;
        case "closed":
          $257947e92926277a$export$2e2bcd8739ae039.log("iceConnectionState is closed, closing connections to " + peerId);
          this.connection.emitError($78455e22dea96b8c$export$7974935686149686.ConnectionClosed, "Connection to " + peerId + " closed.");
          this.connection.close();
          break;
        case "disconnected":
          $257947e92926277a$export$2e2bcd8739ae039.log("iceConnectionState changed to disconnected on the connection with " + peerId);
          break;
        case "completed":
          peerConnection.onicecandidate = () => {
          };
          break;
      }
      this.connection.emit("iceStateChanged", peerConnection.iceConnectionState);
    };
    $257947e92926277a$export$2e2bcd8739ae039.log("Listening for data channel");
    peerConnection.ondatachannel = (evt) => {
      $257947e92926277a$export$2e2bcd8739ae039.log("Received data channel");
      const dataChannel = evt.channel;
      const connection = provider.getConnection(peerId, connectionId);
      connection._initializeDataChannel(dataChannel);
    };
    $257947e92926277a$export$2e2bcd8739ae039.log("Listening for remote stream");
    peerConnection.ontrack = (evt) => {
      $257947e92926277a$export$2e2bcd8739ae039.log("Received remote stream");
      const stream = evt.streams[0];
      const connection = provider.getConnection(peerId, connectionId);
      if (connection.type === $78455e22dea96b8c$export$3157d57b4135e3bc.Media) {
        const mediaConnection = connection;
        this._addStreamToMediaConnection(stream, mediaConnection);
      }
    };
  }
  cleanup() {
    $257947e92926277a$export$2e2bcd8739ae039.log("Cleaning up PeerConnection to " + this.connection.peer);
    const peerConnection = this.connection.peerConnection;
    if (!peerConnection)
      return;
    this.connection.peerConnection = null;
    peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = () => {
    };
    const peerConnectionNotClosed = peerConnection.signalingState !== "closed";
    let dataChannelNotClosed = false;
    const dataChannel = this.connection.dataChannel;
    if (dataChannel)
      dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== "closed";
    if (peerConnectionNotClosed || dataChannelNotClosed)
      peerConnection.close();
  }
  async _makeOffer() {
    const peerConnection = this.connection.peerConnection;
    const provider = this.connection.provider;
    try {
      const offer = await peerConnection.createOffer(this.connection.options.constraints);
      (0, $257947e92926277a$export$2e2bcd8739ae039).log("Created offer.");
      if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === "function")
        offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;
      try {
        await peerConnection.setLocalDescription(offer);
        (0, $257947e92926277a$export$2e2bcd8739ae039).log("Set localDescription:", offer, `for:${this.connection.peer}`);
        let payload = {
          sdp: offer,
          type: this.connection.type,
          connectionId: this.connection.connectionId,
          metadata: this.connection.metadata
        };
        if (this.connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data) {
          const dataConnection = this.connection;
          payload = {
            ...payload,
            label: dataConnection.label,
            reliable: dataConnection.reliable,
            serialization: dataConnection.serialization
          };
        }
        provider.socket.send({
          type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Offer,
          payload,
          dst: this.connection.peer
        });
      } catch (err) {
        if (err != "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer") {
          provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);
          (0, $257947e92926277a$export$2e2bcd8739ae039).log("Failed to setLocalDescription, ", err);
        }
      }
    } catch (err_1) {
      provider.emitError($78455e22dea96b8c$export$9547aaa2e39030ff.WebRTC, err_1);
      $257947e92926277a$export$2e2bcd8739ae039.log("Failed to createOffer, ", err_1);
    }
  }
  async _makeAnswer() {
    const peerConnection = this.connection.peerConnection;
    const provider = this.connection.provider;
    try {
      const answer = await peerConnection.createAnswer();
      (0, $257947e92926277a$export$2e2bcd8739ae039).log("Created answer.");
      if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === "function")
        answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;
      try {
        await peerConnection.setLocalDescription(answer);
        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Set localDescription:`, answer, `for:${this.connection.peer}`);
        provider.socket.send({
          type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer,
          payload: {
            sdp: answer,
            type: this.connection.type,
            connectionId: this.connection.connectionId
          },
          dst: this.connection.peer
        });
      } catch (err) {
        provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);
        (0, $257947e92926277a$export$2e2bcd8739ae039).log("Failed to setLocalDescription, ", err);
      }
    } catch (err_1) {
      provider.emitError($78455e22dea96b8c$export$9547aaa2e39030ff.WebRTC, err_1);
      $257947e92926277a$export$2e2bcd8739ae039.log("Failed to create answer, ", err_1);
    }
  }
  /** Handle an SDP. */
  async handleSDP(type, sdp2) {
    sdp2 = new RTCSessionDescription(sdp2);
    const peerConnection = this.connection.peerConnection;
    const provider = this.connection.provider;
    $257947e92926277a$export$2e2bcd8739ae039.log("Setting remote description", sdp2);
    const self2 = this;
    try {
      await peerConnection.setRemoteDescription(sdp2);
      (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Set remoteDescription:${type} for:${this.connection.peer}`);
      if (type === "OFFER")
        await self2._makeAnswer();
    } catch (err) {
      provider.emitError($78455e22dea96b8c$export$9547aaa2e39030ff.WebRTC, err);
      $257947e92926277a$export$2e2bcd8739ae039.log("Failed to setRemoteDescription, ", err);
    }
  }
  /** Handle a candidate. */
  async handleCandidate(ice) {
    $257947e92926277a$export$2e2bcd8739ae039.log(`handleCandidate:`, ice);
    try {
      await this.connection.peerConnection.addIceCandidate(ice);
      (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Added ICE candidate for:${this.connection.peer}`);
    } catch (err) {
      this.connection.provider.emitError($78455e22dea96b8c$export$9547aaa2e39030ff.WebRTC, err);
      $257947e92926277a$export$2e2bcd8739ae039.log("Failed to handleCandidate, ", err);
    }
  }
  _addTracksToConnection(stream, peerConnection) {
    $257947e92926277a$export$2e2bcd8739ae039.log(`add tracks from stream ${stream.id} to peer connection`);
    if (!peerConnection.addTrack)
      return $257947e92926277a$export$2e2bcd8739ae039.error(`Your browser does't support RTCPeerConnection#addTrack. Ignored.`);
    stream.getTracks().forEach((track2) => {
      peerConnection.addTrack(track2, stream);
    });
  }
  _addStreamToMediaConnection(stream, mediaConnection) {
    $257947e92926277a$export$2e2bcd8739ae039.log(`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`);
    mediaConnection.addStream(stream);
  }
}
class $23779d1881157a18$export$6a678e589c8a4542 extends $c4dcfd1d1ea86647$exports.EventEmitter {
  /**
  * Emits a typed error message.
  *
  * @internal
  */
  emitError(type, err) {
    $257947e92926277a$export$2e2bcd8739ae039.error("Error:", err);
    this.emit("error", new $23779d1881157a18$export$98871882f492de82(`${type}`, err));
  }
}
class $23779d1881157a18$export$98871882f492de82 extends Error {
  /**
  * @internal
  */
  constructor(type, err) {
    if (typeof err === "string")
      super(err);
    else {
      super();
      Object.assign(this, err);
    }
    this.type = type;
  }
}
class $5045192fc6d387ba$export$23a2a68283c24d80 extends $23779d1881157a18$export$6a678e589c8a4542 {
  /**
  * Whether the media connection is active (e.g. your call has been answered).
  * You can check this if you want to set a maximum wait time for a one-sided call.
  */
  get open() {
    return this._open;
  }
  constructor(peer, provider, options) {
    super();
    this.peer = peer;
    this.provider = provider;
    this.options = options;
    this._open = false;
    this.metadata = options.metadata;
  }
}
const _$5c1d08c7c57da9a3$export$4a84e95a2324ac29 = class _$5c1d08c7c57da9a3$export$4a84e95a2324ac29 extends $5045192fc6d387ba$export$23a2a68283c24d80 {
  /**
  * For media connections, this is always 'media'.
  */
  get type() {
    return $78455e22dea96b8c$export$3157d57b4135e3bc.Media;
  }
  get localStream() {
    return this._localStream;
  }
  get remoteStream() {
    return this._remoteStream;
  }
  constructor(peerId, provider, options) {
    super(peerId, provider, options);
    this._localStream = this.options._stream;
    this.connectionId = this.options.connectionId || _$5c1d08c7c57da9a3$export$4a84e95a2324ac29.ID_PREFIX + $4f4134156c446392$export$7debb50ef11d5e0b.randomToken();
    this._negotiator = new $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a(this);
    if (this._localStream)
      this._negotiator.startConnection({
        _stream: this._localStream,
        originator: true
      });
  }
  /** Called by the Negotiator when the DataChannel is ready. */
  _initializeDataChannel(dc) {
    this.dataChannel = dc;
    this.dataChannel.onopen = () => {
      $257947e92926277a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} dc connection success`);
      this.emit("willCloseOnRemote");
    };
    this.dataChannel.onclose = () => {
      $257947e92926277a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} dc closed for:`, this.peer);
      this.close();
    };
  }
  addStream(remoteStream) {
    $257947e92926277a$export$2e2bcd8739ae039.log("Receiving stream", remoteStream);
    this._remoteStream = remoteStream;
    super.emit("stream", remoteStream);
  }
  /**
  * @internal
  */
  handleMessage(message) {
    const type = message.type;
    const payload = message.payload;
    switch (message.type) {
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Answer:
        this._negotiator.handleSDP(type, payload.sdp);
        this._open = true;
        break;
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Candidate:
        this._negotiator.handleCandidate(payload.candidate);
        break;
      default:
        $257947e92926277a$export$2e2bcd8739ae039.warn(`Unrecognized message type:${type} from peer:${this.peer}`);
        break;
    }
  }
  /**
       * When receiving a {@apilink PeerEvents | `call`} event on a peer, you can call
       * `answer` on the media connection provided by the callback to accept the call
       * and optionally send your own media stream.
  
       *
       * @param stream A WebRTC media stream.
       * @param options
       * @returns
       */
  answer(stream, options = {}) {
    if (this._localStream) {
      $257947e92926277a$export$2e2bcd8739ae039.warn("Local stream already exists on this MediaConnection. Are you answering a call twice?");
      return;
    }
    this._localStream = stream;
    if (options && options.sdpTransform)
      this.options.sdpTransform = options.sdpTransform;
    this._negotiator.startConnection({
      ...this.options._payload,
      _stream: stream
    });
    const messages2 = this.provider._getMessages(this.connectionId);
    for (const message of messages2)
      this.handleMessage(message);
    this._open = true;
  }
  /**
  * Exposed functionality for users.
  */
  /**
  * Closes the media connection.
  */
  close() {
    if (this._negotiator) {
      this._negotiator.cleanup();
      this._negotiator = null;
    }
    this._localStream = null;
    this._remoteStream = null;
    if (this.provider) {
      this.provider._removeConnection(this);
      this.provider = null;
    }
    if (this.options && this.options._stream)
      this.options._stream = null;
    if (!this.open)
      return;
    this._open = false;
    super.emit("close");
  }
};
__ = new WeakMap();
__privateAdd(_$5c1d08c7c57da9a3$export$4a84e95a2324ac29, __, (() => {
  _$5c1d08c7c57da9a3$export$4a84e95a2324ac29.ID_PREFIX = "mc_";
})());
let $5c1d08c7c57da9a3$export$4a84e95a2324ac29 = _$5c1d08c7c57da9a3$export$4a84e95a2324ac29;
class $abf266641927cd89$export$2c4e825dc9120f87 {
  constructor(_options) {
    this._options = _options;
  }
  _buildRequest(method) {
    const protocol = this._options.secure ? "https" : "http";
    const { host, port, path, key } = this._options;
    const url = new URL(`${protocol}://${host}:${port}${path}${key}/${method}`);
    url.searchParams.set("ts", `${Date.now()}${Math.random()}`);
    url.searchParams.set("version", $f5f881ec4575f1fc$exports.version);
    return fetch(url.href, {
      referrerPolicy: this._options.referrerPolicy
    });
  }
  /** Get a unique ID from the server via XHR and initialize with it. */
  async retrieveId() {
    try {
      const response = await this._buildRequest("id");
      if (response.status !== 200)
        throw new Error(`Error. Status:${response.status}`);
      return response.text();
    } catch (error) {
      $257947e92926277a$export$2e2bcd8739ae039.error("Error retrieving ID", error);
      let pathError = "";
      if (this._options.path === "/" && this._options.host !== $4f4134156c446392$export$7debb50ef11d5e0b.CLOUD_HOST)
        pathError = " If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.";
      throw new Error("Could not get an ID from the server." + pathError);
    }
  }
  /** @deprecated */
  async listAllPeers() {
    try {
      const response = await this._buildRequest("peers");
      if (response.status !== 200) {
        if (response.status === 401) {
          let helpfulError = "";
          if (this._options.host === (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST)
            helpfulError = "It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.";
          else
            helpfulError = "You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.";
          throw new Error("It doesn't look like you have permission to list peers IDs. " + helpfulError);
        }
        throw new Error(`Error. Status:${response.status}`);
      }
      return response.json();
    } catch (error) {
      $257947e92926277a$export$2e2bcd8739ae039.error("Error retrieving list peers", error);
      throw new Error("Could not get list peers from the server." + error);
    }
  }
}
const _$6366c4ca161bc297$export$d365f7ad9d7df9c9 = class _$6366c4ca161bc297$export$d365f7ad9d7df9c9 extends $5045192fc6d387ba$export$23a2a68283c24d80 {
  get type() {
    return $78455e22dea96b8c$export$3157d57b4135e3bc.Data;
  }
  constructor(peerId, provider, options) {
    super(peerId, provider, options);
    this.connectionId = this.options.connectionId || _$6366c4ca161bc297$export$d365f7ad9d7df9c9.ID_PREFIX + $0e5fd1585784c252$export$4e61f672936bec77();
    this.label = this.options.label || this.connectionId;
    this.reliable = !!this.options.reliable;
    this._negotiator = new $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a(this);
    this._negotiator.startConnection(this.options._payload || {
      originator: true,
      reliable: this.reliable
    });
  }
  /** Called by the Negotiator when the DataChannel is ready. */
  _initializeDataChannel(dc) {
    this.dataChannel = dc;
    this.dataChannel.onopen = () => {
      $257947e92926277a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} dc connection success`);
      this._open = true;
      this.emit("open");
    };
    this.dataChannel.onmessage = (e) => {
      $257947e92926277a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} dc onmessage:`, e.data);
    };
    this.dataChannel.onclose = () => {
      $257947e92926277a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} dc closed for:`, this.peer);
      this.close();
    };
  }
  /**
  * Exposed functionality for users.
  */
  /** Allows user to close connection. */
  close(options) {
    if (options == null ? void 0 : options.flush) {
      this.send({
        __peerData: {
          type: "close"
        }
      });
      return;
    }
    if (this._negotiator) {
      this._negotiator.cleanup();
      this._negotiator = null;
    }
    if (this.provider) {
      this.provider._removeConnection(this);
      this.provider = null;
    }
    if (this.dataChannel) {
      this.dataChannel.onopen = null;
      this.dataChannel.onmessage = null;
      this.dataChannel.onclose = null;
      this.dataChannel = null;
    }
    if (!this.open)
      return;
    this._open = false;
    super.emit("close");
  }
  /** Allows user to send data. */
  send(data2, chunked = false) {
    if (!this.open) {
      this.emitError($78455e22dea96b8c$export$49ae800c114df41d.NotOpenYet, "Connection is not open. You should listen for the `open` event before sending messages.");
      return;
    }
    return this._send(data2, chunked);
  }
  async handleMessage(message) {
    const payload = message.payload;
    switch (message.type) {
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Answer:
        await this._negotiator.handleSDP(message.type, payload.sdp);
        break;
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Candidate:
        await this._negotiator.handleCandidate(payload.candidate);
        break;
      default:
        $257947e92926277a$export$2e2bcd8739ae039.warn("Unrecognized message type:", message.type, "from peer:", this.peer);
        break;
    }
  }
};
__2 = new WeakMap();
__1 = new WeakMap();
__privateAdd(_$6366c4ca161bc297$export$d365f7ad9d7df9c9, __2, (() => {
  _$6366c4ca161bc297$export$d365f7ad9d7df9c9.ID_PREFIX = "dc_";
})());
__privateAdd(_$6366c4ca161bc297$export$d365f7ad9d7df9c9, __1, (() => {
  _$6366c4ca161bc297$export$d365f7ad9d7df9c9.MAX_BUFFERED_AMOUNT = 8388608;
})());
let $6366c4ca161bc297$export$d365f7ad9d7df9c9 = _$6366c4ca161bc297$export$d365f7ad9d7df9c9;
class $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b extends $6366c4ca161bc297$export$d365f7ad9d7df9c9 {
  get bufferSize() {
    return this._bufferSize;
  }
  _initializeDataChannel(dc) {
    super._initializeDataChannel(dc);
    this.dataChannel.binaryType = "arraybuffer";
    this.dataChannel.addEventListener("message", (e) => this._handleDataMessage(e));
  }
  _bufferedSend(msg) {
    if (this._buffering || !this._trySend(msg)) {
      this._buffer.push(msg);
      this._bufferSize = this._buffer.length;
    }
  }
  // Returns true if the send succeeds.
  _trySend(msg) {
    if (!this.open)
      return false;
    if (this.dataChannel.bufferedAmount > $6366c4ca161bc297$export$d365f7ad9d7df9c9.MAX_BUFFERED_AMOUNT) {
      this._buffering = true;
      setTimeout(() => {
        this._buffering = false;
        this._tryBuffer();
      }, 50);
      return false;
    }
    try {
      this.dataChannel.send(msg);
    } catch (e) {
      $257947e92926277a$export$2e2bcd8739ae039.error(`DC#:${this.connectionId} Error when sending:`, e);
      this._buffering = true;
      this.close();
      return false;
    }
    return true;
  }
  // Try to send the first message in the buffer.
  _tryBuffer() {
    if (!this.open)
      return;
    if (this._buffer.length === 0)
      return;
    const msg = this._buffer[0];
    if (this._trySend(msg)) {
      this._buffer.shift();
      this._bufferSize = this._buffer.length;
      this._tryBuffer();
    }
  }
  close(options) {
    if (options == null ? void 0 : options.flush) {
      this.send({
        __peerData: {
          type: "close"
        }
      });
      return;
    }
    this._buffer = [];
    this._bufferSize = 0;
    super.close();
  }
  constructor(...args) {
    super(...args);
    this._buffer = [];
    this._bufferSize = 0;
    this._buffering = false;
  }
}
class $9fcfddb3ae148f88$export$f0a5a64d5bb37108 extends $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b {
  close(options) {
    super.close(options);
    this._chunkedData = {};
  }
  constructor(peerId, provider, options) {
    super(peerId, provider, options);
    this.chunker = new $fcbcc7538a6776d5$export$f1c5f4c9cb95390b();
    this.serialization = $78455e22dea96b8c$export$89f507cf986a947.Binary;
    this._chunkedData = {};
  }
  // Handles a DataChannel message.
  _handleDataMessage({ data: data2 }) {
    const deserializedData = $0cfd7828ad59115f$export$417857010dc9287f(data2);
    const peerData = deserializedData["__peerData"];
    if (peerData) {
      if (peerData.type === "close") {
        this.close();
        return;
      }
      this._handleChunk(deserializedData);
      return;
    }
    this.emit("data", deserializedData);
  }
  _handleChunk(data2) {
    const id = data2.__peerData;
    const chunkInfo = this._chunkedData[id] || {
      data: [],
      count: 0,
      total: data2.total
    };
    chunkInfo.data[data2.n] = new Uint8Array(data2.data);
    chunkInfo.count++;
    this._chunkedData[id] = chunkInfo;
    if (chunkInfo.total === chunkInfo.count) {
      delete this._chunkedData[id];
      const data3 = $fcbcc7538a6776d5$export$52c89ebcdc4f53f2(chunkInfo.data);
      this._handleDataMessage({
        data: data3
      });
    }
  }
  _send(data2, chunked) {
    if (data2 instanceof Blob)
      return data2.arrayBuffer().then((buffer) => {
        this._send(buffer, chunked);
      });
    const blob = $0cfd7828ad59115f$export$2a703dbb0cb35339(data2);
    if (!chunked && blob.byteLength > this.chunker.chunkedMTU) {
      this._sendChunks(blob);
      return;
    }
    this._bufferedSend(blob);
  }
  _sendChunks(blob) {
    const blobs = this.chunker.chunk(blob);
    $257947e92926277a$export$2e2bcd8739ae039.log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);
    for (const blob2 of blobs)
      this.send(blob2, true);
  }
}
class $bbaee3f15f714663$export$6f88fe47d32c9c94 extends $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b {
  _handleDataMessage({ data: data2 }) {
    super.emit("data", data2);
  }
  _send(data2, _chunked) {
    this._bufferedSend(data2);
  }
  constructor(...args) {
    super(...args);
    this.serialization = $78455e22dea96b8c$export$89f507cf986a947.None;
  }
}
class $817f931e3f9096cf$export$48880ac635f47186 extends $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b {
  // Handles a DataChannel message.
  _handleDataMessage({ data: data2 }) {
    const deserializedData = this.parse(this.decoder.decode(data2));
    const peerData = deserializedData["__peerData"];
    if (peerData && peerData.type === "close") {
      this.close();
      return;
    }
    this.emit("data", deserializedData);
  }
  _send(data2, _chunked) {
    const encodedData = this.encoder.encode(this.stringify(data2));
    if (encodedData.byteLength >= $4f4134156c446392$export$7debb50ef11d5e0b.chunkedMTU) {
      this.emitError($78455e22dea96b8c$export$49ae800c114df41d.MessageToBig, "Message too big for JSON channel");
      return;
    }
    this._bufferedSend(encodedData);
  }
  constructor(...args) {
    super(...args);
    this.serialization = $78455e22dea96b8c$export$89f507cf986a947.JSON;
    this.encoder = new TextEncoder();
    this.decoder = new TextDecoder();
    this.stringify = JSON.stringify;
    this.parse = JSON.parse;
  }
}
const _$416260bce337df90$export$ecd1fc136c422448 = class _$416260bce337df90$export$ecd1fc136c422448 extends $23779d1881157a18$export$6a678e589c8a4542 {
  /**
  * The brokering ID of this peer
  *
  * If no ID was specified in {@apilink Peer | the constructor},
  * this will be `undefined` until the {@apilink PeerEvents | `open`} event is emitted.
  */
  get id() {
    return this._id;
  }
  get options() {
    return this._options;
  }
  get open() {
    return this._open;
  }
  /**
  * @internal
  */
  get socket() {
    return this._socket;
  }
  /**
  * A hash of all connections associated with this peer, keyed by the remote peer's ID.
  * @deprecated
  * Return type will change from Object to Map<string,[]>
  */
  get connections() {
    const plainConnections = /* @__PURE__ */ Object.create(null);
    for (const [k, v] of this._connections)
      plainConnections[k] = v;
    return plainConnections;
  }
  /**
  * true if this peer and all of its connections can no longer be used.
  */
  get destroyed() {
    return this._destroyed;
  }
  /**
  * false if there is an active connection to the PeerServer.
  */
  get disconnected() {
    return this._disconnected;
  }
  constructor(id, options) {
    super();
    this._serializers = {
      raw: $bbaee3f15f714663$export$6f88fe47d32c9c94,
      json: $817f931e3f9096cf$export$48880ac635f47186,
      binary: $9fcfddb3ae148f88$export$f0a5a64d5bb37108,
      "binary-utf8": $9fcfddb3ae148f88$export$f0a5a64d5bb37108,
      default: $9fcfddb3ae148f88$export$f0a5a64d5bb37108
    };
    this._id = null;
    this._lastServerId = null;
    this._destroyed = false;
    this._disconnected = false;
    this._open = false;
    this._connections = /* @__PURE__ */ new Map();
    this._lostMessages = /* @__PURE__ */ new Map();
    let userId;
    if (id && id.constructor == Object)
      options = id;
    else if (id)
      userId = id.toString();
    options = {
      debug: 0,
      host: $4f4134156c446392$export$7debb50ef11d5e0b.CLOUD_HOST,
      port: $4f4134156c446392$export$7debb50ef11d5e0b.CLOUD_PORT,
      path: "/",
      key: _$416260bce337df90$export$ecd1fc136c422448.DEFAULT_KEY,
      token: $4f4134156c446392$export$7debb50ef11d5e0b.randomToken(),
      config: $4f4134156c446392$export$7debb50ef11d5e0b.defaultConfig,
      referrerPolicy: "strict-origin-when-cross-origin",
      serializers: {},
      ...options
    };
    this._options = options;
    this._serializers = {
      ...this._serializers,
      ...this.options.serializers
    };
    if (this._options.host === "/")
      this._options.host = window.location.hostname;
    if (this._options.path) {
      if (this._options.path[0] !== "/")
        this._options.path = "/" + this._options.path;
      if (this._options.path[this._options.path.length - 1] !== "/")
        this._options.path += "/";
    }
    if (this._options.secure === void 0 && this._options.host !== $4f4134156c446392$export$7debb50ef11d5e0b.CLOUD_HOST)
      this._options.secure = $4f4134156c446392$export$7debb50ef11d5e0b.isSecure();
    else if (this._options.host == $4f4134156c446392$export$7debb50ef11d5e0b.CLOUD_HOST)
      this._options.secure = true;
    if (this._options.logFunction)
      $257947e92926277a$export$2e2bcd8739ae039.setLogFunction(this._options.logFunction);
    $257947e92926277a$export$2e2bcd8739ae039.logLevel = this._options.debug || 0;
    this._api = new $abf266641927cd89$export$2c4e825dc9120f87(options);
    this._socket = this._createServerConnection();
    if (!$4f4134156c446392$export$7debb50ef11d5e0b.supports.audioVideo && !$4f4134156c446392$export$7debb50ef11d5e0b.supports.data) {
      this._delayedAbort($78455e22dea96b8c$export$9547aaa2e39030ff.BrowserIncompatible, "The current browser does not support WebRTC");
      return;
    }
    if (!!userId && !$4f4134156c446392$export$7debb50ef11d5e0b.validateId(userId)) {
      this._delayedAbort($78455e22dea96b8c$export$9547aaa2e39030ff.InvalidID, `ID "${userId}" is invalid`);
      return;
    }
    if (userId)
      this._initialize(userId);
    else
      this._api.retrieveId().then((id2) => this._initialize(id2)).catch((error) => this._abort($78455e22dea96b8c$export$9547aaa2e39030ff.ServerError, error));
  }
  _createServerConnection() {
    const socket = new $8f5bfa60836d261d$export$4798917dbf149b79(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);
    socket.on($78455e22dea96b8c$export$3b5c4a4b6354f023.Message, (data2) => {
      this._handleMessage(data2);
    });
    socket.on($78455e22dea96b8c$export$3b5c4a4b6354f023.Error, (error) => {
      this._abort($78455e22dea96b8c$export$9547aaa2e39030ff.SocketError, error);
    });
    socket.on($78455e22dea96b8c$export$3b5c4a4b6354f023.Disconnected, () => {
      if (this.disconnected)
        return;
      this.emitError($78455e22dea96b8c$export$9547aaa2e39030ff.Network, "Lost connection to server.");
      this.disconnect();
    });
    socket.on($78455e22dea96b8c$export$3b5c4a4b6354f023.Close, () => {
      if (this.disconnected)
        return;
      this._abort($78455e22dea96b8c$export$9547aaa2e39030ff.SocketClosed, "Underlying socket is already closed.");
    });
    return socket;
  }
  /** Initialize a connection with the server. */
  _initialize(id) {
    this._id = id;
    this.socket.start(id, this._options.token);
  }
  /** Handles messages from the server. */
  _handleMessage(message) {
    const type = message.type;
    const payload = message.payload;
    const peerId = message.src;
    switch (type) {
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Open:
        this._lastServerId = this.id;
        this._open = true;
        this.emit("open", this.id);
        break;
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Error:
        this._abort($78455e22dea96b8c$export$9547aaa2e39030ff.ServerError, payload.msg);
        break;
      case $78455e22dea96b8c$export$adb4a1754da6f10d.IdTaken:
        this._abort($78455e22dea96b8c$export$9547aaa2e39030ff.UnavailableID, `ID "${this.id}" is taken`);
        break;
      case $78455e22dea96b8c$export$adb4a1754da6f10d.InvalidKey:
        this._abort($78455e22dea96b8c$export$9547aaa2e39030ff.InvalidKey, `API KEY "${this._options.key}" is invalid`);
        break;
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Leave:
        $257947e92926277a$export$2e2bcd8739ae039.log(`Received leave message from ${peerId}`);
        this._cleanupPeer(peerId);
        this._connections.delete(peerId);
        break;
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Expire:
        this.emitError($78455e22dea96b8c$export$9547aaa2e39030ff.PeerUnavailable, `Could not connect to peer ${peerId}`);
        break;
      case $78455e22dea96b8c$export$adb4a1754da6f10d.Offer: {
        const connectionId = payload.connectionId;
        let connection = this.getConnection(peerId, connectionId);
        if (connection) {
          connection.close();
          $257947e92926277a$export$2e2bcd8739ae039.warn(`Offer received for existing Connection ID:${connectionId}`);
        }
        if (payload.type === $78455e22dea96b8c$export$3157d57b4135e3bc.Media) {
          const mediaConnection = new $5c1d08c7c57da9a3$export$4a84e95a2324ac29(peerId, this, {
            connectionId,
            _payload: payload,
            metadata: payload.metadata
          });
          connection = mediaConnection;
          this._addConnection(peerId, connection);
          this.emit("call", mediaConnection);
        } else if (payload.type === $78455e22dea96b8c$export$3157d57b4135e3bc.Data) {
          const dataConnection = new this._serializers[payload.serialization](peerId, this, {
            connectionId,
            _payload: payload,
            metadata: payload.metadata,
            label: payload.label,
            serialization: payload.serialization,
            reliable: payload.reliable
          });
          connection = dataConnection;
          this._addConnection(peerId, connection);
          this.emit("connection", dataConnection);
        } else {
          $257947e92926277a$export$2e2bcd8739ae039.warn(`Received malformed connection type:${payload.type}`);
          return;
        }
        const messages2 = this._getMessages(connectionId);
        for (const message2 of messages2)
          connection.handleMessage(message2);
        break;
      }
      default: {
        if (!payload) {
          $257947e92926277a$export$2e2bcd8739ae039.warn(`You received a malformed message from ${peerId} of type ${type}`);
          return;
        }
        const connectionId = payload.connectionId;
        const connection = this.getConnection(peerId, connectionId);
        if (connection && connection.peerConnection)
          connection.handleMessage(message);
        else if (connectionId)
          this._storeMessage(connectionId, message);
        else
          $257947e92926277a$export$2e2bcd8739ae039.warn("You received an unrecognized message:", message);
        break;
      }
    }
  }
  /** Stores messages without a set up connection, to be claimed later. */
  _storeMessage(connectionId, message) {
    if (!this._lostMessages.has(connectionId))
      this._lostMessages.set(connectionId, []);
    this._lostMessages.get(connectionId).push(message);
  }
  /**
  * Retrieve messages from lost message store
  * @internal
  */
  //TODO Change it to private
  _getMessages(connectionId) {
    const messages2 = this._lostMessages.get(connectionId);
    if (messages2) {
      this._lostMessages.delete(connectionId);
      return messages2;
    }
    return [];
  }
  /**
  * Connects to the remote peer specified by id and returns a data connection.
  * @param peer The brokering ID of the remote peer (their {@apilink Peer.id}).
  * @param options for specifying details about Peer Connection
  */
  connect(peer, options = {}) {
    options = {
      serialization: "default",
      ...options
    };
    if (this.disconnected) {
      $257947e92926277a$export$2e2bcd8739ae039.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.");
      this.emitError($78455e22dea96b8c$export$9547aaa2e39030ff.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
      return;
    }
    const dataConnection = new this._serializers[options.serialization](peer, this, options);
    this._addConnection(peer, dataConnection);
    return dataConnection;
  }
  /**
  * Calls the remote peer specified by id and returns a media connection.
  * @param peer The brokering ID of the remote peer (their peer.id).
  * @param stream The caller's media stream
  * @param options Metadata associated with the connection, passed in by whoever initiated the connection.
  */
  call(peer, stream, options = {}) {
    if (this.disconnected) {
      $257947e92926277a$export$2e2bcd8739ae039.warn("You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.");
      this.emitError($78455e22dea96b8c$export$9547aaa2e39030ff.Disconnected, "Cannot connect to new Peer after disconnecting from server.");
      return;
    }
    if (!stream) {
      $257947e92926277a$export$2e2bcd8739ae039.error("To call a peer, you must provide a stream from your browser's `getUserMedia`.");
      return;
    }
    const mediaConnection = new $5c1d08c7c57da9a3$export$4a84e95a2324ac29(peer, this, {
      ...options,
      _stream: stream
    });
    this._addConnection(peer, mediaConnection);
    return mediaConnection;
  }
  /** Add a data/media connection to this peer. */
  _addConnection(peerId, connection) {
    $257947e92926277a$export$2e2bcd8739ae039.log(`add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`);
    if (!this._connections.has(peerId))
      this._connections.set(peerId, []);
    this._connections.get(peerId).push(connection);
  }
  //TODO should be private
  _removeConnection(connection) {
    const connections = this._connections.get(connection.peer);
    if (connections) {
      const index = connections.indexOf(connection);
      if (index !== -1)
        connections.splice(index, 1);
    }
    this._lostMessages.delete(connection.connectionId);
  }
  /** Retrieve a data/media connection for this peer. */
  getConnection(peerId, connectionId) {
    const connections = this._connections.get(peerId);
    if (!connections)
      return null;
    for (const connection of connections) {
      if (connection.connectionId === connectionId)
        return connection;
    }
    return null;
  }
  _delayedAbort(type, message) {
    setTimeout(() => {
      this._abort(type, message);
    }, 0);
  }
  /**
  * Emits an error message and destroys the Peer.
  * The Peer is not destroyed if it's in a disconnected state, in which case
  * it retains its disconnected state and its existing connections.
  */
  _abort(type, message) {
    $257947e92926277a$export$2e2bcd8739ae039.error("Aborting!");
    this.emitError(type, message);
    if (!this._lastServerId)
      this.destroy();
    else
      this.disconnect();
  }
  /**
  * Destroys the Peer: closes all active connections as well as the connection
  * to the server.
  *
  * :::caution
  * This cannot be undone; the respective peer object will no longer be able
  * to create or receive any connections, its ID will be forfeited on the server,
  * and all of its data and media connections will be closed.
  * :::
  */
  destroy() {
    if (this.destroyed)
      return;
    $257947e92926277a$export$2e2bcd8739ae039.log(`Destroy peer with ID:${this.id}`);
    this.disconnect();
    this._cleanup();
    this._destroyed = true;
    this.emit("close");
  }
  /** Disconnects every connection on this peer. */
  _cleanup() {
    for (const peerId of this._connections.keys()) {
      this._cleanupPeer(peerId);
      this._connections.delete(peerId);
    }
    this.socket.removeAllListeners();
  }
  /** Closes all connections to this peer. */
  _cleanupPeer(peerId) {
    const connections = this._connections.get(peerId);
    if (!connections)
      return;
    for (const connection of connections)
      connection.close();
  }
  /**
  * Disconnects the Peer's connection to the PeerServer. Does not close any
  *  active connections.
  * Warning: The peer can no longer create or accept connections after being
  *  disconnected. It also cannot reconnect to the server.
  */
  disconnect() {
    if (this.disconnected)
      return;
    const currentId = this.id;
    $257947e92926277a$export$2e2bcd8739ae039.log(`Disconnect peer with ID:${currentId}`);
    this._disconnected = true;
    this._open = false;
    this.socket.close();
    this._lastServerId = currentId;
    this._id = null;
    this.emit("disconnected", currentId);
  }
  /** Attempts to reconnect with the same ID.
  *
  * Only {@apilink Peer.disconnect | disconnected peers} can be reconnected.
  * Destroyed peers cannot be reconnected.
  * If the connection fails (as an example, if the peer's old ID is now taken),
  * the peer's existing connections will not close, but any associated errors events will fire.
  */
  reconnect() {
    if (this.disconnected && !this.destroyed) {
      $257947e92926277a$export$2e2bcd8739ae039.log(`Attempting reconnection to server with ID ${this._lastServerId}`);
      this._disconnected = false;
      this._initialize(this._lastServerId);
    } else if (this.destroyed)
      throw new Error("This peer cannot reconnect to the server. It has already been destroyed.");
    else if (!this.disconnected && !this.open)
      $257947e92926277a$export$2e2bcd8739ae039.error("In a hurry? We're still trying to make the initial connection!");
    else
      throw new Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`);
  }
  /**
  * Get a list of available peer IDs. If you're running your own server, you'll
  * want to set allow_discovery: true in the PeerServer options. If you're using
  * the cloud server, email team@peerjs.com to get the functionality enabled for
  * your key.
  */
  listAllPeers(cb = (_) => {
  }) {
    this._api.listAllPeers().then((peers) => cb(peers)).catch((error) => this._abort($78455e22dea96b8c$export$9547aaa2e39030ff.ServerError, error));
  }
};
__3 = new WeakMap();
__privateAdd(_$416260bce337df90$export$ecd1fc136c422448, __3, (() => {
  _$416260bce337df90$export$ecd1fc136c422448.DEFAULT_KEY = "peerjs";
})());
let $416260bce337df90$export$ecd1fc136c422448 = _$416260bce337df90$export$ecd1fc136c422448;
const messages = {
  "en": {
    "game_create": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Create game"]);
    },
    "game_manage": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Manage your games"]);
    },
    "game_join": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Join game"]);
    },
    "character_manage": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Manage your characters"]);
    },
    "read_more": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["More about Minotaure"]);
    },
    "character_help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Your characters are stored in your browser, so you can find them again when you connect to a previously joined game. You can play on another browser by exporting your characters."]);
    },
    "character_nb": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
      return _plural([_normalize(["You have no character to export"]), _normalize(["You have one character to export"]), _normalize(["You have ", _interpolate(_named("count")), " characters to export"])]);
    },
    "challenge_success": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["You've passed a ", _interpolate(_named("stat")), " challenge."]);
    },
    "challenge_failure": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["You've failed a ", _interpolate(_named("stat")), " challenge."]);
    },
    "result_bonus": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["You gain ", _interpolate(_named("points")), " points of ", _interpolate(_named("name")), "."]);
    },
    "result_malus": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["You lose ", _interpolate(_named("points")), " points of ", _interpolate(_named("name")), "."]);
    },
    "characters": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Characters"]);
    },
    "bars": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Bars"]);
    },
    "polls": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Polls"]);
    },
    "challenge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Challenge"]);
    },
    "stats": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Stats"]);
    },
    "settings": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Settings"]);
    },
    "tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tags"]);
    },
    "draw": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Draw"]);
    },
    "help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Help"]);
    },
    "start": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Start"]);
    },
    "invite_to_play": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Invite to play"]);
    },
    "invite_link_copied": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Invite link copied!"]);
    },
    "game_id_copied": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Game ID copied !"]);
    },
    "strength": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Strength"]);
    },
    "mind": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Mind"]);
    },
    "health": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Health"]);
    },
    "will": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Will"]);
    },
    "game_rename": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rename game"]);
    },
    "selected": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Selected"]);
    },
    "continue_game": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Continue - ", _interpolate(_named("name"))]);
    },
    "count_personnage": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
      return _plural([_normalize(["1 character"]), _normalize([_interpolate(_named("count")), " characters"])]);
    },
    "continue": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Continue"]);
    },
    "see_more": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["See more"]);
    },
    "any_game": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You didn't create any game."]);
    },
    "cancel": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Cancel"]);
    },
    "in_progress": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Please input text"]);
    },
    "start_game": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Start game"]);
    },
    "warning_version": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["The game marked with <span class='danger'>*</span> are not compatible with your Minotaure version (", _interpolate(_named("version")), "), it might not work properly."]);
    },
    "delete_all_games": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Delete all games"]);
    },
    "confirm_question": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Are you sure?"]);
    },
    "game_name_invite": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Name your game. You can change it later."]);
    },
    "my_game": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["My game"]);
    },
    "game_id_help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Your invite link contains this id. You may change this id."]);
    },
    "add_poll": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add poll"]);
    },
    "active_polls": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["View active polls"]);
    },
    "past_polls": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["View past polls"]);
    },
    "question": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Question"]);
    },
    "possible_choices": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Possible choices"]);
    },
    "add_poll_choice": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add choice"]);
    },
    "start_poll": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Poll"]);
    },
    "show_poll_results": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Show results"]);
    },
    "close_poll": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Close poll"]);
    },
    "nb_choice": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Choix ", _interpolate(_named("nb"))]);
    },
    "choice_gives_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add following tag for this choice"]);
    },
    "turnout": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Turnout: "]);
    },
    "other_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Miscellaneous"]);
    },
    "minotaure_welcome": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Welcome to Minotaure"]);
    },
    "tutorial_help_1": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You may begin the tutorial by clicking on the <strong class='icon-question'>Help</strong> button (a full tutorial will be available in a future version)"]);
    },
    "tutorial_help_2": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Before starting your game, you can modify the <strong>settings</strong> and <strong>tags</strong> in their respective tabs."]);
    },
    "tutorial_help_3": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can invite your players to the game right away by clicking on <strong class='icon-email'>Invite to play</strong> button."]);
    },
    "next": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Next"]);
    },
    "end_tour": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["End this tour"]);
    },
    "end_tab_tour": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["End the tour for this tab"]);
    },
    "step_help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Would you like to take the full tour or just get help for this tab?"]);
    },
    "see_all_tutorial": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Complete tour"]);
    },
    "see_page_tutorial": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Visit this tab"]);
    },
    "step_game_name": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can change the game name anytime."]);
    },
    "step_invite": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["By clicking on this button an invitation link will be copied and will allow you to invite people to join your game."]);
    },
    "step_start": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Until you click this button, your guests will wait on a waiting screen."]);
    },
    "tab_label_settings": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["The settings are the game settings that we recommend you change before the game starts, but that you can always change during the game."]);
    },
    "step_settings_gauges": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Bars are point reserves for each character. When you create a game, two bars are created by default: life and will."]);
    },
    "step_settings_add_gauge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can add as many bars as you like."]);
    },
    "step_settings_gauge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["All characters have these bars when they are created, with a number of starting points that you can change."]);
    },
    "step_settings_gauge_delete": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can delete a bar at any time."]);
    },
    "step_settings_gauge_make_deadly": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can make it so that a bar's passage to a score of 0 results in a character's death by clicking on this button (this action is reversible, but characters already dead will not be resurrected!)."]);
    },
    "step_settings_stats": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["The stats work in the same way as in most role-playing games. When you create a game, two stats are created: physical and mental."]);
    },
    "step_settings_add_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can add as many stats as you want."]);
    },
    "step_settings_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["All characters have these stats at their creation, with a starting number of points of 10 + a random number between -9 and +9. <br> The point total of all stats of a the creation of a character is always 10 times the number of stats, to ensure the same total points for all participants."]);
    },
    "step_settings_stat_delete": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can delete a stat at any time."]);
    },
    "tab_label_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tags are labels assigned to characters and are a great strength of Minotaure.<br>"]);
    },
    "step_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Each tag belongs to a tag group, which can be named (e.g., professions, gender, race, advantages, flaws, etc.). A tag can be used for a character class, but it's versatile enough for other uses."]);
    },
    "example": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["example"]);
    },
    "step_tags_group_add": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can add as many tag groups as you want."]);
    },
    "step_tags_group": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Start typing text and confirm to create a tag. A color will be associated with it."]);
    },
    "step_tags_group_distribution": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["For each tag group, you can choose a tag distribution mode: <ul> <li>- chosen by the player at character creation</li> <li>- assigned randomly</li> <li>- distributed evenly (the system will choose from the least assigned tags to balance the distributed tags)</li> <li>- not assigned at creation (you will use them differently than at character creation)</li> </ul>"]);
    },
    "step_tags_group_distribute": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Click here to distribute a tag from this group to all characters that do not already have one. Useful if you created the group during the game."]);
    },
    "step_tags_group_shuffle": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Click here to distribute a tag from this group to all characters that already have one. The new tag will replace the old one. Useful if you are not satisfied with the current distribution."]);
    },
    "step_tags_group_rename": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can rename a tag group at any time."]);
    },
    "step_tags_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([`Each tag can influence a character's bars and stats at their creation. By clicking on a tag, you can: <ul> <li>- associate it with a <strong>main stat</strong>. If a character gets this tag at creation, it will automatically be their strongest stat. For example, a "wizard" tag could have the main stat "Magic."</li> <li>- associate it with a <strong>secondary stat</strong>. If a character gets this tag at creation, it will automatically be their second-strongest stat.</li> <li>- associate it with <strong>bonuses</strong> and <strong>penalties</strong> that modify the initial stats roll or the starting value of certain bars.</li> <li>- increase or decrease its random attribution <strong>probability</strong>.</li> <li>- change its <strong>color</strong>.</li> </ul>`]);
    },
    "step_tags_group_delete": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can delete a tag group at any time. This will remove the corresponding tags for the characters."]);
    },
    "tab_label_characters": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["This is the tab you will use most during the game: it presents all created characters and summarizes their properties (character name, player's pseudonym, bats, stats, tags, etc.). You can search for characters based on various criteria."]);
    },
    "tab_label_poll": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can trigger a poll that will help you determine the direction in which the game should evolve. You can also add tags to characters based on the choices of each player in the poll."]);
    },
    "tab_label_challenge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You can trigger the equivalent of dice rolls that will result in consequences for each character involved, depending on their success or failure."]);
    },
    "tab_label_pick": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Random draws allow you to select a number of characters of your choice at random from the entire or a portion of the population. You can also apply consequences to the characters drawn."]);
    },
    "add": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add"]);
    },
    "gauge_start": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Starts at ", _interpolate(_named("gauge_value"))]);
    },
    "kills_at_0": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Kills at 0"]);
    },
    "submit": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Submit"]);
    },
    "make_normal": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Make normal"]);
    },
    "make_fatal": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Make fatal"]);
    },
    "modify": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Modify"]);
    },
    "delete": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Delete"]);
    },
    "name": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Name"]);
    },
    "starts_at": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Start at"]);
    },
    "rename": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rename"]);
    },
    "dif_cake": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Piece of cake"]);
    },
    "dif_ext_easy": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Extremely easy"]);
    },
    "dif_very_easy": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Very Easy"]);
    },
    "dif_easy": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Easy"]);
    },
    "dif_moderate": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Moderate"]);
    },
    "dif_hard": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Hard"]);
    },
    "dif_very_hard": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Very Hard"]);
    },
    "dif_extreme": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Extreme"]);
    },
    "dif_impossible": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Impossible"]);
    },
    "added_tag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["added tag:", _interpolate(_named("tag_label"))]);
    },
    "removed_tag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["removed tag:", _interpolate(_named("tag_label"))]);
    },
    "must_first": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["You must first "]);
    },
    "add_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["add stat"]);
    },
    "tested_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tested stat"]);
    },
    "choose_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Choose stat"]);
    },
    "difficulty": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Difficulty: "]);
    },
    "targets": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Targets"]);
    },
    "add_target": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add target"]);
    },
    "everyone": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Everyone"]);
    },
    "positive_csq": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Consequences of success"]);
    },
    "negative_csq": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Consequences of failure"]);
    },
    "add_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add tags"]);
    },
    "add_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add tag"]);
    },
    "input_word": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Input word"]);
    },
    "no_tag_create": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["No other tag, create one!"]);
    },
    "remove_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Remove tags"]);
    },
    "this_will_test": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["This will test: "]);
    },
    "for_everyone": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["For everyone"]);
    },
    "for_every": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["For every:"]);
    },
    "challenge_characters": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Characters "]);
    },
    "that_pass": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["that pass"]);
    },
    "that_fail": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["that fail"]);
    },
    "will_have": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([" will have:"]);
    },
    "get_following_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["And get following tags: "]);
    },
    "lose_following_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["And lose following tags (if possessed!): "]);
    },
    "start_challenge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Start Challenge!"]);
    },
    "context_add_selection_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add character to selection (maj + left click)"]);
    },
    "context_remove_selection_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Remove character from selection (maj + left click)"]);
    },
    "context_delete_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Delete character"]);
    },
    "context_edit_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Edit character (future feature)"]);
    },
    "last_challenge_success_rate": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Success rate of last challenge: "]);
    },
    "select_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Select tag"]);
    },
    "alive": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Alive"]);
    },
    "connected": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Connected"]);
    },
    "passed": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Passed"]);
    },
    "failed": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Failed"]);
    },
    "show_all_characters": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Show all"]);
    },
    "spawn_npc": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Spawn NPC"]);
    },
    "characters_on": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([" on "]);
    },
    "no_characters_to_show_try_different_filter": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["No characters to show here. Try a different filter."]);
    },
    "search_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Search for a character"]);
    },
    "start_typing": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Start typing"]);
    },
    "clear_selection": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Clear selection"]);
    },
    "char_picked": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Selected characters"]);
    },
    "add_all_to_selection": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add all to selection"]);
    },
    "group_nb": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Group ", _interpolate(_named("nb"))]);
    },
    "bonus_gauge": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Boost the bar ", _interpolate(_named("name"))]);
    },
    "malus_gauge": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Nerf the bar ", _interpolate(_named("name"))]);
    },
    "bonus_stat": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Boost the stat ", _interpolate(_named("name"))]);
    },
    "malus_stat": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Nerf the stat ", _interpolate(_named("name"))]);
    },
    "linkStatToTag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Make ", _interpolate(_named("statname")), " as main stat"]);
    },
    "unlinkStatToTag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Remove ", _interpolate(_named("statname")), " as main stat"]);
    },
    "link2StatToTag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Make ", _interpolate(_named("statname")), " as secondary stat"]);
    },
    "unlink2StatToTag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Remove ", _interpolate(_named("statname")), " as secondary stat"]);
    },
    "change_tag_color": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Change tag color"]);
    },
    "add_groug_of_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Add a group of tag"]);
    },
    "distribution_mode": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Distribution mode: "]);
    },
    "randomly_distributed_at_creation": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Randomly distributed at creation"]);
    },
    "equitably_distributed_at_creation": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Equitably distributed at creation"]);
    },
    "chosen_at_char_creation": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Chosen at character creation"]);
    },
    "not_autodistributed": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Not autodistributed"]);
    },
    "distribute": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Distribute"]);
    },
    "shuffle": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Shuffle"]);
    },
    "shuffle_help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["For each character already having a tag from this group, a new tag from this group will be assigned to it instead."]);
    },
    "main_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([" Main stat: "]);
    },
    "secondary_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([" Secondary stat: "]);
    },
    "tags_submit": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Submit"]);
    },
    "a_tag_will_be_assigned_to_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["A tag will be assigned to all characters missing a tag from this group"]);
    },
    "delete_groupe_tags_and_remove_from_chars": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["This group's tags will be deleted and removed from characters"]);
    },
    "increase_probability": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Increase probability"]);
    },
    "decrease_probability": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Decrease probability"]);
    },
    "tag_probability": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
      return _plural([_normalize(["1 chance out of ", _interpolate(_named("total"))]), _normalize([_interpolate(_named("count")), " chances out of ", _interpolate(_named("total"))])]);
    },
    "count_char_import": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
      return _plural([_normalize(["1 imported character"]), _normalize([_interpolate(_named("count")), " imported characters"])]);
    },
    "invalid_qr_code": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Invalid QR code"]);
    },
    "export_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Export characters"]);
    },
    "import_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Import characters"]);
    },
    "delete_all_chars": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Delete all your characters"]);
    },
    "admin_pick_one": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["out of characters with any following tags:"]);
    },
    "admin_pick_all": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["out of characters with all following tags:"]);
    },
    "admin_pick_none": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["out of characters with none of the following tags:"]);
    },
    "admin_pick_each": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["characters by tag:"]);
    },
    "admin_pick_launch": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Draw"]);
    },
    "future_feature": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Future feature"]);
    },
    "admin_pick_add_csq": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Additional consequences of the draw"]);
    },
    "game_id": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Game ID"]);
    },
    "join": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Join Game"]);
    },
    "back_to_home": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Back to Home"]);
    },
    "waiting_for_game_start": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Waiting for game start"]);
    },
    "char_name": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Character name"]);
    },
    "user_name": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Username (optional)"]);
    },
    "your_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Your character is "]);
    },
    "submit_your_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Submit your character"]);
    },
    "send_answer": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Send answer"]);
    },
    "is_dead": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize([_interpolate(_named("charname")), " is dead"]);
    },
    "poll_pending": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Poll ", _interpolate(_named("pollnb")), " is pending"]);
    },
    "create_new_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Create a new character"]);
    }
  },
  "fr": {
    "game_create": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Crer une partie"]);
    },
    "game_manage": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Grer vos parties"]);
    },
    "game_join": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rejoindre une partie"]);
    },
    "character_manage": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Grer vos personnages"]);
    },
    "read_more": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["En savoir plus"]);
    },
    "character_help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vos personnages sont conservs dans votre navigateur, ce qui permet de les retrouver lors d'une connexion  une partie rejointe auparavant. Vous pouvez jouer sur un autre navigateur en exportant vos personnages."]);
    },
    "character_nb": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
      return _plural([_normalize(["Vous n'avez aucun personnage  exporter"]), _normalize(["Vous avez un personnage  exporter"]), _normalize(["Vous avez ", _interpolate(_named("count")), " personnages  exporter"])]);
    },
    "challenge_success": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Vous avez russi une preuve de ", _interpolate(_named("stat")), "."]);
    },
    "challenge_failure": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Vous avez rat une preuve de ", _interpolate(_named("stat")), "."]);
    },
    "result_bonus": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Vous gagnez ", _interpolate(_named("points")), " points de ", _interpolate(_named("name")), "."]);
    },
    "result_malus": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Vous perdez ", _interpolate(_named("points")), " points de ", _interpolate(_named("name")), "."]);
    },
    "characters": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Personnages"]);
    },
    "bars": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Jauges"]);
    },
    "polls": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Sondages"]);
    },
    "challenge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["preuve"]);
    },
    "stats": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Caractristiques"]);
    },
    "settings": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Paramtres"]);
    },
    "tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tags"]);
    },
    "draw": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tirage"]);
    },
    "help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Aide"]);
    },
    "start": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Dmarrer"]);
    },
    "invite_to_play": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Inviter  jouer"]);
    },
    "invite_link_copied": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Lien d'invitation copi !"]);
    },
    "game_id_copied": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Identifiant de partie copi !"]);
    },
    "strength": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Physique"]);
    },
    "mind": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Mental"]);
    },
    "health": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vie"]);
    },
    "will": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Volont"]);
    },
    "game_rename": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Renommer la partie"]);
    },
    "selected": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Slectionns"]);
    },
    "continue_game": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Continuer - ", _interpolate(_named("name"))]);
    },
    "count_personnage": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
      return _plural([_normalize(["1 personnage"]), _normalize([_interpolate(_named("count")), " personnages"])]);
    },
    "continue": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Continuer"]);
    },
    "see_more": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Voir plus"]);
    },
    "any_game": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous n'avez cr aucune partie."]);
    },
    "cancel": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Annuler"]);
    },
    "in_progress": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["En attente"]);
    },
    "start_game": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Lancer la partie"]);
    },
    "warning_version": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Les parties marques d'un <span class='danger'>*</span> ne sont pas compatibles avec votre version de Minotaure (", _interpolate(_named("version")), "), elles pourraient ne pas fonctionner correctement."]);
    },
    "delete_all_games": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Supprimer toutes les parties"]);
    },
    "confirm_question": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Confirmer ?"]);
    },
    "game_name_invite": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Nom de votre partie. Vous pourrez le changer plus tard."]);
    },
    "my_game": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ma partie"]);
    },
    "game_id_help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Cet identifiant sera inclus dans votre lien d'invitation. Vous pouvez choisir le vtre."]);
    },
    "add_poll": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ajouter un sondage"]);
    },
    "active_polls": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Voir les sondages actifs"]);
    },
    "past_polls": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Voir les sondages passs"]);
    },
    "question": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Question"]);
    },
    "possible_choices": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Choix possibles"]);
    },
    "add_poll_choice": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ajouter un choix"]);
    },
    "start_poll": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Lancer le sondage"]);
    },
    "show_poll_results": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Montrer les rsultats"]);
    },
    "close_poll": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Terminer le sondage"]);
    },
    "nb_choice": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Choix ", _interpolate(_named("choice"))]);
    },
    "choice_gives_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ce choix donnera le tag suivant"]);
    },
    "turnout": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Participation : "]);
    },
    "other_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Divers"]);
    },
    "minotaure_welcome": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Bienvenue dans Minotaure"]);
    },
    "tutorial_help_1": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez dmarrer le didacticiel  tout moment en cliquant sur le bouton <strong class='icon-question'>Aide</strong> (le didacticiel complet sera disponible dans une version future)."]);
    },
    "tutorial_help_2": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Avant de dmarrer votre partie, vous pouvez modifier les <strong>paramtres</strong> et les <strong>tags</strong> dans les onglets correspondants."]);
    },
    "tutorial_help_3": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez ds maintenant inviter vos joueurs dans la partie en cliquant sur le bouton <strong class='icon-email'>Invitation  jouer</strong>."]);
    },
    "tutorial_help_4": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tant que vous n'aurez pas cliqu sur <strong class='icon-play'>Dmarrer</strong> ils seront en salle d'attente."]);
    },
    "next": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Suivant"]);
    },
    "end_tour": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Terminer la visite"]);
    },
    "end_tab_tour": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Terminer la visite de cet onglet"]);
    },
    "step_help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Souhaitez-vous suivre la visite complte ou obtenir uniquement l'aide pour cet onglet ?"]);
    },
    "see_all_tutorial": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Visite complte"]);
    },
    "see_page_tutorial": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Visite de cet onglet"]);
    },
    "step_game_name": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez changer le nom de la partie  tout moment."]);
    },
    "step_invite": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["En cliquant sur ce bouton un lien d'invitation sera copi et vous permettra d'inviter  rejoindre  votre partie."]);
    },
    "step_start": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tant que vous ne cliquez pas sur ce bouton, vos invits patienteront sur un cran d'attente."]);
    },
    "tab_label_settings": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Les paramtres sont les rglages de la partie que nous vous conseillons de modifier avant son dmarrage, mais que vous pourrez toujours changer en cours de partie."]);
    },
    "step_settings_gauges": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Les jauges sont des rserves de points pour chaque personnage. Quand vous crez une partie, deux jauges sont cres par dfaut : vie et volont."]);
    },
    "step_settings_add_gauge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez ajouter autant de jauge que vous le souhaitez."]);
    },
    "step_settings_gauge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tous les personnages possdent ces jauges  leur cration, avec un nombre de points de dpart que vous pouvez modifier."]);
    },
    "step_settings_gauge_delete": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez supprimer une jauge  tout moment."]);
    },
    "step_settings_gauge_make_deadly": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez faire en sorte que le passage d'une jauge  un score de 0 entraine la mort d'un personnage en cliquant sur ce bouton (cette action est rversible mais les personnages dj morts ne seront pas ressuscits pour autant !)."]);
    },
    "step_settings_stats": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Les caractristiques fonctionnent de la mme faon que dans la plupart des jeux de rle. Quand vous crez une partie, deux caractristiques sont cres : physique et mental."]);
    },
    "step_settings_add_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez ajouter autant de caractristiques que vous le souhaitez."]);
    },
    "step_settings_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tous les personnages possdent ces caractristiques  leur cration, avec un nombre de points de dpart de 10 + un nombre alatoire entre -9 et +9. <br> Le total des caractristiques d'un personnage  sa cration est toujours de 10 x le nombre de caractristiques, pour garantir le mme total de points  tous les participants."]);
    },
    "step_settings_stat_delete": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez supprimer une caractristique  tout moment."]);
    },
    "tab_label_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Les tags sont des tiquettes attribues aux personnages et font la grande force de Minotaure.<br>"]);
    },
    "step_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Chaque tag fait partie d'un groupe de tag, qui peut tre nomm (exemple: mtiers, genre, peuple, avantages, dfauts, etc.). Un tag peut servir comme une classe de personnage, mais est suffisamment polyvalent pour permettre d'autres utilisations."]);
    },
    "step_tags_group_add": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez ajouter autant de groupes de tags que vous le souhaitez"]);
    },
    "step_tags_group": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Commencez  taper du texte et validez pour crer un tag. Une couleur lui sera associe."]);
    },
    "step_tags_group_distribution": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Pour chaque groupe de tags, vous pouvez choisir un mode de rpartition des tags : <ul> <li>- choisis par le joueur  la cration du personnage</li> <li>- attribus alatoirement</li> <li>- attribus quitablement (le systme choisira parmi les tags les moins attribus pour quilibrer les tags distribus)</li> <li>- non attribus  la cration (vous vous en servirez autrement qu' la cration)</li> </ul>"]);
    },
    "step_tags_group_distribute": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Cliquez ici pour distribuer un tag de ce groupe  tous les personnages qui n'en ont pas dj un. Utile si vous avez cr le groupe en cours de partie."]);
    },
    "step_tags_group_shuffle": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Cliquez ici pour distribuer un tag de ce groupe  tous les personnages qui en ont dj un. Le nouveau tag remplacera l'ancien. Utile si vous n'tes pas satisfait de la rpartition actuelle."]);
    },
    "step_tags_group_rename": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez renommer  tout moment un groupe de tag."]);
    },
    "step_tags_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([`Chaque tag peut influer sur les jauges et les caractristiques d'un personnage  sa cration. En cliquant sur un tag, vous pouvez: <ul> <li>- lui associer une <strong>caractristique principale</strong>. Si un personnage obtient ce tag  la cration, ce sera automatiquement sa plus forte caractristique. Exemple: un tag "magicien" pourrait avoir la caractristique principale "Magie".</li> <li>- lui associer une <strong>caractristique secondaire</strong>. Si un personnage obtient ce tag  la cration, ce sera automatiquement sa deuxime plus forte caractristique.</li> <li>- lui associer des <strong>bonus</strong> et des <strong>malus</strong> qui viennent modifier le tirage des caractristiques de dpart, ou la valeur de dpart de certaines jauges.</li> <li>- augmenter ou diminuer sa <strong>probabilit</strong> d'attribution alatoire.</li> <li>- changer sa <strong>couleur</strong></li> </ul>`]);
    },
    "example": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["exemple"]);
    },
    "step_tags_group_delete": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez supprimer un groupe de tags  tout moment. Cela supprimera les tags correspondants pour les personnages."]);
    },
    "tab_label_characters": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["C'est l'onglet que vous montrerez le plus pendant la partie : il prsente l'ensemble des personnages crs et rsume ses proprits (nom du personnage, pseudo du joueur, jauges, caractristiques, tags, etc.). Vous pouvez y rechercher les personnages selon de nombreux critres."]);
    },
    "tab_label_poll": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez dclencher un sondage qui vous permettra de savoir dans quel sens faire voluer la partie. Vous pouvez galement ajouter des tags aux personnages en fonction des choix de chaque joueur au sondage."]);
    },
    "tab_label_challenge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous pouvez dclencher l'quivalent de jets de ds qui entraneront pour chaque personnage concern des consquences selon sa russite ou son chec."]);
    },
    "tab_label_pick": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Les tirages au sort vous permettent de slectionner un nombre de personnages de votre choix au hasard parmi tout ou partie de la population. Vous pouvez galement appliquer des consquences aux personnages tirs au sort."]);
    },
    "add": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ajouter"]);
    },
    "gauge_start": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Dmarre  ", _interpolate(_named("gauge_value"))]);
    },
    "kills_at_0": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tue  0"]);
    },
    "submit": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Valider"]);
    },
    "make_normal": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rendre normale"]);
    },
    "make_fatal": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rendre fatale"]);
    },
    "modify": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Modifier"]);
    },
    "delete": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Supprimer"]);
    },
    "name": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Nom"]);
    },
    "starts_at": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Dmarre "]);
    },
    "rename": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Renommer"]);
    },
    "dif_cake": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Trivial"]);
    },
    "dif_ext_easy": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ais"]);
    },
    "dif_very_easy": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Facile"]);
    },
    "dif_easy": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Assez facile"]);
    },
    "dif_moderate": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Modr"]);
    },
    "dif_hard": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Assez difficile"]);
    },
    "dif_very_hard": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Difficile"]);
    },
    "dif_extreme": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ardu"]);
    },
    "dif_impossible": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Cauchemardesque"]);
    },
    "added_tag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["tag ajout : ", _interpolate(_named("tag_label"))]);
    },
    "removed_tag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["tag enlev : ", _interpolate(_named("tag_label"))]);
    },
    "must_first": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous devez d'abord "]);
    },
    "add_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["crer une caractristique"]);
    },
    "tested_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Caractristique  tester"]);
    },
    "choose_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Choisissez une caractristique"]);
    },
    "difficulty": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Difficult : "]);
    },
    "targets": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Cibles"]);
    },
    "add_target": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ajouter une cible"]);
    },
    "everyone": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tout le monde"]);
    },
    "positive_csq": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Consquences de russite"]);
    },
    "negative_csq": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Consquences d'chec"]);
    },
    "add_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ajouter les tags"]);
    },
    "add_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ajouter un tag"]);
    },
    "input_word": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tapez un mot"]);
    },
    "no_tag_create": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Aucun autre tag, inventez-en un !"]);
    },
    "remove_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Retirer les tags"]);
    },
    "this_will_test": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vous allez dclencher une preuve de "]);
    },
    "for_everyone": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Pour tout le monde"]);
    },
    "for_every": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Pour chaque : "]);
    },
    "challenge_characters": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Les personnages "]);
    },
    "that_pass": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["russissant"]);
    },
    "that_fail": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["chouant"]);
    },
    "will_have": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([" obtiendront : "]);
    },
    "get_following_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ces tags en plus : "]);
    },
    "lose_following_tags": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ces tags en moins (s'ils les ont) : "]);
    },
    "start_challenge": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Lancer l'preuve !"]);
    },
    "context_add_selection_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ajouter  la slection (maj + clic gauche)"]);
    },
    "context_remove_selection_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Retirer de la slection (maj + clic gauche)"]);
    },
    "context_delete_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Supprimer le personnage"]);
    },
    "context_edit_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Modifier le personnage ( venir)"]);
    },
    "last_challenge_success_rate": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["La dernire preuve a connu un pourcentage de russite de "]);
    },
    "select_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Choisir un tag"]);
    },
    "alive": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Vivants"]);
    },
    "connected": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Connects"]);
    },
    "passed": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Russites"]);
    },
    "failed": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["checs"]);
    },
    "show_all_characters": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Montrer tout"]);
    },
    "spawn_npc": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Gnrer un PNJ"]);
    },
    "characters_on": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([" sur "]);
    },
    "no_characters_to_show_try_different_filter": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Aucun personnage ne correspond  ces filtres"]);
    },
    "search_character": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rechercher un personnage"]);
    },
    "start_typing": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Commencez  taper"]);
    },
    "clear_selection": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Effacer la slection"]);
    },
    "char_picked": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Slectionns"]);
    },
    "add_all_to_selection": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tout ajouter  la slection"]);
    },
    "group_nb": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Groupe ", _interpolate(_named("nb"))]);
    },
    "bonus_gauge": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Augmenter la jauge ", _interpolate(_named("name"))]);
    },
    "malus_gauge": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Diminuer la jauge ", _interpolate(_named("name"))]);
    },
    "bonus_stat": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Augmenter la caractristique ", _interpolate(_named("name"))]);
    },
    "malus_stat": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Diminuer la caractristique ", _interpolate(_named("name"))]);
    },
    "linkStatToTag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Associer  ", _interpolate(_named("statname")), " comme carac principale"]);
    },
    "unlinkStatToTag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Ne plus associer  ", _interpolate(_named("statname")), " comme carac principale"]);
    },
    "link2StatToTag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Associer  ", _interpolate(_named("statname")), " comme carac secondaire"]);
    },
    "unlink2StatToTag": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Ne plus associer  ", _interpolate(_named("statname")), " comme carac secondaire"]);
    },
    "change_tag_color": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Changer la couleur"]);
    },
    "add_groug_of_tag": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Ajouter un groupe de tags"]);
    },
    "distribution_mode": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rgle d'attribution : "]);
    },
    "randomly_distributed_at_creation": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rpartis alatoirement  la cration"]);
    },
    "equitably_distributed_at_creation": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rpartis quitablement  la cration"]);
    },
    "chosen_at_char_creation": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["A choisir  la cration du personnage"]);
    },
    "not_autodistributed": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Pas de rgle"]);
    },
    "distribute": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Distribuer"]);
    },
    "shuffle": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Mlanger"]);
    },
    "shuffle_help": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Pour chaque personnage ayant dj un tag de ce groupe, un tag du groupe lui sera attribu au hasard  la place"]);
    },
    "main_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([" Carac principale : "]);
    },
    "secondary_stat": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize([" Carac secondaire : "]);
    },
    "tags_submit": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Terminer"]);
    },
    "a_tag_will_be_assigned_to_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Pour chaque personnage n'ayant pas encore de tag de ce groupe, un tag lui sera attribu au hasard"]);
    },
    "delete_groupe_tags_and_remove_from_chars": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Tous les tags de ce groupe seront supprims, et retirs des personnages"]);
    },
    "increase_probability": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Augmenter la probabilit"]);
    },
    "decrease_probability": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Diminuer la probabilit"]);
    },
    "tag_probability": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
      return _plural([_normalize(["1 chance sur ", _interpolate(_named("total"))]), _normalize([_interpolate(_named("count")), " chances sur ", _interpolate(_named("total"))])]);
    },
    "count_char_import": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named, plural: _plural } = ctx;
      return _plural([_normalize(["1 personnage import"]), _normalize([_interpolate(_named("count")), " personnages imports"])]);
    },
    "invalid_qr_code": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["QR code invalide"]);
    },
    "export_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Exporter vos personnages"]);
    },
    "import_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Importer vos personnages"]);
    },
    "delete_all_chars": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Supprimer tous vos personnages"]);
    },
    "admin_pick_one": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["parmi les personnages ayant un de ces tags :"]);
    },
    "admin_pick_all": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["parmi les personnages ayant tous ces tags :"]);
    },
    "admin_pick_none": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["parmi les personnages n'ayant aucun de ces tags :"]);
    },
    "admin_pick_each": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["personnages par tag :"]);
    },
    "admin_pick_launch": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Lancer le tirage"]);
    },
    "future_feature": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["future fonctionnalit"]);
    },
    "admin_pick_add_csq": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Consquences supplmentaires du tirage"]);
    },
    "game_id": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["ID de la partie"]);
    },
    "join": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Rejoindre"]);
    },
    "back_to_home": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Retourner  l'accueil"]);
    },
    "waiting_for_game_start": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["En attente du dmarrage de la partie"]);
    },
    "char_name": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Nom de votre personnage"]);
    },
    "user_name": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Votre pseudo (optionnel)"]);
    },
    "your_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Votre personnage est "]);
    },
    "submit_your_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Valider votre personnage"]);
    },
    "send_answer": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Envoyer mon choix"]);
    },
    "is_dead": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize([_interpolate(_named("charname")), " est mort"]);
    },
    "poll_pending": (ctx) => {
      const { normalize: _normalize, interpolate: _interpolate, named: _named } = ctx;
      return _normalize(["Sondage ", _interpolate(_named("pollnb")), " en attente"]);
    },
    "create_new_char": (ctx) => {
      const { normalize: _normalize } = ctx;
      return _normalize(["Crer un nouveau personnage"]);
    }
  }
};
const Main_vue_vue_type_style_index_0_lang = "";
const _export_sfc = (sfc, props) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target2[key] = val;
  }
  return target2;
};
const _sfc_main$g = {
  setup() {
    const current_route = ref("");
    return { current_route };
  },
  data() {
    return {
      locale: localStorage.getItem("locale_name") ?? this.$i18n.locale,
      themes: ["dark", "light", "blue"],
      root: null
    };
  },
  mounted: function() {
    this.$i18n.locale = this.locale;
    this.root = document.documentElement;
    const theme_name = localStorage.getItem("theme_name");
    document.documentElement.setAttribute("data-theme", theme_name ?? "dark");
  },
  methods: {
    changeTheme(name) {
      localStorage.setItem("theme_name", name);
      document.documentElement.setAttribute("data-theme", name);
    },
    changeLocale() {
      this.$i18n.locale = this.locale;
      localStorage.setItem("locale_name", this.locale);
    }
  }
};
const _hoisted_1$g = { id: "main" };
const _hoisted_2$g = {
  class: "main-wrapper",
  ref: "main"
};
const _hoisted_3$g = { class: "options-switch" };
const _hoisted_4$f = { id: "theme-switch" };
const _hoisted_5$d = ["data-theme", "onClick"];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_view = resolveComponent("router-view");
  const _component_router_link = resolveComponent("router-link");
  return openBlock(), createElementBlock("div", _hoisted_1$g, [
    createBaseVNode("div", _hoisted_2$g, [
      createVNode(_component_router_view)
    ], 512),
    createBaseVNode("div", _hoisted_3$g, [
      createBaseVNode("div", _hoisted_4$f, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.themes, (theme) => {
          return openBlock(), createElementBlock("div", {
            class: "picker",
            "data-theme": theme,
            onClick: ($event) => $options.changeTheme(theme)
          }, null, 8, _hoisted_5$d);
        }), 256))
      ]),
      _ctx.$route.path !== "/home" ? (openBlock(), createBlock(_component_router_link, {
        key: 0,
        to: "/home"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString$1(_ctx.$t("back_to_home")), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      createBaseVNode("div", null, [
        withDirectives(createBaseVNode("select", {
          onChange: _cache[0] || (_cache[0] = ($event) => $options.changeLocale()),
          id: "language-switch",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.locale = $event)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$i18n.availableLocales, (locale) => {
            return openBlock(), createElementBlock("option", null, toDisplayString$1(locale), 1);
          }), 256))
        ], 544), [
          [vModelSelect, $data.locale]
        ])
      ])
    ])
  ]);
}
const Main = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f]]);
const Home_vue_vue_type_style_index_0_lang = "";
const _sfc_main$f = {
  setup() {
    const version2 = "1.0.0";
    return {
      version: version2,
      store: usePlayerStore()
    };
  }
};
const _hoisted_1$f = { id: "home" };
const _hoisted_2$f = { class: "menu" };
const _hoisted_3$f = /* @__PURE__ */ createBaseVNode("div", { class: "logo-wrapper" }, [
  /* @__PURE__ */ createBaseVNode("span", null, "minotaure"),
  /* @__PURE__ */ createBaseVNode("svg", {
    class: "logo",
    "aria-hidden": "true",
    focusable: "false",
    role: "img",
    version: "1.1",
    viewBox: "0 0 1466.1 1466.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("g", { transform: "translate(-374.54 -11291)" }, [
      /* @__PURE__ */ createBaseVNode("circle", {
        cx: "1107.6",
        cy: "12024",
        r: "733.06",
        fill: "#fff",
        "stroke-dasharray": "2.11592, 4.23184",
        "stroke-opacity": ".8",
        "stroke-width": "2.1159"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "m1107.6 12251c-43.501 0-78.764-35.263-78.764-78.764v-131.27c0-43.5 35.263-78.764 78.764-78.764 43.5 0 78.764 35.264 78.764 78.764v131.27c0 43.501-35.264 78.764-78.764 78.764z",
        fill: "#cc4c4c",
        "stroke-width": ".82046"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "m859.96 11429c-1.917-0.03-4.4812 0.931-7.7422 3.436l-228.12 175.24c-10.946 8.41-5.8818 17.419-2.9355 25.414l68.51 185.91c8.4572 22.949 7.7487 16.721 24.025 5.336l164.21-114.85c17.14-11.989 19.057-13.846 0.15625-21.801l-120.51-50.721c-14.902-6.272-15.897-18.784-10.643-26.525l115.78-170.58c2.818-4.151 2.1616-10.775-2.7344-10.864zm495.28 0c-4.897 0.09-5.5514 6.713-2.7344 10.864l115.78 170.58c5.254 7.741 4.2604 20.253-10.643 26.525l-120.51 50.721c-18.9 7.955-16.985 9.812 0.1563 21.801l164.21 114.85c16.276 11.385 15.568 17.613 24.025-5.336l68.51-185.91c2.946-7.995 8.0095-17.004-2.9375-25.414l-228.12-175.24c-3.261-2.505-5.8262-3.471-7.7422-3.436zm-496.92 481.76c-48.07 0-87.04 38.971-87.039 87.041 0 48.07 38.97 87.039 87.039 87.039 48.07 0 87.039-38.969 87.039-87.039s-38.968-87.041-87.039-87.041zm498.55 0c-48.071 0-87.038 38.971-87.037 87.041 0 48.07 38.967 87.039 87.037 87.039 48.069 0 87.039-38.969 87.039-87.039s-38.969-87.041-87.039-87.041zm-380.55 209.33c-7.254 0-13.127 5.874-13.127 13.127v39.383c0 72.939 54.388 133.3 124.71 142.95v27.707h-45.945l16.408 39.381h98.455l16.41-39.381h-45.945v-28.019c72.225-9.96 124.71-75.524 124.71-149.07v-32.95c0-7.253-5.874-13.127-13.127-13.127h-13.127c-7.253 0-13.129 5.874-13.129 13.127v34.705c0 54.815-39.964 103.86-94.525 109.19-62.601 6.104-115.51-43.14-115.51-104.51v-39.383c0-7.253-5.875-13.127-13.127-13.127z",
        "stroke-width": ".82046"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "m1107.6 11664c-10.209 0-20.421 4.941-26.508 14.821l-131.35 231.4c21.692 22.698 35.018 53.459 35.018 87.334 0 2.935-0.10864 5.846-0.30664 8.731h22.613c11.92-44.366 52.413-77.026 100.54-77.026s88.622 32.66 100.54 77.026h22.611c-0.197-2.885-0.3047-5.796-0.3047-8.731 0-33.871 13.323-64.629 35.01-87.326l-131.36-231.4c-6.087-9.88-16.298-14.821-26.508-14.821zm-130.97 20.688c-2.556-0.01-5.2286 0.645-7.8516 2.144l-293.29 191.78c-4.8038 3.15-4.6471 10.229 0.25391 13.185l72.611 43.364c21.742-38.238 62.844-64.034 109.97-64.034 12.998 0 25.541 1.968 37.344 5.612l94.074-168.24c6.858-11.156-2.0363-23.762-13.113-23.81zm261.93 0c-11.077 0.05-19.972 12.654-13.115 23.81l94.078 168.24c11.807-3.646 24.35-5.616 37.352-5.616 47.127 0 88.225 25.787 109.97 64.018l72.607-43.367c4.92-2.956 5.056-10.037 0.252-13.188l-293.29-191.75c-2.621-1.499-5.2926-2.155-7.8496-2.144zm-589.96 264.27c-4.0452 0.02-7.752 3.255-7.752 7.792v316.63c0 7.838 10.288 10.755 14.41 4.065l115.9-188.34c-24.161-23.012-39.236-55.478-39.258-91.473l-79.264-47.552c-1.2982-0.778-2.6854-1.13-4.0332-1.123zm917.98 0c-1.349-0.01-2.7332 0.345-4.0312 1.123l-79.25 47.554c-0.02 36.001-15.105 68.473-39.275 91.485l115.9 188.34c4.103 6.69 14.41 3.773 14.41-4.084v-316.63c0-4.537-3.7089-7.771-7.7539-7.792zm-722.25 174.54c-15.576-0.08-31.399 11.196-47.389 34.812l-153.77 227.11c-5.99 9.724 0.19305 22.363 11.531 23.608l360.52 38.205c30.463 3.228 39.479-4.075 22.57-33.662l-138.29-241.98c-17.936-31.384-36.372-48.001-55.17-48.091zm526.52 0c-18.798 0.09-37.236 16.707-55.172 48.091l-138.29 241.98c-16.909 29.587-7.8927 36.89 22.57 33.662l360.52-38.205c11.338-1.245 17.521-13.884 11.531-23.608l-153.77-227.11c-15.99-23.616-31.813-34.887-47.389-34.812zm-691.04 349.54c-8.0636-0.186-11.075 11.046-3.4824 14.777l378.06 170.48c10.307 4.766 22.074-2.782 22.074-14.119v-127.71l-395.86-43.368c-0.2707-0.03-0.53512-0.05-0.79492-0.06zm855.54 0c-0.261 0.01-0.5269 0.02-0.7969 0.06l-395.86 43.35v127.72c0 11.357 11.763 18.884 22.07 14.119l378.06-170.48c7.591-3.711 4.5816-14.943-3.4824-14.758z",
        fill: "#a33737",
        "stroke-width": "1.9448"
      })
    ])
  ])
], -1);
const _hoisted_4$e = { class: "small-wrapper infos" };
const _hoisted_5$c = { href: "https://github.com/uurshin/minotaure" };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");
  const _component_router_view = resolveComponent("router-view");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", _hoisted_1$f, [
      createBaseVNode("div", _hoisted_2$f, [
        createBaseVNode("div", null, [
          createVNode(_component_router_link, { to: "/create" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(_ctx.$t("game_create")), 1)
            ]),
            _: 1
          }),
          createVNode(_component_router_link, { to: "/continue" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(_ctx.$t("game_manage")), 1)
            ]),
            _: 1
          })
        ]),
        _hoisted_3$f,
        createBaseVNode("div", null, [
          createVNode(_component_router_link, { to: "/join" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(_ctx.$t("game_join")), 1)
            ]),
            _: 1
          }),
          createVNode(_component_router_link, { to: "/characters" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString$1(_ctx.$t("character_manage")), 1)
            ]),
            _: 1
          })
        ])
      ]),
      createBaseVNode("div", _hoisted_4$e, [
        createBaseVNode("span", null, "Version : " + toDisplayString$1($setup.version), 1),
        createBaseVNode("a", _hoisted_5$c, toDisplayString$1(_ctx.$t("read_more")), 1)
      ])
    ]),
    createVNode(_component_router_view)
  ], 64);
}
const Home = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e]]);
const Create_vue_vue_type_style_index_0_scoped_85fa7177_lang = "";
const _sfc_main$e = {
  data() {
    const store = usePlayerStore();
    return {
      store,
      peer: "",
      connections: [],
      id_admin: "",
      name: "",
      btn_text: this.$t("in_progress"),
      step: 0
    };
  },
  computed: {
    isBtnDisabled() {
      if (this.step === 0) {
        if (this.name.length === 0 || this.name.length === 1) {
          this.btn_text = this.$t("submit");
        }
        if (this.name.length === 0) {
          return true;
        }
      } else if (this.step === 1) {
        this.btn_text = this.$t("start_game");
      }
      return false;
    }
  },
  mounted() {
  },
  methods: {
    ask_id() {
      const vm = this;
      if (this.step === 0) {
        this.step = 1;
        let peer = new $416260bce337df90$export$ecd1fc136c422448(this.id_admin);
        peer.once("open", function() {
          vm.store.setPeer(peer);
          vm.id_admin = peer.id;
          vm.$nextTick(() => {
            vm.$refs.id_admin.focus();
          });
        });
      } else {
        this.launch();
      }
    },
    launch() {
      const vm = this;
      let games_storage = localStorage.getItem("games");
      games_storage = games_storage == null ? [] : JSON.parse(games_storage);
      let new_game = {
        id: Date.now(),
        name: this.name,
        characters: [],
        date: Date.now(),
        version: "1.0.0",
        init: true,
        tag_groups: []
      };
      games_storage.push(new_game);
      this.store.setCurrentGame(new_game);
      this.store.current_game.initialized = false;
      this.store.current_game.tuto_on = true;
      this.store.current_game.game_started = false;
      localStorage.setItem("games", JSON.stringify(games_storage));
      localStorage.removeItem("temp_game");
      if (this.id_admin !== "" && this.store.peer.id !== this.id_admin) {
        this.store.peer.destroy();
        let peer = new $416260bce337df90$export$ecd1fc136c422448(this.id_admin);
        peer.on("open", function() {
          vm.store.setPeer(peer);
          router.push("/admin");
        });
      } else {
        router.push("/admin");
      }
    }
  }
};
const _hoisted_1$e = { class: "small-wrapper menu-wrapper" };
const _hoisted_2$e = {
  key: 0,
  for: "name"
};
const _hoisted_3$e = ["placeholder"];
const _hoisted_4$d = {
  key: 2,
  for: "id_admin"
};
const _hoisted_5$b = ["disabled"];
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("h1", null, toDisplayString$1(_ctx.$t("game_create")), 1),
    createBaseVNode("div", _hoisted_1$e, [
      $data.step === 0 ? (openBlock(), createElementBlock("label", _hoisted_2$e, toDisplayString$1(_ctx.$t("game_name_invite")), 1)) : createCommentVNode("", true),
      $data.step === 0 ? withDirectives((openBlock(), createElementBlock("input", {
        key: 1,
        onKeyup: _cache[0] || (_cache[0] = withKeys((...args) => $options.ask_id && $options.ask_id(...args), ["enter"])),
        autocomplete: "off",
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.name = $event),
        type: "text",
        id: "name",
        value: "Ma partie",
        placeholder: _ctx.$t("my_game"),
        maxlength: "25"
      }, null, 40, _hoisted_3$e)), [
        [vModelText, $data.name]
      ]) : createCommentVNode("", true),
      $data.step === 1 ? (openBlock(), createElementBlock("label", _hoisted_4$d, toDisplayString$1(_ctx.$t("game_id_help")), 1)) : createCommentVNode("", true),
      $data.step === 1 ? withDirectives((openBlock(), createElementBlock("input", {
        key: 3,
        type: "text",
        ref: "id_admin",
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.id_admin = $event),
        id: "id_admin",
        onKeyup: _cache[3] || (_cache[3] = withKeys((...args) => $options.launch && $options.launch(...args), ["enter"]))
      }, null, 544)), [
        [vModelText, $data.id_admin]
      ]) : createCommentVNode("", true),
      createBaseVNode("button", {
        class: "btn-valid",
        disabled: $options.isBtnDisabled,
        onClick: _cache[4] || (_cache[4] = (...args) => $options.ask_id && $options.ask_id(...args)),
        onKeyup: _cache[5] || (_cache[5] = withKeys((...args) => $options.ask_id && $options.ask_id(...args), ["enter"]))
      }, toDisplayString$1($data.btn_text), 41, _hoisted_5$b)
    ])
  ], 64);
}
const Create = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d], ["__scopeId", "data-v-85fa7177"]]);
const Join_vue_vue_type_style_index_0_lang = "";
const _sfc_main$d = {
  setup() {
    const store = usePlayerStore();
    return {
      store
    };
  },
  data() {
    return {
      peer_client: null,
      id_join: "",
      btn_text: this.$t("in_progress")
    };
  },
  computed: {
    isBtnDisabled() {
      if (this.id_join.length === 0) {
        this.btn_text = this.$t("in_progress");
        return true;
      }
      this.btn_text = this.$t("join");
      return false;
    }
  },
  mounted() {
    if (this.$route.query.id !== void 0 && this.$route.query.id !== "") {
      this.id_join = this.$route.query.id;
      this.store.join(this.$route.query.id);
    }
    localStorage.removeItem("temp_peer");
  }
};
const _hoisted_1$d = {
  key: 0,
  id: "wrapper-message"
};
const _hoisted_2$d = { class: "small-wrapper menu-wrapper" };
const _hoisted_3$d = { for: "id_join" };
const _hoisted_4$c = ["disabled"];
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(Transition, { name: "fade" }, {
      default: withCtx(() => [
        $setup.store.message ? (openBlock(), createElementBlock("div", _hoisted_1$d, [
          createBaseVNode("div", null, toDisplayString$1($setup.store.message), 1)
        ])) : createCommentVNode("", true)
      ]),
      _: 1
    }),
    createBaseVNode("h1", null, toDisplayString$1(_ctx.$t("character_manage")), 1),
    createBaseVNode("div", _hoisted_2$d, [
      createBaseVNode("label", _hoisted_3$d, toDisplayString$1(_ctx.$t("game_id")), 1),
      withDirectives(createBaseVNode("input", {
        name: "id_join",
        autocomplete: "off",
        type: "text",
        id: "id_join",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.id_join = $event)
      }, null, 512), [
        [vModelText, $data.id_join]
      ]),
      createBaseVNode("button", {
        id: "join",
        disabled: $options.isBtnDisabled,
        onClick: _cache[1] || (_cache[1] = ($event) => $setup.store.join($data.id_join))
      }, toDisplayString$1($data.btn_text), 9, _hoisted_4$c)
    ])
  ], 64);
}
const Join = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$c]]);
const shepherd = "";
const AdminTabIntro_vue_vue_type_style_index_0_lang = "";
const _sfc_main$c = {
  components: {},
  data() {
    const store = usePlayerStore();
    return {
      store
    };
  },
  mounted() {
  },
  methods: {}
};
const _hoisted_1$c = {
  class: "tab",
  ref: "tab"
};
const _hoisted_2$c = { id: "tab-intro-content" };
const _hoisted_3$c = { class: "tutorial-help" };
const _hoisted_4$b = /* @__PURE__ */ createBaseVNode("div", { class: "logo-wrapper" }, [
  /* @__PURE__ */ createBaseVNode("svg", {
    class: "logo",
    "aria-hidden": "true",
    focusable: "false",
    role: "img",
    version: "1.1",
    viewBox: "0 0 1466.1 1466.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, [
    /* @__PURE__ */ createBaseVNode("g", { transform: "translate(-374.54 -11291)" }, [
      /* @__PURE__ */ createBaseVNode("circle", {
        cx: "1107.6",
        cy: "12024",
        r: "733.06",
        fill: "#fff",
        "stroke-dasharray": "2.11592, 4.23184",
        "stroke-opacity": ".8",
        "stroke-width": "2.1159"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "m1107.6 12251c-43.501 0-78.764-35.263-78.764-78.764v-131.27c0-43.5 35.263-78.764 78.764-78.764 43.5 0 78.764 35.264 78.764 78.764v131.27c0 43.501-35.264 78.764-78.764 78.764z",
        fill: "#cc4c4c",
        "stroke-width": ".82046"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "m859.96 11429c-1.917-0.03-4.4812 0.931-7.7422 3.436l-228.12 175.24c-10.946 8.41-5.8818 17.419-2.9355 25.414l68.51 185.91c8.4572 22.949 7.7487 16.721 24.025 5.336l164.21-114.85c17.14-11.989 19.057-13.846 0.15625-21.801l-120.51-50.721c-14.902-6.272-15.897-18.784-10.643-26.525l115.78-170.58c2.818-4.151 2.1616-10.775-2.7344-10.864zm495.28 0c-4.897 0.09-5.5514 6.713-2.7344 10.864l115.78 170.58c5.254 7.741 4.2604 20.253-10.643 26.525l-120.51 50.721c-18.9 7.955-16.985 9.812 0.1563 21.801l164.21 114.85c16.276 11.385 15.568 17.613 24.025-5.336l68.51-185.91c2.946-7.995 8.0095-17.004-2.9375-25.414l-228.12-175.24c-3.261-2.505-5.8262-3.471-7.7422-3.436zm-496.92 481.76c-48.07 0-87.04 38.971-87.039 87.041 0 48.07 38.97 87.039 87.039 87.039 48.07 0 87.039-38.969 87.039-87.039s-38.968-87.041-87.039-87.041zm498.55 0c-48.071 0-87.038 38.971-87.037 87.041 0 48.07 38.967 87.039 87.037 87.039 48.069 0 87.039-38.969 87.039-87.039s-38.969-87.041-87.039-87.041zm-380.55 209.33c-7.254 0-13.127 5.874-13.127 13.127v39.383c0 72.939 54.388 133.3 124.71 142.95v27.707h-45.945l16.408 39.381h98.455l16.41-39.381h-45.945v-28.019c72.225-9.96 124.71-75.524 124.71-149.07v-32.95c0-7.253-5.874-13.127-13.127-13.127h-13.127c-7.253 0-13.129 5.874-13.129 13.127v34.705c0 54.815-39.964 103.86-94.525 109.19-62.601 6.104-115.51-43.14-115.51-104.51v-39.383c0-7.253-5.875-13.127-13.127-13.127z",
        "stroke-width": ".82046"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "m1107.6 11664c-10.209 0-20.421 4.941-26.508 14.821l-131.35 231.4c21.692 22.698 35.018 53.459 35.018 87.334 0 2.935-0.10864 5.846-0.30664 8.731h22.613c11.92-44.366 52.413-77.026 100.54-77.026s88.622 32.66 100.54 77.026h22.611c-0.197-2.885-0.3047-5.796-0.3047-8.731 0-33.871 13.323-64.629 35.01-87.326l-131.36-231.4c-6.087-9.88-16.298-14.821-26.508-14.821zm-130.97 20.688c-2.556-0.01-5.2286 0.645-7.8516 2.144l-293.29 191.78c-4.8038 3.15-4.6471 10.229 0.25391 13.185l72.611 43.364c21.742-38.238 62.844-64.034 109.97-64.034 12.998 0 25.541 1.968 37.344 5.612l94.074-168.24c6.858-11.156-2.0363-23.762-13.113-23.81zm261.93 0c-11.077 0.05-19.972 12.654-13.115 23.81l94.078 168.24c11.807-3.646 24.35-5.616 37.352-5.616 47.127 0 88.225 25.787 109.97 64.018l72.607-43.367c4.92-2.956 5.056-10.037 0.252-13.188l-293.29-191.75c-2.621-1.499-5.2926-2.155-7.8496-2.144zm-589.96 264.27c-4.0452 0.02-7.752 3.255-7.752 7.792v316.63c0 7.838 10.288 10.755 14.41 4.065l115.9-188.34c-24.161-23.012-39.236-55.478-39.258-91.473l-79.264-47.552c-1.2982-0.778-2.6854-1.13-4.0332-1.123zm917.98 0c-1.349-0.01-2.7332 0.345-4.0312 1.123l-79.25 47.554c-0.02 36.001-15.105 68.473-39.275 91.485l115.9 188.34c4.103 6.69 14.41 3.773 14.41-4.084v-316.63c0-4.537-3.7089-7.771-7.7539-7.792zm-722.25 174.54c-15.576-0.08-31.399 11.196-47.389 34.812l-153.77 227.11c-5.99 9.724 0.19305 22.363 11.531 23.608l360.52 38.205c30.463 3.228 39.479-4.075 22.57-33.662l-138.29-241.98c-17.936-31.384-36.372-48.001-55.17-48.091zm526.52 0c-18.798 0.09-37.236 16.707-55.172 48.091l-138.29 241.98c-16.909 29.587-7.8927 36.89 22.57 33.662l360.52-38.205c11.338-1.245 17.521-13.884 11.531-23.608l-153.77-227.11c-15.99-23.616-31.813-34.887-47.389-34.812zm-691.04 349.54c-8.0636-0.186-11.075 11.046-3.4824 14.777l378.06 170.48c10.307 4.766 22.074-2.782 22.074-14.119v-127.71l-395.86-43.368c-0.2707-0.03-0.53512-0.05-0.79492-0.06zm855.54 0c-0.261 0.01-0.5269 0.02-0.7969 0.06l-395.86 43.35v127.72c0 11.357 11.763 18.884 22.07 14.119l378.06-170.48c7.591-3.711 4.5816-14.943-3.4824-14.758z",
        fill: "#a33737",
        "stroke-width": "1.9448"
      })
    ])
  ])
], -1);
const _hoisted_5$a = { class: "tuto-text" };
const _hoisted_6$9 = ["innerHTML"];
const _hoisted_7$9 = ["innerHTML"];
const _hoisted_8$9 = ["innerHTML"];
const _hoisted_9$9 = ["innerHTML"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$c, [
    createBaseVNode("div", _hoisted_2$c, [
      createBaseVNode("div", _hoisted_3$c, [
        createBaseVNode("h1", null, toDisplayString$1(_ctx.$t("minotaure_welcome")), 1),
        _hoisted_4$b,
        createBaseVNode("div", _hoisted_5$a, [
          createBaseVNode("div", {
            innerHTML: _ctx.$t("tutorial_help_1")
          }, null, 8, _hoisted_6$9),
          createBaseVNode("div", {
            innerHTML: _ctx.$t("tutorial_help_2")
          }, null, 8, _hoisted_7$9),
          createBaseVNode("div", {
            innerHTML: _ctx.$t("tutorial_help_3")
          }, null, 8, _hoisted_8$9),
          createBaseVNode("div", {
            innerHTML: _ctx.$t("tutorial_help_4")
          }, null, 8, _hoisted_9$9)
        ])
      ])
    ])
  ], 512);
}
const AdminTabIntro = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$b]]);
function isEmpty(opt) {
  if (opt === 0)
    return false;
  if (Array.isArray(opt) && opt.length === 0)
    return true;
  return !opt;
}
function not(fun) {
  return (...params) => !fun(...params);
}
function includes(str, query) {
  if (str === void 0)
    str = "undefined";
  if (str === null)
    str = "null";
  if (str === false)
    str = "false";
  const text2 = str.toString().toLowerCase();
  return text2.indexOf(query.trim()) !== -1;
}
function filterOptions(options, search, label, customLabel) {
  return search ? options.filter((option) => includes(customLabel(option, label), search)).sort((a, b) => customLabel(a, label).length - customLabel(b, label).length) : options;
}
function stripGroups(options) {
  return options.filter((option) => !option.$isLabel);
}
function flattenOptions(values, label) {
  return (options) => options.reduce((prev, curr) => {
    if (curr[values] && curr[values].length) {
      prev.push({
        $groupLabel: curr[label],
        $isLabel: true
      });
      return prev.concat(curr[values]);
    }
    return prev;
  }, []);
}
function filterGroups(search, label, values, groupLabel, customLabel) {
  return (groups) => groups.map((group) => {
    if (!group[values]) {
      console.warn(`Options passed to vue-multiselect do not contain groups, despite the config.`);
      return [];
    }
    const groupOptions = filterOptions(group[values], search, label, customLabel);
    return groupOptions.length ? {
      [groupLabel]: group[groupLabel],
      [values]: groupOptions
    } : [];
  });
}
const flow = (...fns) => (x) => fns.reduce((v, f2) => f2(v), x);
var multiselectMixin = {
  data() {
    return {
      search: "",
      isOpen: false,
      preferredOpenDirection: "below",
      optimizedHeight: this.maxHeight
    };
  },
  props: {
    /**
     * Decide whether to filter the results based on search query.
     * Useful for async filtering, where we search through more complex data.
     * @type {Boolean}
     */
    internalSearch: {
      type: Boolean,
      default: true
    },
    /**
     * Array of available options: Objects, Strings or Integers.
     * If array of objects, visible label will default to option.label.
     * If `labal` prop is passed, label will equal option['label']
     * @type {Array}
     */
    options: {
      type: Array,
      required: true
    },
    /**
     * Equivalent to the `multiple` attribute on a `<select>` input.
     * @default false
     * @type {Boolean}
     */
    multiple: {
      type: Boolean,
      default: false
    },
    /**
     * Key to compare objects
     * @default 'id'
     * @type {String}
     */
    trackBy: {
      type: String
    },
    /**
     * Label to look for in option Object
     * @default 'label'
     * @type {String}
     */
    label: {
      type: String
    },
    /**
     * Enable/disable search in options
     * @default true
     * @type {Boolean}
     */
    searchable: {
      type: Boolean,
      default: true
    },
    /**
     * Clear the search input after `)
     * @default true
     * @type {Boolean}
     */
    clearOnSelect: {
      type: Boolean,
      default: true
    },
    /**
     * Hide already selected options
     * @default false
     * @type {Boolean}
     */
    hideSelected: {
      type: Boolean,
      default: false
    },
    /**
     * Equivalent to the `placeholder` attribute on a `<select>` input.
     * @default 'Select option'
     * @type {String}
     */
    placeholder: {
      type: String,
      default: "Select option"
    },
    /**
     * Allow to remove all selected values
     * @default true
     * @type {Boolean}
     */
    allowEmpty: {
      type: Boolean,
      default: true
    },
    /**
     * Reset this.internalValue, this.search after this.internalValue changes.
     * Useful if want to create a stateless dropdown.
     * @default false
     * @type {Boolean}
     */
    resetAfter: {
      type: Boolean,
      default: false
    },
    /**
     * Enable/disable closing after selecting an option
     * @default true
     * @type {Boolean}
     */
    closeOnSelect: {
      type: Boolean,
      default: true
    },
    /**
     * Function to interpolate the custom label
     * @default false
     * @type {Function}
     */
    customLabel: {
      type: Function,
      default(option, label) {
        if (isEmpty(option))
          return "";
        return label ? option[label] : option;
      }
    },
    /**
     * Disable / Enable tagging
     * @default false
     * @type {Boolean}
     */
    taggable: {
      type: Boolean,
      default: false
    },
    /**
     * String to show when highlighting a potential tag
     * @default 'Press enter to create a tag'
     * @type {String}
    */
    tagPlaceholder: {
      type: String,
      default: "Press enter to create a tag"
    },
    /**
     * By default new tags will appear above the search results.
     * Changing to 'bottom' will revert this behaviour
     * and will proritize the search results
     * @default 'top'
     * @type {String}
    */
    tagPosition: {
      type: String,
      default: "top"
    },
    /**
     * Number of allowed selected options. No limit if 0.
     * @default 0
     * @type {Number}
    */
    max: {
      type: [Number, Boolean],
      default: false
    },
    /**
     * Will be passed with all events as second param.
     * Useful for identifying events origin.
     * @default null
     * @type {String|Integer}
    */
    id: {
      default: null
    },
    /**
     * Limits the options displayed in the dropdown
     * to the first X options.
     * @default 1000
     * @type {Integer}
    */
    optionsLimit: {
      type: Number,
      default: 1e3
    },
    /**
     * Name of the property containing
     * the group values
     * @default 1000
     * @type {String}
    */
    groupValues: {
      type: String
    },
    /**
     * Name of the property containing
     * the group label
     * @default 1000
     * @type {String}
    */
    groupLabel: {
      type: String
    },
    /**
     * Allow to select all group values
     * by selecting the group label
     * @default false
     * @type {Boolean}
     */
    groupSelect: {
      type: Boolean,
      default: false
    },
    /**
     * Array of keyboard keys to block
     * when selecting
     * @default 1000
     * @type {String}
    */
    blockKeys: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Prevent from wiping up the search value
     * @default false
     * @type {Boolean}
    */
    preserveSearch: {
      type: Boolean,
      default: false
    },
    /**
     * Select 1st options if value is empty
     * @default false
     * @type {Boolean}
    */
    preselectFirst: {
      type: Boolean,
      default: false
    },
    /**
     * Prevent autofocus
     * @default false
     * @type {Boolean}
    */
    preventAutofocus: {
      type: Boolean,
      default: false
    }
  },
  mounted() {
    if (!this.multiple && this.max) {
      console.warn("[Vue-Multiselect warn]: Max prop should not be used when prop Multiple equals false.");
    }
    if (this.preselectFirst && !this.internalValue.length && this.options.length) {
      this.select(this.filteredOptions[0]);
    }
  },
  computed: {
    internalValue() {
      return this.modelValue || this.modelValue === 0 ? Array.isArray(this.modelValue) ? this.modelValue : [this.modelValue] : [];
    },
    filteredOptions() {
      const search = this.search || "";
      const normalizedSearch = search.toLowerCase().trim();
      let options = this.options.concat();
      if (this.internalSearch) {
        options = this.groupValues ? this.filterAndFlat(options, normalizedSearch, this.label) : filterOptions(options, normalizedSearch, this.label, this.customLabel);
      } else {
        options = this.groupValues ? flattenOptions(this.groupValues, this.groupLabel)(options) : options;
      }
      options = this.hideSelected ? options.filter(not(this.isSelected)) : options;
      if (this.taggable && normalizedSearch.length && !this.isExistingOption(normalizedSearch)) {
        if (this.tagPosition === "bottom") {
          options.push({ isTag: true, label: search });
        } else {
          options.unshift({ isTag: true, label: search });
        }
      }
      return options.slice(0, this.optionsLimit);
    },
    valueKeys() {
      if (this.trackBy) {
        return this.internalValue.map((element2) => element2[this.trackBy]);
      } else {
        return this.internalValue;
      }
    },
    optionKeys() {
      const options = this.groupValues ? this.flatAndStrip(this.options) : this.options;
      return options.map((element2) => this.customLabel(element2, this.label).toString().toLowerCase());
    },
    currentOptionLabel() {
      return this.multiple ? this.searchable ? "" : this.placeholder : this.internalValue.length ? this.getOptionLabel(this.internalValue[0]) : this.searchable ? "" : this.placeholder;
    }
  },
  watch: {
    internalValue: {
      handler() {
        if (this.resetAfter && this.internalValue.length) {
          this.search = "";
          this.$emit("update:modelValue", this.multiple ? [] : null);
        }
      },
      deep: true
    },
    search() {
      this.$emit("search-change", this.search);
    }
  },
  emits: ["open", "search-change", "close", "select", "update:modelValue", "remove", "tag"],
  methods: {
    /**
     * Returns the internalValue in a way it can be emited to the parent
     * @returns {Object||Array||String||Integer}
     */
    getValue() {
      return this.multiple ? this.internalValue : this.internalValue.length === 0 ? null : this.internalValue[0];
    },
    /**
     * Filters and then flattens the options list
     * @param  {Array}
     * @return {Array} returns a filtered and flat options list
     */
    filterAndFlat(options, search, label) {
      return flow(
        filterGroups(search, label, this.groupValues, this.groupLabel, this.customLabel),
        flattenOptions(this.groupValues, this.groupLabel)
      )(options);
    },
    /**
     * Flattens and then strips the group labels from the options list
     * @param  {Array}
     * @return {Array} returns a flat options list without group labels
     */
    flatAndStrip(options) {
      return flow(
        flattenOptions(this.groupValues, this.groupLabel),
        stripGroups
      )(options);
    },
    /**
     * Updates the search value
     * @param  {String}
     */
    updateSearch(query) {
      this.search = query;
    },
    /**
     * Finds out if the given query is already present
     * in the available options
     * @param  {String}
     * @return {Boolean} returns true if element is available
     */
    isExistingOption(query) {
      return !this.options ? false : this.optionKeys.indexOf(query) > -1;
    },
    /**
     * Finds out if the given element is already present
     * in the result value
     * @param  {Object||String||Integer} option passed element to check
     * @returns {Boolean} returns true if element is selected
     */
    isSelected(option) {
      const opt = this.trackBy ? option[this.trackBy] : option;
      return this.valueKeys.indexOf(opt) > -1;
    },
    /**
     * Finds out if the given option is disabled
     * @param  {Object||String||Integer} option passed element to check
     * @returns {Boolean} returns true if element is disabled
     */
    isOptionDisabled(option) {
      return !!option.$isDisabled;
    },
    /**
     * Returns empty string when options is null/undefined
     * Returns tag query if option is tag.
     * Returns the customLabel() results and casts it to string.
     *
     * @param  {Object||String||Integer} Passed option
     * @returns {Object||String}
     */
    getOptionLabel(option) {
      if (isEmpty(option))
        return "";
      if (option.isTag)
        return option.label;
      if (option.$isLabel)
        return option.$groupLabel;
      const label = this.customLabel(option, this.label);
      if (isEmpty(label))
        return "";
      return label;
    },
    /**
     * Add the given option to the list of selected options
     * or sets the option as the selected option.
     * If option is already selected -> remove it from the results.
     *
     * @param  {Object||String||Integer} option to select/deselect
     * @param  {Boolean} block removing
     */
    select(option, key) {
      if (option.$isLabel && this.groupSelect) {
        this.selectGroup(option);
        return;
      }
      if (this.blockKeys.indexOf(key) !== -1 || this.disabled || option.$isDisabled || option.$isLabel)
        return;
      if (this.max && this.multiple && this.internalValue.length === this.max)
        return;
      if (key === "Tab" && !this.pointerDirty)
        return;
      if (option.isTag) {
        this.$emit("tag", option.label, this.id);
        this.search = "";
        if (this.closeOnSelect && !this.multiple)
          this.deactivate();
      } else {
        const isSelected = this.isSelected(option);
        if (isSelected) {
          if (key !== "Tab")
            this.removeElement(option);
          return;
        }
        if (this.multiple) {
          this.$emit("update:modelValue", this.internalValue.concat([option]));
        } else {
          this.$emit("update:modelValue", option);
        }
        this.$emit("select", option, this.id);
        if (this.clearOnSelect)
          this.search = "";
      }
      if (this.closeOnSelect)
        this.deactivate();
    },
    /**
     * Add the given group options to the list of selected options
     * If all group optiona are already selected -> remove it from the results.
     *
     * @param  {Object||String||Integer} group to select/deselect
     */
    selectGroup(selectedGroup) {
      const group = this.options.find((option) => {
        return option[this.groupLabel] === selectedGroup.$groupLabel;
      });
      if (!group)
        return;
      if (this.wholeGroupSelected(group)) {
        this.$emit("remove", group[this.groupValues], this.id);
        const newValue = this.internalValue.filter(
          (option) => group[this.groupValues].indexOf(option) === -1
        );
        this.$emit("update:modelValue", newValue);
      } else {
        let optionsToAdd = group[this.groupValues].filter(
          (option) => !(this.isOptionDisabled(option) || this.isSelected(option))
        );
        if (this.max) {
          optionsToAdd.splice(this.max - this.internalValue.length);
        }
        this.$emit("select", optionsToAdd, this.id);
        this.$emit(
          "update:modelValue",
          this.internalValue.concat(optionsToAdd)
        );
      }
      if (this.closeOnSelect)
        this.deactivate();
    },
    /**
     * Helper to identify if all values in a group are selected
     *
     * @param {Object} group to validated selected values against
     */
    wholeGroupSelected(group) {
      return group[this.groupValues].every(
        (option) => this.isSelected(option) || this.isOptionDisabled(option)
      );
    },
    /**
     * Helper to identify if all values in a group are disabled
     *
     * @param {Object} group to check for disabled values
     */
    wholeGroupDisabled(group) {
      return group[this.groupValues].every(this.isOptionDisabled);
    },
    /**
     * Removes the given option from the selected options.
     * Additionally checks this.allowEmpty prop if option can be removed when
     * it is the last selected option.
     *
     * @param  {type} option description
     * @return {type}        description
     */
    removeElement(option, shouldClose = true) {
      if (this.disabled)
        return;
      if (option.$isDisabled)
        return;
      if (!this.allowEmpty && this.internalValue.length <= 1) {
        this.deactivate();
        return;
      }
      const index = typeof option === "object" ? this.valueKeys.indexOf(option[this.trackBy]) : this.valueKeys.indexOf(option);
      if (this.multiple) {
        const newValue = this.internalValue.slice(0, index).concat(this.internalValue.slice(index + 1));
        this.$emit("update:modelValue", newValue);
      } else {
        this.$emit("update:modelValue", null);
      }
      this.$emit("remove", option, this.id);
      if (this.closeOnSelect && shouldClose)
        this.deactivate();
    },
    /**
     * Calls this.removeElement() with the last element
     * from this.internalValue (selected element Array)
     *
     * @fires this#removeElement
     */
    removeLastElement() {
      if (this.blockKeys.indexOf("Delete") !== -1)
        return;
      if (this.search.length === 0 && Array.isArray(this.internalValue) && this.internalValue.length) {
        this.removeElement(this.internalValue[this.internalValue.length - 1], false);
      }
    },
    /**
     * Opens the multiselects dropdown.
     * Sets this.isOpen to TRUE
     */
    activate() {
      if (this.isOpen || this.disabled)
        return;
      this.adjustPosition();
      if (this.groupValues && this.pointer === 0 && this.filteredOptions.length) {
        this.pointer = 1;
      }
      this.isOpen = true;
      if (this.searchable) {
        if (!this.preserveSearch)
          this.search = "";
        if (!this.preventAutofocus)
          this.$nextTick(() => this.$refs.search && this.$refs.search.focus());
      } else if (!this.preventAutofocus) {
        if (typeof this.$el !== "undefined")
          this.$el.focus();
      }
      this.$emit("open", this.id);
    },
    /**
     * Closes the multiselects dropdown.
     * Sets this.isOpen to FALSE
     */
    deactivate() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      if (this.searchable) {
        if (typeof this.$refs.search !== "undefined")
          this.$refs.search.blur();
      } else {
        if (typeof this.$el !== "undefined")
          this.$el.blur();
      }
      if (!this.preserveSearch)
        this.search = "";
      this.$emit("close", this.getValue(), this.id);
    },
    /**
     * Call this.activate() or this.deactivate()
     * depending on this.isOpen value.
     *
     * @fires this#activate || this#deactivate
     * @property {Boolean} isOpen indicates if dropdown is open
     */
    toggle() {
      this.isOpen ? this.deactivate() : this.activate();
    },
    /**
     * Updates the hasEnoughSpace variable used for
     * detecting where to expand the dropdown
     */
    adjustPosition() {
      if (typeof window === "undefined")
        return;
      const spaceAbove = this.$el.getBoundingClientRect().top;
      const spaceBelow = window.innerHeight - this.$el.getBoundingClientRect().bottom;
      const hasEnoughSpaceBelow = spaceBelow > this.maxHeight;
      if (hasEnoughSpaceBelow || spaceBelow > spaceAbove || this.openDirection === "below" || this.openDirection === "bottom") {
        this.preferredOpenDirection = "below";
        this.optimizedHeight = Math.min(spaceBelow - 40, this.maxHeight);
      } else {
        this.preferredOpenDirection = "above";
        this.optimizedHeight = Math.min(spaceAbove - 40, this.maxHeight);
      }
    }
  }
};
var pointerMixin = {
  data() {
    return {
      pointer: 0,
      pointerDirty: false
    };
  },
  props: {
    /**
     * Enable/disable highlighting of the pointed value.
     * @type {Boolean}
     * @default true
     */
    showPointer: {
      type: Boolean,
      default: true
    },
    optionHeight: {
      type: Number,
      default: 40
    }
  },
  computed: {
    pointerPosition() {
      return this.pointer * this.optionHeight;
    },
    visibleElements() {
      return this.optimizedHeight / this.optionHeight;
    }
  },
  watch: {
    filteredOptions() {
      this.pointerAdjust();
    },
    isOpen() {
      this.pointerDirty = false;
    },
    pointer() {
      this.$refs.search && this.$refs.search.setAttribute("aria-activedescendant", this.id + "-" + this.pointer.toString());
    }
  },
  methods: {
    optionHighlight(index, option) {
      return {
        "multiselect__option--highlight": index === this.pointer && this.showPointer,
        "multiselect__option--selected": this.isSelected(option)
      };
    },
    groupHighlight(index, selectedGroup) {
      if (!this.groupSelect) {
        return [
          "multiselect__option--disabled",
          { "multiselect__option--group": selectedGroup.$isLabel }
        ];
      }
      const group = this.options.find((option) => {
        return option[this.groupLabel] === selectedGroup.$groupLabel;
      });
      return group && !this.wholeGroupDisabled(group) ? [
        "multiselect__option--group",
        { "multiselect__option--highlight": index === this.pointer && this.showPointer },
        { "multiselect__option--group-selected": this.wholeGroupSelected(group) }
      ] : "multiselect__option--disabled";
    },
    addPointerElement({ key } = "Enter") {
      if (this.filteredOptions.length > 0) {
        this.select(this.filteredOptions[this.pointer], key);
      }
      this.pointerReset();
    },
    pointerForward() {
      if (this.pointer < this.filteredOptions.length - 1) {
        this.pointer++;
        if (this.$refs.list.scrollTop <= this.pointerPosition - (this.visibleElements - 1) * this.optionHeight) {
          this.$refs.list.scrollTop = this.pointerPosition - (this.visibleElements - 1) * this.optionHeight;
        }
        if (this.filteredOptions[this.pointer] && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect)
          this.pointerForward();
      }
      this.pointerDirty = true;
    },
    pointerBackward() {
      if (this.pointer > 0) {
        this.pointer--;
        if (this.$refs.list.scrollTop >= this.pointerPosition) {
          this.$refs.list.scrollTop = this.pointerPosition;
        }
        if (this.filteredOptions[this.pointer] && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect)
          this.pointerBackward();
      } else {
        if (this.filteredOptions[this.pointer] && this.filteredOptions[0].$isLabel && !this.groupSelect)
          this.pointerForward();
      }
      this.pointerDirty = true;
    },
    pointerReset() {
      if (!this.closeOnSelect)
        return;
      this.pointer = 0;
      if (this.$refs.list) {
        this.$refs.list.scrollTop = 0;
      }
    },
    pointerAdjust() {
      if (this.pointer >= this.filteredOptions.length - 1) {
        this.pointer = this.filteredOptions.length ? this.filteredOptions.length - 1 : 0;
      }
      if (this.filteredOptions.length > 0 && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect) {
        this.pointerForward();
      }
    },
    pointerSet(index) {
      this.pointer = index;
      this.pointerDirty = true;
    }
  }
};
var script$1 = {
  name: "vue-multiselect",
  mixins: [multiselectMixin, pointerMixin],
  compatConfig: {
    MODE: 3,
    ATTR_ENUMERATED_COERCION: false
  },
  props: {
    /**
       * name attribute to match optional label element
       * @default ''
       * @type {String}
       */
    name: {
      type: String,
      default: ""
    },
    /**
       * Presets the selected options value.
       * @type {Object||Array||String||Integer}
       */
    modelValue: {
      type: null,
      default() {
        return [];
      }
    },
    /**
       * String to show when pointing to an option
       * @default 'Press enter to select'
       * @type {String}
       */
    selectLabel: {
      type: String,
      default: "Press enter to select"
    },
    /**
       * String to show when pointing to an option
       * @default 'Press enter to select'
       * @type {String}
       */
    selectGroupLabel: {
      type: String,
      default: "Press enter to select group"
    },
    /**
       * String to show next to selected option
       * @default 'Selected'
       * @type {String}
       */
    selectedLabel: {
      type: String,
      default: "Selected"
    },
    /**
       * String to show when pointing to an already selected option
       * @default 'Press enter to remove'
       * @type {String}
       */
    deselectLabel: {
      type: String,
      default: "Press enter to remove"
    },
    /**
       * String to show when pointing to an already selected option
       * @default 'Press enter to remove'
       * @type {String}
       */
    deselectGroupLabel: {
      type: String,
      default: "Press enter to deselect group"
    },
    /**
       * Decide whether to show pointer labels
       * @default true
       * @type {Boolean}
       */
    showLabels: {
      type: Boolean,
      default: true
    },
    /**
       * Limit the display of selected options. The rest will be hidden within the limitText string.
       * @default 99999
       * @type {Integer}
       */
    limit: {
      type: Number,
      default: 99999
    },
    /**
       * Sets maxHeight style value of the dropdown
       * @default 300
       * @type {Integer}
       */
    maxHeight: {
      type: Number,
      default: 300
    },
    /**
       * Function that process the message shown when selected
       * elements pass the defined limit.
       * @default 'and * more'
       * @param {Int} count Number of elements more than limit
       * @type {Function}
       */
    limitText: {
      type: Function,
      default: (count) => `and ${count} more`
    },
    /**
       * Set true to trigger the loading spinner.
       * @default False
       * @type {Boolean}
       */
    loading: {
      type: Boolean,
      default: false
    },
    /**
       * Disables the multiselect if true.
       * @default false
       * @type {Boolean}
       */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
       * Fixed opening direction
       * @default ''
       * @type {String}
       */
    openDirection: {
      type: String,
      default: ""
    },
    /**
       * Shows slot with message about empty options
       * @default true
       * @type {Boolean}
       */
    showNoOptions: {
      type: Boolean,
      default: true
    },
    showNoResults: {
      type: Boolean,
      default: true
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },
  computed: {
    hasOptionGroup() {
      return this.groupValues && this.groupLabel && this.groupSelect;
    },
    isSingleLabelVisible() {
      return (this.singleValue || this.singleValue === 0) && (!this.isOpen || !this.searchable) && !this.visibleValues.length;
    },
    isPlaceholderVisible() {
      return !this.internalValue.length && (!this.searchable || !this.isOpen);
    },
    visibleValues() {
      return this.multiple ? this.internalValue.slice(0, this.limit) : [];
    },
    singleValue() {
      return this.internalValue[0];
    },
    deselectLabelText() {
      return this.showLabels ? this.deselectLabel : "";
    },
    deselectGroupLabelText() {
      return this.showLabels ? this.deselectGroupLabel : "";
    },
    selectLabelText() {
      return this.showLabels ? this.selectLabel : "";
    },
    selectGroupLabelText() {
      return this.showLabels ? this.selectGroupLabel : "";
    },
    selectedLabelText() {
      return this.showLabels ? this.selectedLabel : "";
    },
    inputStyle() {
      if (this.searchable || this.multiple && this.modelValue && this.modelValue.length) {
        return this.isOpen ? { width: "100%" } : { width: "0", position: "absolute", padding: "0" };
      }
      return "";
    },
    contentStyle() {
      return this.options.length ? { display: "inline-block" } : { display: "block" };
    },
    isAbove() {
      if (this.openDirection === "above" || this.openDirection === "top") {
        return true;
      } else if (this.openDirection === "below" || this.openDirection === "bottom") {
        return false;
      } else {
        return this.preferredOpenDirection === "above";
      }
    },
    showSearchInput() {
      return this.searchable && (this.hasSingleSelectedSlot && (this.visibleSingleValue || this.visibleSingleValue === 0) ? this.isOpen : true);
    }
  }
};
const _hoisted_1$b = {
  ref: "tags",
  class: "multiselect__tags"
};
const _hoisted_2$b = { class: "multiselect__tags-wrap" };
const _hoisted_3$b = { class: "multiselect__spinner" };
const _hoisted_4$a = { key: 0 };
const _hoisted_5$9 = { class: "multiselect__option" };
const _hoisted_6$8 = { class: "multiselect__option" };
const _hoisted_7$8 = /* @__PURE__ */ createTextVNode("No elements found. Consider changing the search query.");
const _hoisted_8$8 = { class: "multiselect__option" };
const _hoisted_9$8 = /* @__PURE__ */ createTextVNode("List is empty.");
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("div", {
    tabindex: _ctx.searchable ? -1 : $props.tabindex,
    class: [{ "multiselect--active": _ctx.isOpen, "multiselect--disabled": $props.disabled, "multiselect--above": $options.isAbove, "multiselect--has-options-group": $options.hasOptionGroup }, "multiselect"],
    onFocus: _cache[14] || (_cache[14] = ($event) => _ctx.activate()),
    onBlur: _cache[15] || (_cache[15] = ($event) => _ctx.searchable ? false : _ctx.deactivate()),
    onKeydown: [
      _cache[16] || (_cache[16] = withKeys(withModifiers(($event) => _ctx.pointerForward(), ["self", "prevent"]), ["down"])),
      _cache[17] || (_cache[17] = withKeys(withModifiers(($event) => _ctx.pointerBackward(), ["self", "prevent"]), ["up"]))
    ],
    onKeypress: _cache[18] || (_cache[18] = withKeys(withModifiers(($event) => _ctx.addPointerElement($event), ["stop", "self"]), ["enter", "tab"])),
    onKeyup: _cache[19] || (_cache[19] = withKeys(($event) => _ctx.deactivate(), ["esc"])),
    role: "combobox",
    "aria-owns": "listbox-" + _ctx.id
  }, [
    renderSlot(_ctx.$slots, "caret", { toggle: _ctx.toggle }, () => [
      createVNode(
        "div",
        {
          onMousedown: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.toggle(), ["prevent", "stop"])),
          class: "multiselect__select"
        },
        null,
        32
        /* HYDRATE_EVENTS */
      )
    ]),
    renderSlot(_ctx.$slots, "clear", { search: _ctx.search }),
    createVNode(
      "div",
      _hoisted_1$b,
      [
        renderSlot(_ctx.$slots, "selection", {
          search: _ctx.search,
          remove: _ctx.removeElement,
          values: $options.visibleValues,
          isOpen: _ctx.isOpen
        }, () => [
          withDirectives(createVNode(
            "div",
            _hoisted_2$b,
            [
              (openBlock(true), createBlock(
                Fragment,
                null,
                renderList($options.visibleValues, (option, index) => {
                  return renderSlot(_ctx.$slots, "tag", {
                    option,
                    search: _ctx.search,
                    remove: _ctx.removeElement
                  }, () => [
                    (openBlock(), createBlock("span", {
                      class: "multiselect__tag",
                      key: index
                    }, [
                      createVNode("span", {
                        textContent: toDisplayString$1(_ctx.getOptionLabel(option))
                      }, null, 8, ["textContent"]),
                      createVNode("i", {
                        tabindex: "1",
                        onKeypress: withKeys(withModifiers(($event) => _ctx.removeElement(option), ["prevent"]), ["enter"]),
                        onMousedown: withModifiers(($event) => _ctx.removeElement(option), ["prevent"]),
                        class: "multiselect__tag-icon"
                      }, null, 40, ["onKeypress", "onMousedown"])
                    ]))
                  ]);
                }),
                256
                /* UNKEYED_FRAGMENT */
              ))
            ],
            512
            /* NEED_PATCH */
          ), [
            [vShow, $options.visibleValues.length > 0]
          ]),
          _ctx.internalValue && _ctx.internalValue.length > $props.limit ? renderSlot(_ctx.$slots, "limit", { key: 0 }, () => [
            createVNode("strong", {
              class: "multiselect__strong",
              textContent: toDisplayString$1($props.limitText(_ctx.internalValue.length - $props.limit))
            }, null, 8, ["textContent"])
          ]) : createCommentVNode("v-if", true)
        ]),
        createVNode(Transition, { name: "multiselect__loading" }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "loading", {}, () => [
              withDirectives(createVNode(
                "div",
                _hoisted_3$b,
                null,
                512
                /* NEED_PATCH */
              ), [
                [vShow, $props.loading]
              ])
            ])
          ]),
          _: 3
          /* FORWARDED */
        }),
        _ctx.searchable ? (openBlock(), createBlock("input", {
          key: 0,
          ref: "search",
          name: $props.name,
          id: _ctx.id,
          type: "text",
          autocomplete: "off",
          spellcheck: "false",
          placeholder: _ctx.placeholder,
          style: $options.inputStyle,
          value: _ctx.search,
          disabled: $props.disabled,
          tabindex: $props.tabindex,
          onInput: _cache[2] || (_cache[2] = ($event) => _ctx.updateSearch($event.target.value)),
          onFocus: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.activate(), ["prevent"])),
          onBlur: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.deactivate(), ["prevent"])),
          onKeyup: _cache[5] || (_cache[5] = withKeys(($event) => _ctx.deactivate(), ["esc"])),
          onKeydown: [
            _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => _ctx.pointerForward(), ["prevent"]), ["down"])),
            _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => _ctx.pointerBackward(), ["prevent"]), ["up"])),
            _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => _ctx.removeLastElement(), ["stop"]), ["delete"]))
          ],
          onKeypress: _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => _ctx.addPointerElement($event), ["prevent", "stop", "self"]), ["enter"])),
          class: "multiselect__input",
          "aria-controls": "listbox-" + _ctx.id
        }, null, 44, ["name", "id", "placeholder", "value", "disabled", "tabindex", "aria-controls"])) : createCommentVNode("v-if", true),
        $options.isSingleLabelVisible ? (openBlock(), createBlock(
          "span",
          {
            key: 1,
            class: "multiselect__single",
            onMousedown: _cache[10] || (_cache[10] = withModifiers((...args) => _ctx.toggle && _ctx.toggle(...args), ["prevent"]))
          },
          [
            renderSlot(_ctx.$slots, "singleLabel", { option: $options.singleValue }, () => [
              createTextVNode(
                toDisplayString$1(_ctx.currentOptionLabel),
                1
                /* TEXT */
              )
            ])
          ],
          32
          /* HYDRATE_EVENTS */
        )) : createCommentVNode("v-if", true),
        $options.isPlaceholderVisible ? (openBlock(), createBlock(
          "span",
          {
            key: 2,
            class: "multiselect__placeholder",
            onMousedown: _cache[11] || (_cache[11] = withModifiers((...args) => _ctx.toggle && _ctx.toggle(...args), ["prevent"]))
          },
          [
            renderSlot(_ctx.$slots, "placeholder", {}, () => [
              createTextVNode(
                toDisplayString$1(_ctx.placeholder),
                1
                /* TEXT */
              )
            ])
          ],
          32
          /* HYDRATE_EVENTS */
        )) : createCommentVNode("v-if", true)
      ],
      512
      /* NEED_PATCH */
    ),
    createVNode(Transition, { name: "multiselect" }, {
      default: withCtx(() => [
        withDirectives(createVNode(
          "div",
          {
            class: "multiselect__content-wrapper",
            onFocus: _cache[12] || (_cache[12] = (...args) => _ctx.activate && _ctx.activate(...args)),
            tabindex: "-1",
            onMousedown: _cache[13] || (_cache[13] = withModifiers(() => {
            }, ["prevent"])),
            style: { maxHeight: _ctx.optimizedHeight + "px" },
            ref: "list"
          },
          [
            createVNode("ul", {
              class: "multiselect__content",
              style: $options.contentStyle,
              role: "listbox",
              id: "listbox-" + _ctx.id
            }, [
              renderSlot(_ctx.$slots, "beforeList"),
              _ctx.multiple && _ctx.max === _ctx.internalValue.length ? (openBlock(), createBlock("li", _hoisted_4$a, [
                createVNode("span", _hoisted_5$9, [
                  renderSlot(_ctx.$slots, "maxElements", {}, () => [
                    createTextVNode(
                      "Maximum of " + toDisplayString$1(_ctx.max) + " options selected. First remove a selected option to select another.",
                      1
                      /* TEXT */
                    )
                  ])
                ])
              ])) : createCommentVNode("v-if", true),
              !_ctx.max || _ctx.internalValue.length < _ctx.max ? (openBlock(true), createBlock(
                Fragment,
                { key: 1 },
                renderList(_ctx.filteredOptions, (option, index) => {
                  return openBlock(), createBlock("li", {
                    class: "multiselect__element",
                    key: index,
                    id: _ctx.id + "-" + index,
                    role: !(option && (option.$isLabel || option.$isDisabled)) ? "option" : null
                  }, [
                    !(option && (option.$isLabel || option.$isDisabled)) ? (openBlock(), createBlock("span", {
                      key: 0,
                      class: [_ctx.optionHighlight(index, option), "multiselect__option"],
                      onClick: withModifiers(($event) => _ctx.select(option), ["stop"]),
                      onMouseenter: withModifiers(($event) => _ctx.pointerSet(index), ["self"]),
                      "data-select": option && option.isTag ? _ctx.tagPlaceholder : $options.selectLabelText,
                      "data-selected": $options.selectedLabelText,
                      "data-deselect": $options.deselectLabelText
                    }, [
                      renderSlot(_ctx.$slots, "option", {
                        option,
                        search: _ctx.search,
                        index
                      }, () => [
                        createVNode(
                          "span",
                          null,
                          toDisplayString$1(_ctx.getOptionLabel(option)),
                          1
                          /* TEXT */
                        )
                      ])
                    ], 42, ["onClick", "onMouseenter", "data-select", "data-selected", "data-deselect"])) : createCommentVNode("v-if", true),
                    option && (option.$isLabel || option.$isDisabled) ? (openBlock(), createBlock("span", {
                      key: 1,
                      "data-select": _ctx.groupSelect && $options.selectGroupLabelText,
                      "data-deselect": _ctx.groupSelect && $options.deselectGroupLabelText,
                      class: [_ctx.groupHighlight(index, option), "multiselect__option"],
                      onMouseenter: withModifiers(($event) => _ctx.groupSelect && _ctx.pointerSet(index), ["self"]),
                      onMousedown: withModifiers(($event) => _ctx.selectGroup(option), ["prevent"])
                    }, [
                      renderSlot(_ctx.$slots, "option", {
                        option,
                        search: _ctx.search,
                        index
                      }, () => [
                        createVNode(
                          "span",
                          null,
                          toDisplayString$1(_ctx.getOptionLabel(option)),
                          1
                          /* TEXT */
                        )
                      ])
                    ], 42, ["data-select", "data-deselect", "onMouseenter", "onMousedown"])) : createCommentVNode("v-if", true)
                  ], 8, ["id", "role"]);
                }),
                128
                /* KEYED_FRAGMENT */
              )) : createCommentVNode("v-if", true),
              withDirectives(createVNode(
                "li",
                null,
                [
                  createVNode("span", _hoisted_6$8, [
                    renderSlot(_ctx.$slots, "noResult", { search: _ctx.search }, () => [
                      _hoisted_7$8
                    ])
                  ])
                ],
                512
                /* NEED_PATCH */
              ), [
                [vShow, $props.showNoResults && (_ctx.filteredOptions.length === 0 && _ctx.search && !$props.loading)]
              ]),
              withDirectives(createVNode(
                "li",
                null,
                [
                  createVNode("span", _hoisted_8$8, [
                    renderSlot(_ctx.$slots, "noOptions", {}, () => [
                      _hoisted_9$8
                    ])
                  ])
                ],
                512
                /* NEED_PATCH */
              ), [
                [vShow, $props.showNoOptions && ((_ctx.options.length === 0 || $options.hasOptionGroup === true && _ctx.filteredOptions.length === 0) && !_ctx.search && !$props.loading)]
              ]),
              renderSlot(_ctx.$slots, "afterList")
            ], 12, ["id"])
          ],
          36
          /* STYLE, HYDRATE_EVENTS */
        ), [
          [vShow, _ctx.isOpen]
        ])
      ]),
      _: 3
      /* FORWARDED */
    })
  ], 42, ["tabindex", "aria-owns"]);
}
script$1.render = render$1;
const p$1 = {
  show: "Show",
  entries: "entries",
  previous: "Previous",
  next: "Next",
  showing: "Showing",
  showingTo: "to",
  showingOf: "of",
  showingEntries: "entries"
}, V = "...";
function z(t, n, s) {
  let e;
  return function() {
    const r = this, o = arguments;
    clearTimeout(e), s && !e && t.apply(r, o), e = setTimeout(function() {
      e = null, s || t.apply(r, o);
    }, n);
  };
}
function O(t) {
  for (const n in t)
    return false;
  return true;
}
function G(t, n) {
  const e = [], r = [];
  let o;
  if (e.push(1), t <= 1)
    return e;
  for (let a = n - 2; a <= n + 2; a++)
    a < t && a > 1 && e.push(a);
  e.push(t);
  for (let a = 0; a < e.length; a++)
    o && (e[a] - o === 2 ? r.push(o + 1) : e[a] - o !== 1 && r.push(V)), r.push(e[a]), o = e[a];
  return r;
}
function W(t, n = {}) {
  const s = [];
  let e;
  const r = t.length;
  return t = t.map(function(o, a) {
    return o[0] === "-" ? (s[a] = -1, o = o.substring(1)) : s[a] = 1, o;
  }), function(o, a) {
    for (e = 0; e < r; e++) {
      const d2 = t[e], b = n[d2] ? n[d2](o.value[d2]) : o.value[d2], m2 = n[d2] ? n[d2](a.value[d2]) : a.value[d2];
      if (b > m2)
        return s[e];
      if (b < m2)
        return -s[e];
    }
    return 0;
  };
}
function q(t, n) {
  for (const s in n)
    t = t.filter(function(e) {
      const r = e.value;
      for (const o in r)
        if (o === s) {
          if (typeof n[s] == "function")
            return n[s](r[o], r);
          if (n[s] === "" || r[o] === n[s])
            return true;
        }
      return false;
    });
  return t;
}
function H(t, n, s, e) {
  e = String(e).toLowerCase();
  for (const r in s)
    if (t.length === 0 || t.indexOf(r) !== -1) {
      const o = String(s[r]).toLowerCase();
      for (const a in n)
        if (a === r && typeof n[a] == "function") {
          const d2 = n[a](o, e, s);
          if (d2 === true)
            return d2;
        }
      if (o.indexOf(e) >= 0)
        return true;
    }
  return false;
}
const y = (t, n) => {
  const s = t.__vccOpts || t;
  for (const [e, r] of n)
    s[e] = r;
  return s;
}, J = {
  props: {
    dsData: {
      type: Array,
      default: () => []
    },
    dsFilterFields: {
      type: Object,
      default: () => ({})
    },
    dsSortby: {
      type: Array,
      default: () => []
    },
    dsSearchIn: {
      type: Array,
      default: () => []
    },
    dsSearchAs: {
      type: Object,
      default: () => ({})
    },
    dsSortAs: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:dsData"],
  /**
   * @param {{
   *   dsData: Record<string, any>[];
   *   dsFilterFields: { [fieldId in string]: (columnValue: any) => boolean | any };
   *   dsSortby: string[];
   *   dsSearchIn: string[];
   *   dsSearchAs: { [id in string]: (columnValue: any, searchString: string) => boolean };
   *   dsSortAs: { [id in string]: (columnValue: any) => any };
   * }} props
   */
  setup(t, { emit: n }) {
    const s = ref(1), e = ref(""), r = ref(10), o = ref(p$1), a = ref([]), d2 = (l) => {
      e.value = l;
    }, b = async (l) => {
      r.value = l, await nextTick(), s.value > S.value && m2(P.value[P.value.length - 1]);
    }, m2 = (l) => {
      s.value = l;
    }, T = computed(() => a.value.slice(I.value, D.value)), P = computed(() => G(S.value, s.value)), x = computed(() => a.value.length), S = computed(() => Math.ceil(x.value / r.value)), I = computed(() => (s.value - 1) * r.value), D = computed(() => s.value * r.value);
    return watch(x, (l, g) => {
      m2(1);
    }), watch(
      () => [t.dsData, e, t.dsSortby, t.dsFilterFields, t.dsSearchIn, t.dsSearchAs, t.dsSortAs],
      () => {
        let l = [];
        !e.value && !t.dsSortby.length && O(t.dsFilterFields) ? l = t.dsData.map((g, E) => E) : (l = t.dsData.map((g, E) => ({ index: E, value: g })), O(t.dsFilterFields) || (l = q(l, t.dsFilterFields)), e.value && (l = l.filter((g) => H(t.dsSearchIn, t.dsSearchAs, g.value, e.value))), t.dsSortby.length && l.sort(W(t.dsSortby, t.dsSortAs)), l = l.map((g) => g.index)), a.value = l, n(
          "update:dsData",
          l.map((g) => t.dsData[g])
        );
      },
      {
        immediate: true,
        deep: true
      }
    ), provide("dsIndexes", a), provide("search", d2), provide("showEntries", b), provide("setActive", m2), provide("datasetI18n", o), provide(
      "dsData",
      computed(() => t.dsData)
    ), provide("dsRows", T), provide("dsPages", P), provide("dsResultsNumber", x), provide("dsPagecount", S), provide("dsFrom", I), provide("dsTo", D), provide("dsPage", s), {
      dsIndexes: a,
      dsShowEntries: r,
      dsResultsNumber: x,
      dsPage: s,
      dsPagecount: S,
      dsFrom: I,
      dsTo: D,
      dsRows: T,
      dsPages: P,
      search: d2,
      showEntries: b,
      setActive: m2
    };
  }
};
function Q(t, n, s, e, r, o) {
  return renderSlot(t.$slots, "default", {
    ds: {
      dsIndexes: e.dsIndexes,
      dsShowEntries: e.dsShowEntries,
      dsResultsNumber: e.dsResultsNumber,
      dsPage: e.dsPage,
      dsPagecount: e.dsPagecount,
      dsFrom: e.dsFrom,
      dsTo: e.dsTo,
      dsData: s.dsData,
      dsRows: e.dsRows,
      dsPages: e.dsPages,
      search: e.search,
      showEntries: e.showEntries,
      setActive: e.setActive
    }
  });
}
const ge = /* @__PURE__ */ y(J, [["render", Q]]), U = {
  setup() {
    const t = inject("dsResultsNumber"), n = inject("dsFrom"), s = inject("dsTo"), e = computed(() => t.value !== 0 ? n.value + 1 : 0), r = computed(() => s.value >= t.value ? t.value : s.value);
    return {
      datasetI18n: inject("datasetI18n"),
      dsResultsNumber: t,
      showing: e,
      showingTo: r
    };
  }
};
function X$1(t, n, s, e, r, o) {
  return openBlock(), createElementBlock("div", null, toDisplayString$1(e.datasetI18n.showing) + " " + toDisplayString$1(e.showing) + " " + toDisplayString$1(e.datasetI18n.showingTo) + " " + toDisplayString$1(e.showingTo) + " " + toDisplayString$1(e.datasetI18n.showingOf) + " " + toDisplayString$1(e.dsResultsNumber) + " " + toDisplayString$1(e.datasetI18n.showingEntries), 1);
}
const me = /* @__PURE__ */ y(U, [["render", X$1]]), Y = {
  props: {
    tag: {
      type: String,
      default: "div"
    }
  },
  setup() {
    const t = computed(() => {
      const n = [];
      for (let s = inject("dsFrom").value; s < inject("dsTo").value; s++)
        n.push(s);
      return n;
    });
    return {
      dsData: inject("dsData"),
      dsRows: inject("dsRows"),
      indexes: t
    };
  }
};
function Z(t, n, s, e, r, o) {
  return openBlock(), createBlock(resolveDynamicComponent(s.tag), null, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e.dsRows, (a, d2) => renderSlot(t.$slots, "default", {
        row: e.dsData[a],
        rowIndex: a,
        index: e.indexes[d2]
      })), 256)),
      e.dsRows.length ? createCommentVNode("", true) : renderSlot(t.$slots, "noDataFound", { key: 0 })
    ]),
    _: 3
  });
}
const _e = /* @__PURE__ */ y(Y, [["render", Z]]);
const oe = {
  props: {
    dsSearchPlaceholder: {
      type: String,
      default: ""
    },
    wait: {
      type: Number,
      default: 0
    }
  },
  setup(t) {
    const n = inject("search"), s = ref(""), e = z((r) => {
      n(r);
    }, t.wait);
    return {
      dsSearch: s,
      input: e
    };
  }
}, de$1 = ["placeholder", "value"];
function le(t, n, s, e, r, o) {
  return openBlock(), createElementBlock("input", {
    type: "text",
    placeholder: s.dsSearchPlaceholder,
    class: "form-control",
    value: e.dsSearch,
    onInput: n[0] || (n[0] = (a) => e.input(a.target.value))
  }, null, 40, de$1);
}
const be = /* @__PURE__ */ y(oe, [["render", le]]), ie$1 = {
  props: {
    dsShowEntries: {
      type: Number,
      default: 10
    },
    dsShowEntriesLovs: {
      type: Array,
      default: () => [
        { value: 5, text: 5 },
        { value: 10, text: 10 },
        { value: 25, text: 25 },
        { value: 50, text: 50 },
        { value: 100, text: 100 }
      ]
    }
  },
  emits: ["changed"],
  setup(t, { emit: n }) {
    const s = inject("showEntries"), e = (r) => {
      n("changed", Number(r.target.value)), s(Number(r.target.value));
    };
    return s(Number(t.dsShowEntries)), {
      datasetI18n: inject("datasetI18n"),
      change: e
    };
  }
}, ce = { class: "form-inline" }, ue = ["value"], fe$1 = ["value"];
function ve(t, n, s, e, r, o) {
  return openBlock(), createElementBlock("div", ce, [
    createBaseVNode("label", null, toDisplayString$1(e.datasetI18n.show), 1),
    createBaseVNode("select", {
      value: s.dsShowEntries,
      class: "form-control mr-1 ml-1",
      onChange: n[0] || (n[0] = (...a) => e.change && e.change(...a))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(s.dsShowEntriesLovs, (a) => (openBlock(), createElementBlock("option", {
        key: a.value,
        value: a.value
      }, toDisplayString$1(a.text), 9, fe$1))), 128))
    ], 40, ue),
    createBaseVNode("label", null, toDisplayString$1(e.datasetI18n.entries), 1)
  ]);
}
const ye = /* @__PURE__ */ y(ie$1, [["render", ve]]);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var vClickOutside_umd = createCommonjsModule(function(module, exports) {
  !function(e, n) {
    module.exports = n();
  }(commonjsGlobal, function() {
    var e = "__v-click-outside", n = "undefined" != typeof window, t = "undefined" != typeof navigator, r = n && ("ontouchstart" in window || t && navigator.msMaxTouchPoints > 0) ? ["touchstart"] : ["click"], i = function(e2) {
      var n2 = e2.event, t2 = e2.handler;
      (0, e2.middleware)(n2) && t2(n2);
    }, a = function(n2, t2) {
      var a2 = function(e2) {
        var n3 = "function" == typeof e2;
        if (!n3 && "object" != typeof e2) {
          throw new Error("v-click-outside: Binding value must be a function or an object");
        }
        return { handler: n3 ? e2 : e2.handler, middleware: e2.middleware || function(e3) {
          return e3;
        }, events: e2.events || r, isActive: !(false === e2.isActive), detectIframe: !(false === e2.detectIframe), capture: Boolean(e2.capture) };
      }(t2.value), o2 = a2.handler, d3 = a2.middleware, c2 = a2.detectIframe, u2 = a2.capture;
      if (a2.isActive) {
        if (n2[e] = a2.events.map(function(e2) {
          return { event: e2, srcTarget: document.documentElement, handler: function(e3) {
            return function(e4) {
              var n3 = e4.el, t3 = e4.event, r2 = e4.handler, a3 = e4.middleware, o3 = t3.path || t3.composedPath && t3.composedPath();
              (o3 ? o3.indexOf(n3) < 0 : !n3.contains(t3.target)) && i({ event: t3, handler: r2, middleware: a3 });
            }({ el: n2, event: e3, handler: o2, middleware: d3 });
          }, capture: u2 };
        }), c2) {
          var l = { event: "blur", srcTarget: window, handler: function(e2) {
            return function(e3) {
              var n3 = e3.el, t3 = e3.event, r2 = e3.handler, a3 = e3.middleware;
              setTimeout(function() {
                var e4 = document.activeElement;
                e4 && "IFRAME" === e4.tagName && !n3.contains(e4) && i({ event: t3, handler: r2, middleware: a3 });
              }, 0);
            }({ el: n2, event: e2, handler: o2, middleware: d3 });
          }, capture: u2 };
          n2[e] = [].concat(n2[e], [l]);
        }
        n2[e].forEach(function(t3) {
          var r2 = t3.event, i2 = t3.srcTarget, a3 = t3.handler;
          return setTimeout(function() {
            n2[e] && i2.addEventListener(r2, a3, u2);
          }, 0);
        });
      }
    }, o = function(n2) {
      (n2[e] || []).forEach(function(e2) {
        return e2.srcTarget.removeEventListener(e2.event, e2.handler, e2.capture);
      }), delete n2[e];
    }, d2 = n ? { beforeMount: a, updated: function(e2, n2) {
      var t2 = n2.value, r2 = n2.oldValue;
      JSON.stringify(t2) !== JSON.stringify(r2) && (o(e2), a(e2, { value: t2 }));
    }, unmounted: o } : {};
    return { install: function(e2) {
      e2.directive("click-outside", d2);
    }, directive: d2 };
  });
});
var script = {
  name: "VueSimpleContextMenu",
  props: {
    elementId: {
      type: String,
      required: true
    },
    options: {
      type: Array,
      required: true
    }
  },
  emits: ["menu-closed", "option-clicked"],
  directives: {
    "click-outside": vClickOutside_umd.directive
  },
  data: function data() {
    return {
      item: null,
      menuHeight: null,
      menuWidth: null
    };
  },
  methods: {
    showMenu: function showMenu(event, item) {
      this.item = item;
      var menu = document.getElementById(this.elementId);
      if (!menu) {
        return;
      }
      if (!this.menuWidth || !this.menuHeight) {
        menu.style.visibility = "hidden";
        menu.style.display = "block";
        this.menuWidth = menu.offsetWidth;
        this.menuHeight = menu.offsetHeight;
        menu.removeAttribute("style");
      }
      if (this.menuWidth + event.pageX >= window.innerWidth) {
        menu.style.left = event.pageX - this.menuWidth + 2 + "px";
      } else {
        menu.style.left = event.pageX - 2 + "px";
      }
      if (this.menuHeight + event.pageY >= window.innerHeight) {
        menu.style.top = event.pageY - this.menuHeight + 2 + "px";
      } else {
        menu.style.top = event.pageY - 2 + "px";
      }
      menu.classList.add("vue-simple-context-menu--active");
    },
    hideContextMenu: function hideContextMenu() {
      var element2 = document.getElementById(this.elementId);
      if (element2) {
        element2.classList.remove("vue-simple-context-menu--active");
        this.$emit("menu-closed");
      }
    },
    onClickOutside: function onClickOutside() {
      this.hideContextMenu();
    },
    optionClicked: function optionClicked(option) {
      this.hideContextMenu();
      this.$emit("option-clicked", {
        item: this.item,
        option
      });
    },
    onEscKeyRelease: function onEscKeyRelease(event) {
      if (event.keyCode === 27) {
        this.hideContextMenu();
      }
    }
  },
  mounted: function mounted() {
    document.body.addEventListener("keyup", this.onEscKeyRelease);
  },
  beforeUnmount: function beforeUnmount() {
    document.removeEventListener("keyup", this.onEscKeyRelease);
  }
};
var _hoisted_1$a = ["id"];
var _hoisted_2$a = ["onClick"];
var _hoisted_3$a = ["innerHTML"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createElementBlock("div", null, [
    withDirectives((openBlock(), createElementBlock("ul", {
      id: $props.elementId,
      class: "vue-simple-context-menu"
    }, [
      (openBlock(true), createElementBlock(
        Fragment,
        null,
        renderList($props.options, function(option, index) {
          return openBlock(), createElementBlock("li", {
            key: index,
            onClick: withModifiers(function($event) {
              return $options.optionClicked(option);
            }, ["stop"]),
            class: normalizeClass(["vue-simple-context-menu__item", [option.class, option.type === "divider" ? "vue-simple-context-menu__divider" : ""]])
          }, [
            createBaseVNode("span", {
              innerHTML: option.name
            }, null, 8, _hoisted_3$a)
          ], 10, _hoisted_2$a);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ], 8, _hoisted_1$a)), [
      [_directive_click_outside, $options.onClickOutside]
    ])
  ]);
}
script.render = render;
script.__file = "src/vue-simple-context-menu.vue";
function install$1(app2) {
  if (install$1.installed) {
    return;
  }
  install$1.installed = true;
  app2.component("VueSimpleContextMenu", script);
}
var plugin$1 = { install: install$1 };
var GlobalVue = null;
if (typeof window !== "undefined") {
  GlobalVue = window.Vue;
} else if (typeof global !== "undefined") {
  GlobalVue = global.Vue;
}
if (GlobalVue) {
  GlobalVue.use(plugin$1);
}
const VueSimpleContextMenu = script;
const AdminTabCharacters_vue_vue_type_style_index_0_lang = "";
const _sfc_main$b = {
  components: {
    VueMultiselect: script$1,
    Dataset: ge,
    DatasetItem: _e,
    DatasetSearch: be,
    DatasetInfo: me,
    DatasetShow: ye,
    VueSimpleContextMenu
  },
  setup() {
    const card_centered = ref(null);
    return {
      card_centered
    };
  },
  data() {
    const store = usePlayerStore();
    return {
      store,
      tag_filter: [],
      search_character: "",
      filters: {},
      options_contextual: [{}]
    };
  },
  mounted() {
    this.$refs["dataset"].showEntries(1e4);
  },
  methods: {
    getClasses(character) {
      let classes = [];
      if (character.challenge !== void 0 && character.challenge.date === this.store.last_challenge.date) {
        classes.push("result-" + character.challenge.result);
      } else {
        classes.push("result-neutral");
      }
      if (character.connection !== null && this.store.connections[character.connection] !== void 0 && this.store.connections[character.connection].open === true) {
        classes.push("connected");
      }
      if (character.picked) {
        classes.push("picked");
      }
      return classes;
    },
    filterOnTag(tags) {
      let found = true;
      if (this.tag_filter.length) {
        found = tags.find(
          (tag) => this.tag_filter.find(
            (chosen_tag) => chosen_tag.label === tag.label
          )
        );
      }
      return found !== void 0;
    },
    filterConnected(connection) {
      if (this.filters["connected"] !== void 0) {
        return connection !== null && this.store.connections[connection] !== void 0 && this.store.connections[connection].open === true;
      }
      return true;
    },
    filterPicked(picked) {
      if (this.filters["picked"] !== void 0) {
        return picked;
      }
      return true;
    },
    filterDead(dead) {
      if (this.filters["dead"] !== void 0) {
        return dead;
      }
      return true;
    },
    filterChallenge(challenge) {
      if (this.filters["challenge"] !== void 0) {
        if (challenge.date === void 0) {
          return false;
        } else if (challenge.date === this.store.last_challenge.date) {
          return challenge.result === this.filters["challenge"];
        }
      }
      return true;
    },
    switchFilter(name) {
      if (this.filters[name] === void 0) {
        this.filters[name] = true;
      } else {
        delete this.filters[name];
      }
    },
    switchFilterChallenge(value) {
      if (this.filters["challenge"] === void 0 || this.filters["challenge"] !== value) {
        this.filters["challenge"] = value;
      } else {
        delete this.filters["challenge"];
      }
    },
    resetFilters() {
      this.filters = {};
      this.tag_filter = [];
      this.search_character = "";
    },
    sortAsChallenge(challenge) {
      return challenge !== void 0 && challenge.date === this.store.last_challenge.date;
    },
    sortAsConnected(connection) {
      return connection !== null && this.store.connections[connection] !== void 0 && this.store.connections[connection].open === true;
    },
    handleClick(event, item) {
      this.options_contextual = this.generateOptions(item);
      this.$refs.context_character.showMenu(event, item);
    },
    generateOptions(item) {
      let options = [];
      if (item.picked === void 0 || !item.picked) {
        options.push({ name: this.$t("context_add_selection_character"), effect: "toggle" });
      } else {
        options.push({ name: this.$t("context_remove_selection_character"), effect: "toggle" });
      }
      options.push({ name: this.$t("context_edit_character"), effect: "edit" });
      options.push({ name: this.$t("context_delete_character"), effect: "delete" });
      return options;
    },
    optionClicked(event) {
      if (event.option.effect !== void 0) {
        let character = event.item;
        switch (event.option.effect) {
          case "rename":
            break;
          case "delete":
            let foundIndex = this.store.characters.findIndex((found_character) => found_character.token === character.token);
            this.store.characters.splice(foundIndex, 1);
            break;
          case "edit":
            break;
          case "toggle":
            this.toggleCharacter(character);
            break;
        }
      }
    },
    toggleCharacter(character) {
      let found = this.store.characters.find((found_character) => found_character.token === character.token);
      found.picked = !found.picked;
    },
    selectVisible(ds) {
      ds.dsRows.forEach((row) => ds.dsData[row].picked = true);
    },
    animateToCenter(id) {
      let expand = false;
      if (this.card_centered !== this.$refs[id]) {
        expand = true;
      }
      if (this.card_centered !== null) {
        this.card_centered.style.transform = null;
        this.card_centered.classList.remove("centered");
        this.card_centered = null;
      }
      if (expand) {
        this.card_centered = this.$refs[id];
        var rect = this.$refs[id].getBoundingClientRect();
        let scale = 2;
        if (window.screen.availHeight > 1e3) {
          scale = 3;
        }
        let diffX = window.innerWidth / 2 - rect.left - this.$refs[id].offsetWidth * scale / 2;
        let diffY = window.innerHeight / 2 - rect.top - this.$refs[id].offsetHeight * scale / 2;
        this.$refs[id].style.transform = "translate(" + diffX + "px ," + diffY + "px) scale3D(" + scale + "," + scale + "," + scale + ")";
        this.$refs[id].classList.add("centered");
      }
    }
  }
};
const _hoisted_1$9 = { id: "tab-characters-content" };
const _hoisted_2$9 = {
  key: 0,
  class: "full"
};
const _hoisted_3$9 = { class: "filter-data" };
const _hoisted_4$9 = { key: 0 };
const _hoisted_5$8 = {
  key: 2,
  class: "dual-button"
};
const _hoisted_6$7 = ["onClick"];
const _hoisted_7$7 = { class: "wrapper-label" };
const _hoisted_8$7 = { class: "summary full" };
const _hoisted_9$7 = ["onClick", "onContextmenu"];
const _hoisted_10$7 = { class: "character-names" };
const _hoisted_11$7 = { class: "character-name" };
const _hoisted_12$7 = { class: "pseudo" };
const _hoisted_13$7 = { class: "gauges" };
const _hoisted_14$6 = { class: "stats" };
const _hoisted_15$6 = {
  key: 0,
  class: "tags"
};
const _hoisted_16$6 = { class: "label-name" };
const _hoisted_17$6 = {
  key: 0,
  class: "no-found"
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VueSimpleContextMenu = resolveComponent("VueSimpleContextMenu");
  const _component_vue_multiselect = resolveComponent("vue-multiselect");
  const _component_dataset_search = resolveComponent("dataset-search");
  const _component_dataset_item = resolveComponent("dataset-item");
  const _component_dataset = resolveComponent("dataset");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_VueSimpleContextMenu, {
      "element-id": "context_menu_characters",
      options: $data.options_contextual,
      ref: "context_character",
      onOptionClicked: $options.optionClicked
    }, null, 8, ["options", "onOptionClicked"]),
    createBaseVNode("div", {
      style: normalizeStyle(_ctx.cssVars),
      class: "tab",
      ref: "tab"
    }, [
      createBaseVNode("div", _hoisted_1$9, [
        this.store.last_challenge.date !== 0 ? (openBlock(), createElementBlock("div", _hoisted_2$9, [
          createBaseVNode("span", null, [
            createTextVNode(toDisplayString$1(_ctx.$t("last_challenge_success_rate")) + " ", 1),
            createBaseVNode("span", {
              class: normalizeClass(["result-challenge", $data.store.last_challenge.rate <= 50 ? $data.store.last_challenge.rate < 50 ? "failure" : "" : "success"])
            }, toDisplayString$1($data.store.last_challenge.rate) + "%", 3)
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$9, [
          $data.store.tags.length ? (openBlock(), createElementBlock("div", _hoisted_4$9, [
            createVNode(_component_vue_multiselect, {
              ref: "tag_filter",
              id: "tag_filter",
              modelValue: $data.tag_filter,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.tag_filter = $event),
              label: "label",
              "track-by": "code",
              "group-values": "tags",
              "group-label": "label",
              "group-select": true,
              placeholder: _ctx.$t("select_tag"),
              tagPlaceholder: _ctx.$t("select_tag"),
              noOptions: _ctx.$t("everyone"),
              options: $data.store.tag_groups,
              multiple: true,
              taggable: false,
              hideSelected: true
            }, null, 8, ["modelValue", "placeholder", "tagPlaceholder", "noOptions", "options"])
          ])) : createCommentVNode("", true),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = ($event) => $options.switchFilter("dead")),
            class: normalizeClass({ active: $data.filters.dead !== void 0 })
          }, toDisplayString$1(_ctx.$t("alive")), 3),
          createBaseVNode("button", {
            onClick: _cache[2] || (_cache[2] = ($event) => $options.switchFilter("connected")),
            class: normalizeClass({ active: $data.filters.connected !== void 0 })
          }, toDisplayString$1(_ctx.$t("connected")), 3),
          $data.store.picked_characters !== void 0 && $data.store.picked_characters.length ? (openBlock(), createElementBlock("button", {
            key: 1,
            onClick: _cache[3] || (_cache[3] = ($event) => $options.switchFilter("picked")),
            class: normalizeClass({ active: $data.filters.picked !== void 0 })
          }, toDisplayString$1(_ctx.$t("char_picked")), 3)) : createCommentVNode("", true),
          $data.store.last_challenge.date !== 0 ? (openBlock(), createElementBlock("div", _hoisted_5$8, [
            createBaseVNode("button", {
              onClick: _cache[4] || (_cache[4] = ($event) => $options.switchFilterChallenge("success")),
              class: normalizeClass(["success-button badge", { active: $data.filters.challenge !== void 0 && $data.filters.challenge === "success" }])
            }, [
              createTextVNode(toDisplayString$1(_ctx.$t("passed")), 1),
              createBaseVNode("span", null, toDisplayString$1($data.store.last_challenge.nb_success), 1)
            ], 2),
            createBaseVNode("button", {
              onClick: _cache[5] || (_cache[5] = ($event) => $options.switchFilterChallenge("failure")),
              class: normalizeClass(["failure-button badge", { active: $data.filters.challenge !== void 0 && $data.filters.challenge === "failure" }])
            }, [
              createTextVNode(toDisplayString$1(_ctx.$t("failed")), 1),
              createBaseVNode("span", null, toDisplayString$1($data.store.last_challenge.nb_failure), 1)
            ], 2)
          ])) : createCommentVNode("", true),
          Object.keys($data.filters).length || $data.tag_filter.length ? (openBlock(), createElementBlock("button", {
            key: 3,
            class: "reset-filters",
            onClick: _cache[6] || (_cache[6] = (...args) => $options.resetFilters && $options.resetFilters(...args))
          }, toDisplayString$1(_ctx.$t("show_all_characters")), 1)) : createCommentVNode("", true),
          $data.store.picked_characters !== void 0 && $data.store.picked_characters.length ? (openBlock(), createElementBlock("button", {
            key: 4,
            class: "btn-valid clear-selection",
            onClick: _cache[7] || (_cache[7] = ($event) => this.store.resetPickedCharacters())
          }, toDisplayString$1(_ctx.$t("clear_selection")), 1)) : createCommentVNode("", true)
        ]),
        createVNode(_component_dataset, {
          "ds-data": $data.store.characters,
          "ds-sortby": ["-alive", "-challenge", "-connection", "name"],
          "ds-search-in": ["name"],
          "ds-filter-fields": { tags: $options.filterOnTag, connection: $options.filterConnected, alive: $options.filterDead, challenge: $options.filterChallenge, picked: $options.filterPicked },
          "ds-sort-as": { challenge: $options.sortAsChallenge, connection: $options.sortAsConnected },
          ref: "dataset"
        }, {
          default: withCtx(({ ds }) => [
            createBaseVNode("button", {
              onClick: ($event) => this.selectVisible(ds)
            }, toDisplayString$1(_ctx.$t("add_all_to_selection")), 9, _hoisted_6$7),
            createBaseVNode("button", {
              ref: "step_characters_1",
              onClick: _cache[8] || (_cache[8] = ($event) => $data.store.generateCharacters(1))
            }, toDisplayString$1(_ctx.$t("spawn_npc")), 513),
            createBaseVNode("div", _hoisted_7$7, [
              createVNode(_component_dataset_search, {
                placeholder: _ctx.$t("search_character"),
                modelValue: $data.search_character,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.search_character = $event),
                id: "search-character",
                "ds-search-placeholder": _ctx.$t("start_typing")
              }, null, 8, ["placeholder", "modelValue", "ds-search-placeholder"])
            ]),
            createBaseVNode("div", _hoisted_8$7, toDisplayString$1(_ctx.$t("count_personnage", { count: ds.dsResultsNumber })) + toDisplayString$1(_ctx.$t("characters_on")) + toDisplayString$1($data.store.characters.length), 1),
            createVNode(_component_dataset_item, {
              class: "full",
              id: "character-list"
            }, {
              default: withCtx(({ row, rowIndex }) => [
                (openBlock(), createElementBlock("div", {
                  onClick: [
                    withModifiers(($event) => $options.animateToCenter(row.token), ["exact"]),
                    withModifiers(($event) => $options.toggleCharacter(row), ["shift", "exact"])
                  ],
                  ref: row.token,
                  key: row.token,
                  onContextmenu: withModifiers(($event) => $options.handleClick($event, row), ["prevent", "stop"]),
                  class: normalizeClass(["character", [$options.getClasses(row), !row.alive ? "dead" : ""]])
                }, [
                  createBaseVNode("div", _hoisted_10$7, [
                    createBaseVNode("span", _hoisted_11$7, toDisplayString$1(row.name), 1),
                    createBaseVNode("span", _hoisted_12$7, toDisplayString$1(row.pseudo), 1)
                  ]),
                  createBaseVNode("div", _hoisted_13$7, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row.gauges, (gauge) => {
                      return openBlock(), createElementBlock("span", null, [
                        createBaseVNode("span", null, toDisplayString$1(gauge.label), 1),
                        createBaseVNode("span", null, toDisplayString$1(gauge.value), 1)
                      ]);
                    }), 256))
                  ]),
                  createBaseVNode("div", _hoisted_14$6, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row.stats, (stat) => {
                      return openBlock(), createElementBlock("span", null, [
                        createBaseVNode("span", null, toDisplayString$1(stat.label), 1),
                        createBaseVNode("span", null, toDisplayString$1(stat.value), 1)
                      ]);
                    }), 256))
                  ]),
                  row.tags !== void 0 && row.tags.length ? (openBlock(), createElementBlock("div", _hoisted_15$6, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(row.tags, (tag) => {
                      return openBlock(), createElementBlock("span", {
                        class: normalizeClass(["tag", "tag-" + tag.code])
                      }, [
                        createBaseVNode("span", _hoisted_16$6, toDisplayString$1(tag.label), 1)
                      ], 2);
                    }), 256))
                  ])) : createCommentVNode("", true)
                ], 42, _hoisted_9$7))
              ]),
              noDataFound: withCtx(() => [
                $data.store.characters.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_17$6, toDisplayString$1(_ctx.$t("no_characters_to_show_try_different_filter")), 1)) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["ds-data", "ds-filter-fields", "ds-sort-as"])
      ])
    ], 4)
  ], 64);
}
const AdminTabCharacters = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$a]]);
const vueColorPicker_min = "";
const TO_DEGREES = 180 / Math.PI;
const normalizeAngle = (angle) => {
  const mod = angle % 360;
  return mod < 0 ? 360 + mod : mod;
};
const getRotationFromCoords = ({
  x,
  y: y2
}, rect) => {
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  return Math.atan2(y2 - cy, x - cx) * TO_DEGREES;
};
const noop$1 = () => {
};
class Rotator {
  constructor(element2, options) {
    this.active = false;
    this.element = element2;
    this.element.style.willChange = "transform";
    this.initOptions(options);
    this.updateCSS();
    this.bindHandlers();
    this.addListeners();
  }
  get angle() {
    return this._angle;
  }
  set angle(value) {
    if (this._angle !== value) {
      this._angle = normalizeAngle(value);
      this.updateCSS();
    }
  }
  initOptions(options) {
    options = options || {};
    this.onRotate = options.onRotate || noop$1;
    this.onDragStart = options.onDragStart || noop$1;
    this.onDragStop = options.onDragStop || noop$1;
    this._angle = options.angle || 0;
  }
  bindHandlers() {
    this.onRotationStart = this.onRotationStart.bind(this);
    this.onRotated = this.onRotated.bind(this);
    this.onRotationStop = this.onRotationStop.bind(this);
  }
  addListeners() {
    this.element.addEventListener("touchstart", this.onRotationStart, {
      passive: true
    });
    document.addEventListener("touchmove", this.onRotated, {
      passive: false
    });
    document.addEventListener("touchend", this.onRotationStop, {
      passive: true
    });
    document.addEventListener("touchcancel", this.onRotationStop, {
      passive: true
    });
    this.element.addEventListener("mousedown", this.onRotationStart, {
      passive: true
    });
    document.addEventListener("mousemove", this.onRotated, {
      passive: false
    });
    document.addEventListener("mouseup", this.onRotationStop, {
      passive: true
    });
    document.addEventListener("mouseleave", this.onRotationStop, {
      passive: false
    });
  }
  removeListeners() {
    this.element.removeEventListener("touchstart", this.onRotationStart);
    document.removeEventListener("touchmove", this.onRotated);
    document.removeEventListener("touchend", this.onRotationStop);
    document.removeEventListener("touchcancel", this.onRotationStop);
    this.element.removeEventListener("mousedown", this.onRotationStart);
    document.removeEventListener("mousemove", this.onRotated);
    document.removeEventListener("mouseup", this.onRotationStop);
    document.removeEventListener("mouseleave", this.onRotationStop);
  }
  destroy() {
    this.onRotationStop();
    this.removeListeners();
  }
  onRotationStart(event) {
    if (event.type === "touchstart" || event.button === 0) {
      this.active = true;
      this.onDragStart(event);
      this.setAngleFromEvent(event);
    }
  }
  onRotationStop() {
    if (this.active) {
      this.active = false;
      this.onDragStop();
    }
    this.active = false;
  }
  onRotated(event) {
    if (this.active) {
      event.preventDefault();
      this.setAngleFromEvent(event);
    }
  }
  setAngleFromEvent(event) {
    const ev = event.targetTouches ? event.targetTouches[0] : event;
    const newAngle = getRotationFromCoords({
      x: ev.clientX,
      y: ev.clientY
    }, this.element.getBoundingClientRect());
    this._angle = normalizeAngle(newAngle + 90);
    this.updateCSS();
    this.onRotate(this._angle);
  }
  updateCSS() {
    this.element.style.transform = "rotate(" + this._angle + "deg)";
  }
}
const colors = ["red", "yellow", "green", "cyan", "blue", "magenta", "red"];
const keys = {
  ArrowUp: (oldAngle, step) => oldAngle + step,
  ArrowRight: (oldAngle, step) => oldAngle + step,
  ArrowDown: (oldAngle, step) => oldAngle - step,
  ArrowLeft: (oldAngle, step) => oldAngle - step,
  PageUp: (oldAngle, step) => oldAngle + step * 10,
  PageDown: (oldAngle, step) => oldAngle - step * 10,
  Home: () => 0,
  End: () => 359
};
const _sfc_main$a = {
  name: "ColorPicker",
  emits: ["select", "input", "change"],
  props: {
    hue: {
      default: 0
    },
    saturation: {
      default: 100
    },
    luminosity: {
      default: 50
    },
    alpha: {
      default: 1
    },
    step: {
      default: 1
    },
    mouseScroll: {
      default: false
    },
    variant: {
      default: "collapsible"
    },
    disabled: {
      default: false
    },
    initiallyCollapsed: {
      default: false
    },
    ariaLabel: {
      default: "color picker"
    },
    ariaRoledescription: {
      default: "radial slider"
    },
    ariaValuetext: {
      default: ""
    },
    ariaLabelColorWell: {
      default: "color well"
    }
  },
  setup(props, { emit: emit3 }) {
    const el = ref(null);
    const rotator = ref(null);
    let rcp = null;
    const initialAngle = props.hue + "deg";
    const angle = ref(props.hue);
    const isPaletteIn = ref(!props.initiallyCollapsed);
    const isKnobIn = ref(!props.initiallyCollapsed);
    const isPressed = ref(false);
    const isRippling = ref(false);
    const isDragging = ref(false);
    const color = computed(() => `hsla(${angle.value}, ${props.saturation}%, ${props.luminosity}%, ${props.alpha})`);
    const valuetext = computed(() => {
      return colors[Math.round(angle.value / 60)];
    });
    watch(() => props.hue, (value) => {
      angle.value = value;
      rcp.angle = value;
    });
    onMounted(() => {
      rcp = new Rotator(rotator.value, {
        angle: angle.value,
        onRotate(hue) {
          angle.value = hue;
          emit3("input", angle.value);
        },
        onDragStart() {
          isDragging.value = true;
        },
        onDragStop() {
          isDragging.value = false;
          emit3("change", angle.value);
        }
      });
    });
    onBeforeUnmount(() => {
      rcp.destroy();
      rcp = null;
    });
    const onKeyDown = (ev) => {
      if (props.disabled || isPressed.value || !isKnobIn.value || !(ev.key in keys))
        return;
      ev.preventDefault();
      rcp.angle = keys[ev.key](rcp.angle, props.step);
      angle.value = rcp.angle;
      emit3("input", angle.value);
      emit3("change", angle.value);
    };
    const onScroll = (ev) => {
      if (isPressed.value || !isKnobIn.value)
        return;
      ev.preventDefault();
      if (ev.deltaY > 0) {
        rcp.angle += props.step;
      } else {
        rcp.angle -= props.step;
      }
      angle.value = rcp.angle;
      emit3("input", angle.value);
      emit3("change", angle.value);
    };
    const selectColor = () => {
      isPressed.value = true;
      if (isPaletteIn.value && isKnobIn.value) {
        emit3("select", angle.value);
        isRippling.value = true;
      } else {
        isPaletteIn.value = true;
      }
    };
    const togglePicker = () => {
      if (props.variant !== "persistent") {
        if (isKnobIn.value) {
          isKnobIn.value = false;
        } else {
          isKnobIn.value = true;
          isPaletteIn.value = true;
        }
      }
      isRippling.value = false;
      isPressed.value = false;
    };
    const hidePalette = () => {
      if (!isKnobIn.value) {
        isPaletteIn.value = false;
      }
    };
    return {
      rcp,
      el,
      rotator,
      initialAngle,
      angle,
      isPaletteIn,
      isKnobIn,
      isDragging,
      isRippling,
      isPressed,
      color,
      valuetext,
      onKeyDown,
      onScroll,
      selectColor,
      togglePicker,
      hidePalette
    };
  }
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("div", {
    ref: "el",
    role: "slider",
    "aria-roledescription": $props.ariaRoledescription,
    "aria-label": $props.ariaLabel,
    "aria-expanded": $setup.isPaletteIn,
    "aria-valuemin": "0",
    "aria-valuemax": "359",
    "aria-valuenow": $setup.angle,
    "aria-valuetext": $props.ariaValuetext || $setup.valuetext,
    "aria-disabled": $props.disabled,
    class: ["rcp", { dragging: $setup.isDragging, disabled: $props.disabled }],
    tabindex: $props.disabled ? -1 : 0,
    style: { "--rcp-initial-angle": $setup.initialAngle },
    onKeyup: _cache[4] || (_cache[4] = withKeys((...args) => $setup.selectColor && $setup.selectColor(...args), ["enter"])),
    onKeydown: _cache[5] || (_cache[5] = (...args) => $setup.onKeyDown && $setup.onKeyDown(...args))
  }, [
    createVNode("div", {
      class: ["rcp__palette", $setup.isPaletteIn ? "in" : "out"]
    }, null, 2),
    createVNode("div", mergeProps({
      class: "rcp__rotator",
      style: {
        "pointer-events": $props.disabled || $setup.isPressed || !$setup.isKnobIn ? "none" : null
      }
    }, toHandlers($props.mouseScroll ? { wheel: $setup.onScroll } : {}), { ref: "rotator" }), [
      createVNode("div", {
        class: ["rcp__knob", $setup.isKnobIn ? "in" : "out"],
        onTransitionend: _cache[1] || (_cache[1] = (...args) => $setup.hidePalette && $setup.hidePalette(...args))
      }, null, 34)
    ], 16),
    createVNode("div", {
      class: ["rcp__ripple", { rippling: $setup.isRippling }],
      style: { borderColor: $setup.color }
    }, null, 6),
    createVNode("button", {
      type: "button",
      class: ["rcp__well", { pressed: $setup.isPressed }],
      "aria-label": $props.ariaLabelColorWell,
      disabled: $props.disabled,
      tabindex: $props.disabled ? -1 : 0,
      style: { backgroundColor: $setup.color },
      onAnimationend: _cache[2] || (_cache[2] = (...args) => $setup.togglePicker && $setup.togglePicker(...args)),
      onClick: _cache[3] || (_cache[3] = (...args) => $setup.selectColor && $setup.selectColor(...args))
    }, null, 46, ["aria-label", "disabled", "tabindex"])
  ], 46, ["aria-roledescription", "aria-label", "aria-expanded", "aria-valuenow", "aria-valuetext", "aria-disabled", "tabindex"]);
}
_sfc_main$a.render = _sfc_render$9;
_sfc_main$a.install = function(app2) {
  app2.component("ColorPicker", _sfc_main$a);
};
const AdminTabTags_vue_vue_type_style_index_0_lang = "";
const _sfc_main$9 = {
  components: { VueMultiselect: script$1, VueSimpleContextMenu, ColorPicker: _sfc_main$a },
  data() {
    const store = usePlayerStore();
    const options_contextual = [{}];
    const color = reactive({
      hue: 50,
      saturation: 71,
      luminosity: 50,
      alpha: 1
    });
    const color_picked = null;
    const group_selected = null;
    return {
      store,
      options_contextual,
      color,
      color_picked,
      group_selected
    };
  },
  mounted() {
    this.store.generateCss();
  },
  methods: {
    onInput(hue) {
      this.color.hue = hue;
    },
    onColorSelect(hue) {
      if (this.color_picked != null) {
        this.color_picked.color = [hue, 71, 50];
        this.store.generateCss();
      }
    },
    handleFocusOut() {
      this.color_picked = null;
    },
    removeTag: function(tag) {
      this.store.removeTagFromAll(tag);
      let groupIndex = this.store.tag_groups.findIndex((group) => group.code === tag.group);
      let tagIndex = this.store.tag_groups[groupIndex].tags.findIndex((search_tag) => search_tag.code === tag.code);
      this.store.tag_groups[groupIndex].picking_array = this.store.tag_groups[groupIndex].picking_array.filter((code2) => code2 !== tag.code);
      if (tagIndex > -1) {
        this.store.tag_groups[groupIndex].tags.splice(tagIndex, 1);
      }
      this.store.generateCss();
    },
    addGroupTag: function() {
      let group = this.store.addGroupTag();
      this.$nextTick(() => {
        this.$refs["group_tag_select_" + group.code][0].$el.focus();
      });
    },
    removeGroupTag: function(key) {
      this.store.tag_groups[key].tags.forEach((tag) => this.store.removeTagFromAll(tag));
      this.store.tag_groups.splice(key, 1);
      this.store.generateCss();
    },
    distributeGroupTag: function(group) {
      const vm = this;
      this.store.characters.forEach(function(character) {
        let found = character.tags.findIndex((tag) => tag.group === group.code);
        if (found === -1) {
          character.tags.push(vm.store.getRandomTagFromGroup(group));
        }
      });
    },
    shuffleGroupTag: function(group) {
      const vm = this;
      this.store.characters.forEach(function(character) {
        let found = character.tags.findIndex((tag) => tag.group === group.code);
        if (found > -1) {
          character.tags.splice(found, 1);
          character.tags.push(vm.store.getRandomTagFromGroup(group));
        }
      });
    },
    focusLabelGroup(event, key) {
      this.group_selected = key;
      this.$nextTick(() => {
        this.$refs["group_name_input_" + key][0].focus();
      });
    },
    handleClick(event, item, group) {
      this.options_contextual = this.generateOptions(item, group);
      this.$refs.context_menu_tags.showMenu(event, item);
      this.$refs.context_menu_tags.$el.focus();
    },
    generateOptions(item, group) {
      let options = [];
      options.push({ name: this.$t("delete"), effect: "remove" });
      options.push({ type: "divider" });
      if (item.stat1 === void 0) {
        for (const [key, stat] of Object.entries(this.store.stats)) {
          options.push({ name: this.$t("linkStatToTag", { statname: stat.name }), effect: "stat1", target: key });
        }
      } else {
        options.push({ name: this.$t("unlinkStatToTag", { statname: this.store.stats[item.stat1].name }), effect: "stat1_unset", target: item.stat1 });
      }
      if (item.stat1 !== void 0) {
        if (item.stat2 === void 0) {
          for (const [key, stat] of Object.entries(this.store.stats)) {
            if (item.stat1 !== key) {
              options.push({ name: this.$t("link2StatToTag", { statname: stat.name }), effect: "stat2", target: key });
            }
          }
        } else {
          options.push({ name: this.$t("unlink2StatToTag", { statname: this.store.stats[item.stat2].name }), effect: "stat2_unset", target: item.stat2 });
        }
      }
      options.push({ type: "divider" });
      for (const [key, gauge] of Object.entries(this.store.gauges)) {
        options.push({ name: this.$t("bonus_gauge", { name: gauge.name }), effect: "bonus_gauge", target: key, value: 1 });
        options.push({ name: this.$t("malus_gauge", { name: gauge.name }), effect: "bonus_gauge", target: key, value: -1 });
      }
      options.push({ type: "divider" });
      for (const [key, stat] of Object.entries(this.store.stats)) {
        options.push({ name: this.$t("bonus_stat", { name: stat.name }), effect: "bonus_stat", target: key, value: 1 });
        options.push({ name: this.$t("malus_stat", { name: stat.name }), effect: "bonus_stat", target: key, value: -1 });
      }
      options.push({ type: "divider" });
      options.push({ name: this.$t("change_tag_color"), effect: "color" });
      if (group.start === "random") {
        if (item.probability !== void 0 && item.probability > 1) {
          options.push({ name: this.$t("decrease_probability"), effect: "decrease_probability", group });
        }
        options.push({ name: this.$t("increase_probability"), effect: "increase_probability", group });
      }
      return options;
    },
    optionClicked(event) {
      if (event.option.effect !== void 0) {
        let tag = this.store.getTagFromCode(event.item.code);
        switch (event.option.effect) {
          case "remove":
            this.removeTag(event.item);
            break;
          case "bonus_stat":
            if (tag.stat_modifiers === void 0) {
              tag.stat_modifiers = {};
            }
            if (tag.stat_modifiers[event.option.target] === void 0) {
              tag.stat_modifiers[event.option.target] = { value: event.option.value };
            } else {
              tag.stat_modifiers[event.option.target].value += event.option.value;
            }
            if (tag.stat_modifiers[event.option.target].value === 0) {
              delete tag.stat_modifiers[event.option.target];
            }
            break;
          case "bonus_gauge":
            if (tag.gauge_modifiers === void 0) {
              tag.gauge_modifiers = {};
            }
            if (tag.gauge_modifiers[event.option.target] === void 0) {
              tag.gauge_modifiers[event.option.target] = { value: event.option.value };
            } else {
              tag.gauge_modifiers[event.option.target].value += event.option.value;
            }
            if (tag.gauge_modifiers[event.option.target].value === 0) {
              delete tag.gauge_modifiers[event.option.target];
            }
            break;
          case "stat1":
            tag.stat1 = event.option.target;
            break;
          case "stat1_unset":
            if (tag.stat2 !== void 0) {
              tag.stat1 = tag.stat2;
              delete tag.stat2;
            } else {
              delete tag.stat1;
            }
            break;
          case "stat2":
            tag.stat2 = event.option.target;
            break;
          case "stat2_unset":
            delete tag.stat2;
            break;
          case "color":
            this.color.hue = tag.color[0];
            this.color_picked = tag;
            this.$nextTick(() => {
              this.$refs.color_picker.$el.focus();
            });
            break;
          case "increase_probability":
            if (tag.probability === void 0) {
              tag.probability = 2;
            } else {
              tag.probability += 1;
            }
            event.option.group.picking_array.push(tag.code);
            break;
          case "decrease_probability":
            tag.probability -= 1;
            let index = event.option.group.picking_array.findIndex((code2) => code2 === tag.code);
            if (index > -1) {
              event.option.group.picking_array.splice(index, 1);
            }
            break;
        }
      }
    },
    changeGroupRule(group) {
      if (group.start === "equitable") {
        group.picking_array = [];
        group.tags.forEach((tag) => group.picking_array.push(tag.code));
      }
    }
  }
};
const _hoisted_1$8 = {
  class: "tab",
  ref: "tab"
};
const _hoisted_2$8 = {
  id: "tab-tags-content",
  ref: "step_tags"
};
const _hoisted_3$8 = { class: "actions" };
const _hoisted_4$8 = { class: "group-label" };
const _hoisted_5$7 = ["onUpdate:modelValue"];
const _hoisted_6$6 = ["onKeyup", "onClick"];
const _hoisted_7$6 = { class: "actions secondary" };
const _hoisted_8$6 = { for: "creation_rule" };
const _hoisted_9$6 = ["onChange", "onUpdate:modelValue"];
const _hoisted_10$6 = { value: "random" };
const _hoisted_11$6 = { value: "equitable" };
const _hoisted_12$6 = { value: "start" };
const _hoisted_13$6 = { value: "none" };
const _hoisted_14$5 = ["onClick", "title"];
const _hoisted_15$5 = ["onClick", "title"];
const _hoisted_16$5 = ["onClick", "title"];
const _hoisted_17$5 = ["onKeyup", "onClick"];
const _hoisted_18$5 = /* @__PURE__ */ createBaseVNode("span", { class: "icon-settings hover-only" }, null, -1);
const _hoisted_19$5 = { class: "label-name" };
const _hoisted_20$5 = { key: 0 };
const _hoisted_21$5 = { key: 1 };
const _hoisted_22$5 = { key: 4 };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VueSimpleContextMenu = resolveComponent("VueSimpleContextMenu");
  const _component_color_picker = resolveComponent("color-picker");
  const _component_vue_multiselect = resolveComponent("vue-multiselect");
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    createBaseVNode("div", _hoisted_2$8, [
      createBaseVNode("div", _hoisted_3$8, [
        createVNode(_component_VueSimpleContextMenu, {
          "element-id": "context_menu_tags",
          options: $data.options_contextual,
          ref: "context_menu_tags",
          onOptionClicked: $options.optionClicked
        }, null, 8, ["options", "onOptionClicked"]),
        createBaseVNode("div", {
          class: normalizeClass(["color-picker", { show: $data.color_picked != null }])
        }, [
          createVNode(_component_color_picker, mergeProps({ ref: "color_picker" }, $data.color, {
            onInput: $options.onColorSelect,
            onFocusout: $options.handleFocusOut,
            step: 30
          }), null, 16, ["onInput", "onFocusout"])
        ], 2),
        createBaseVNode("button", {
          ref: "step_tags_group_add",
          class: "icon-add",
          onClick: _cache[0] || (_cache[0] = ($event) => $options.addGroupTag())
        }, toDisplayString$1(_ctx.$t("add_groug_of_tag")), 513)
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.getGroupTags(), (group, key) => {
        return openBlock(), createElementBlock("div", {
          class: "group-tag",
          ref_for: true,
          ref: key === 0 ? "step_tags_group" : null
        }, [
          createBaseVNode("span", _hoisted_4$8, [
            $data.group_selected === key ? withDirectives((openBlock(), createElementBlock("input", {
              key: 0,
              ref_for: true,
              ref: "group_name_input_" + key,
              onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => {
                $data.group_selected = null;
              }, ["enter"])),
              type: "text",
              "onUpdate:modelValue": ($event) => $data.store.current_game.tag_groups[key].label = $event
            }, null, 40, _hoisted_5$7)), [
              [vModelText, $data.store.current_game.tag_groups[key].label]
            ]) : createCommentVNode("", true),
            withDirectives(createBaseVNode("button", {
              onKeyup: withKeys(($event) => $options.focusLabelGroup($event, key), ["enter"]),
              onClick: ($event) => $options.focusLabelGroup($event, key),
              class: "icon-edit",
              ref_for: true,
              ref: key === 0 ? "step_tags_group_rename" : null
            }, toDisplayString$1($data.store.current_game.tag_groups[key].label), 41, _hoisted_6$6), [
              [vShow, $data.group_selected !== key]
            ]),
            withDirectives(createBaseVNode("button", {
              onClick: _cache[2] || (_cache[2] = ($event) => $data.group_selected = null)
            }, toDisplayString$1(_ctx.$t("tags_submit")), 513), [
              [vShow, $data.group_selected === key]
            ])
          ]),
          createBaseVNode("div", _hoisted_7$6, [
            createBaseVNode("label", _hoisted_8$6, toDisplayString$1(_ctx.$t("distribution_mode")), 1),
            withDirectives(createBaseVNode("select", {
              onChange: ($event) => $options.changeGroupRule(group),
              id: "creation_rule",
              "onUpdate:modelValue": ($event) => $data.store.current_game.tag_groups[key].start = $event,
              ref_for: true,
              ref: key === 0 ? "step_tags_group_distribution" : null
            }, [
              createBaseVNode("option", _hoisted_10$6, toDisplayString$1(_ctx.$t("randomly_distributed_at_creation")), 1),
              createBaseVNode("option", _hoisted_11$6, toDisplayString$1(_ctx.$t("equitably_distributed_at_creation")), 1),
              createBaseVNode("option", _hoisted_12$6, toDisplayString$1(_ctx.$t("chosen_at_char_creation")), 1),
              createBaseVNode("option", _hoisted_13$6, toDisplayString$1(_ctx.$t("not_autodistributed")), 1)
            ], 40, _hoisted_9$6), [
              [vModelSelect, $data.store.current_game.tag_groups[key].start]
            ]),
            createBaseVNode("button", {
              onClick: ($event) => $options.distributeGroupTag(group),
              title: _ctx.$t("a_tag_will_be_assigned_to_char"),
              ref_for: true,
              ref: key === 0 ? "step_tags_group_distribute" : null
            }, toDisplayString$1(_ctx.$t("distribute")), 9, _hoisted_14$5),
            createBaseVNode("button", {
              onClick: ($event) => $options.shuffleGroupTag(group),
              title: _ctx.$t("shuffle_help"),
              ref_for: true,
              ref: key === 0 ? "step_tags_group_shuffle" : null
            }, toDisplayString$1(_ctx.$t("shuffle")), 9, _hoisted_15$5),
            createBaseVNode("button", {
              class: "btn-danger",
              onClick: ($event) => $options.removeGroupTag(key),
              title: _ctx.$t("delete_groupe_tags_and_remove_from_chars"),
              ref_for: true,
              ref: key === 0 ? "step_tags_group_delete" : null
            }, toDisplayString$1(_ctx.$t("delete")), 9, _hoisted_16$5)
          ]),
          createVNode(_component_vue_multiselect, {
            ref_for: true,
            ref: "group_tag_select_" + group.code,
            id: "tag_" + key,
            modelValue: $data.store.current_game.tag_groups[key].tags,
            "onUpdate:modelValue": ($event) => $data.store.current_game.tag_groups[key].tags = $event,
            label: "label",
            "track-by": "code",
            "tag-placeholder": _ctx.$t("add_tag"),
            placeholder: _ctx.$t("input_word"),
            closeOnSelect: false,
            showNoOptions: false,
            options: $data.store.current_game.tag_groups[key].tags,
            multiple: true,
            taggable: true,
            hideSelected: true,
            "show-no-results": false,
            onTag: ($event) => $data.store.addTag($event, group),
            onRemove: _cache[3] || (_cache[3] = ($event) => $options.removeTag($event))
          }, {
            tag: withCtx((tag) => [
              createBaseVNode("div", {
                class: normalizeClass(["multiselect__tag", "tag tag-" + tag.option.code]),
                tabindex: "0",
                onKeyup: withKeys(($event) => $options.handleClick($event, tag.option, group), ["enter"]),
                onClick: withModifiers(($event) => $options.handleClick($event, tag.option, group), ["prevent", "stop"]),
                title: "Paramtrer ce tag",
                ref_for: true,
                ref: key === 0 && Object.entries(group.tags)[0].code === tag.code ? "step_tags_tag" : null
              }, [
                createBaseVNode("div", null, [
                  _hoisted_18$5,
                  createBaseVNode("span", _hoisted_19$5, toDisplayString$1(tag.option.label), 1),
                  tag.option.stat1 ? (openBlock(), createElementBlock("span", _hoisted_20$5, toDisplayString$1(tag.option.stat1 !== void 0 ? _ctx.$t("main_stat") + $data.store.stats[tag.option.stat1].name : ""), 1)) : createCommentVNode("", true),
                  tag.option.stat2 ? (openBlock(), createElementBlock("span", _hoisted_21$5, toDisplayString$1(tag.option.stat2 !== void 0 ? _ctx.$t("secondary_stat") + $data.store.stats[tag.option.stat2].name : ""), 1)) : createCommentVNode("", true),
                  tag.option.gauge_modifiers !== void 0 ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(tag.option.gauge_modifiers, (modifier, key2) => {
                    return openBlock(), createElementBlock("span", null, toDisplayString$1($data.store.gauges[key2].name) + " " + toDisplayString$1(modifier.value > 0 ? "+" + modifier.value : modifier.value), 1);
                  }), 256)) : createCommentVNode("", true),
                  tag.option.stat_modifiers !== void 0 ? (openBlock(true), createElementBlock(Fragment, { key: 3 }, renderList(tag.option.stat_modifiers, (modifier, key2) => {
                    return openBlock(), createElementBlock("span", null, toDisplayString$1($data.store.stats[key2].name) + " " + toDisplayString$1(modifier.value > 0 ? "+" + modifier.value : modifier.value), 1);
                  }), 256)) : createCommentVNode("", true),
                  group.start === "random" ? (openBlock(), createElementBlock("span", _hoisted_22$5, toDisplayString$1(_ctx.$t("tag_probability", { count: tag.option.probability ?? 1, total: $data.store.current_game.tag_groups[key].picking_array.length })), 1)) : createCommentVNode("", true)
                ])
              ], 42, _hoisted_17$5)
            ]),
            _: 2
          }, 1032, ["id", "modelValue", "onUpdate:modelValue", "tag-placeholder", "placeholder", "options", "onTag"])
        ], 512);
      }), 256))
    ], 512)
  ], 512);
}
const AdminTabTags = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$8]]);
const AdminTabSettings_vue_vue_type_style_index_0_scoped_7d13a1fc_lang = "";
const _sfc_main$8 = {
  data() {
    const store = usePlayerStore();
    const change_label_enabled = [];
    const add_gauge_enabled = false;
    const temp_gauge_name = "";
    const temp_gauge_value = 10;
    const add_stat_enabled = false;
    const temp_stat_name = "";
    return {
      store,
      change_label_enabled,
      add_gauge_enabled,
      temp_gauge_name,
      temp_gauge_value,
      add_stat_enabled,
      temp_stat_name
    };
  },
  mounted() {
  },
  methods: {
    changeGauge: function(key) {
      let label = this.store.gauges[key].name = this.$refs["gauge_" + key][0].value;
      let test_value = parseInt(this.$refs["gauge_value_" + key][0].value);
      let value = this.store.gauges[key].value = test_value > 0 ? test_value : 1;
      this.store.characters.forEach(function(character) {
        character.gauges[key].label = label;
        if (character.gauges[key].value > value) {
          character.gauges[key].value = value;
        }
      });
      this.change_label_enabled[key] = false;
    },
    makeDeadly: function(key) {
      let deadly = this.store.gauges[key].deadly = !this.store.gauges[key].deadly;
      if (deadly) {
        this.store.characters.forEach(function(character) {
          if (character.gauges[key].value <= 0) {
            character.alive = false;
          }
        });
      }
      this.change_label_enabled[key] = false;
    },
    addGauge: function() {
      let code2 = Math.floor(Math.random() * 1e7).toString();
      let new_gauge = {
        name: this.temp_gauge_name,
        value: this.temp_gauge_value > 0 ? this.temp_gauge_value : 1
      };
      this.store.gauges[code2] = new_gauge;
      this.store.characters.forEach(function(character) {
        character.gauges[code2] = {
          label: new_gauge.name,
          value: new_gauge.value,
          deadly: false
        };
      });
      this.add_gauge_enabled = false;
      this.temp_gauge_name = "";
    },
    remove: function(key, type) {
      delete this.store[type][key];
      this.store.characters.forEach(function(character) {
        delete character[type][key];
      });
    },
    changeStatLabel: function(key) {
      let label = this.store.stats[key].name = this.$refs["stat_" + key][0].value;
      this.change_label_enabled[key] = false;
      this.store.characters.forEach(function(character) {
        character.stats[key].label = label;
      });
    },
    addStat: function() {
      let new_stat = {
        name: this.temp_stat_name
      };
      let code2 = Math.floor(Math.random() * 1e7).toString();
      this.store.stats[code2] = new_stat;
      this.store.characters.forEach(function(character) {
        character.stats[code2] = { label: new_stat.name, value: Math.floor(Math.random() * 20) + 1 };
      });
      this.add_stat_enabled = false;
      this.temp_stat_name = "";
    }
  }
};
const _hoisted_1$7 = {
  class: "tab",
  ref: "tab"
};
const _hoisted_2$7 = { id: "tab-settings-content" };
const _hoisted_3$7 = {
  ref: "step_settings_gauges",
  class: "wrapper-settings"
};
const _hoisted_4$7 = { class: "wrapper-title" };
const _hoisted_5$6 = { class: "wrapper-list" };
const _hoisted_6$5 = {
  key: 0,
  class: "wrapper-gauge-title"
};
const _hoisted_7$5 = { class: "gauge-name" };
const _hoisted_8$5 = { key: 0 };
const _hoisted_9$5 = ["value"];
const _hoisted_10$5 = ["value"];
const _hoisted_11$5 = ["onClick"];
const _hoisted_12$5 = ["onClick"];
const _hoisted_13$5 = {
  key: 5,
  class: "action"
};
const _hoisted_14$4 = ["onClick"];
const _hoisted_15$4 = ["onClick"];
const _hoisted_16$4 = ["onKeyup", "onClick"];
const _hoisted_17$4 = {
  key: 0,
  class: "action-group"
};
const _hoisted_18$4 = { for: "temp_gauge" };
const _hoisted_19$4 = { for: "temp_gauge_value" };
const _hoisted_20$4 = {
  ref: "step_settings_stats",
  class: "wrapper-settings"
};
const _hoisted_21$4 = { class: "wrapper-title" };
const _hoisted_22$4 = { class: "wrapper-list" };
const _hoisted_23$3 = ["for"];
const _hoisted_24$2 = ["value"];
const _hoisted_25$2 = ["onClick"];
const _hoisted_26$2 = ["onClick"];
const _hoisted_27$2 = { class: "action" };
const _hoisted_28$2 = ["onClick"];
const _hoisted_29$1 = ["onKeyup", "onClick"];
const _hoisted_30$1 = {
  key: 0,
  class: "action-group"
};
const _hoisted_31$1 = { for: "temp_stat" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    createBaseVNode("div", _hoisted_2$7, [
      createBaseVNode("div", _hoisted_3$7, [
        createBaseVNode("div", _hoisted_4$7, [
          createBaseVNode("h2", null, toDisplayString$1(_ctx.$t("bars")), 1),
          !$data.add_gauge_enabled ? (openBlock(), createElementBlock("button", {
            key: 0,
            ref: "step_settings_add_gauge",
            class: "icon-add btn-valid",
            onClick: _cache[0] || (_cache[0] = ($event) => $data.add_gauge_enabled = true)
          }, toDisplayString$1(_ctx.$t("add")), 513)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_5$6, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.gauges, (gauge, key, index) => {
            return openBlock(), createElementBlock("div", {
              class: "gauge list-item",
              ref_for: true,
              ref: index === 0 ? "step_settings_gauge" : null
            }, [
              !$data.change_label_enabled[key] ? (openBlock(), createElementBlock("div", _hoisted_6$5, [
                createBaseVNode("span", _hoisted_7$5, toDisplayString$1(gauge.name), 1),
                createBaseVNode("span", null, toDisplayString$1(_ctx.$t("gauge_start", { gauge_value: gauge.value })), 1),
                gauge.deadly ? (openBlock(), createElementBlock("span", _hoisted_8$5, toDisplayString$1(_ctx.$t("kills_at_0")), 1)) : createCommentVNode("", true)
              ])) : createCommentVNode("", true),
              $data.change_label_enabled[key] ? (openBlock(), createElementBlock("input", {
                key: 1,
                ref_for: true,
                ref: "gauge_" + key,
                value: gauge.name,
                id: "'gauge_'+key",
                type: "text"
              }, null, 8, _hoisted_9$5)) : createCommentVNode("", true),
              $data.change_label_enabled[key] ? (openBlock(), createElementBlock("input", {
                key: 2,
                ref_for: true,
                ref: "gauge_value_" + key,
                value: gauge.value,
                min: "1",
                id: "'gauge_value'+key",
                type: "number"
              }, null, 8, _hoisted_10$5)) : createCommentVNode("", true),
              $data.change_label_enabled[key] ? (openBlock(), createElementBlock("button", {
                key: 3,
                class: "btn-valid",
                onClick: ($event) => $options.changeGauge(key)
              }, toDisplayString$1(_ctx.$t("submit")), 9, _hoisted_11$5)) : createCommentVNode("", true),
              $data.change_label_enabled[key] ? (openBlock(), createElementBlock("button", {
                key: 4,
                onClick: ($event) => $data.change_label_enabled[key] = false
              }, toDisplayString$1(_ctx.$t("cancel")), 9, _hoisted_12$5)) : createCommentVNode("", true),
              !$data.change_label_enabled[key] ? (openBlock(), createElementBlock("div", _hoisted_13$5, [
                createBaseVNode("button", {
                  onClick: ($event) => $options.makeDeadly(key),
                  ref_for: true,
                  ref: index === 0 ? "step_settings_gauge_make_deadly" : null
                }, toDisplayString$1(gauge.deadly ? _ctx.$t("make_normal") : _ctx.$t("make_fatal")), 9, _hoisted_14$4),
                createBaseVNode("button", {
                  onClick: ($event) => $data.change_label_enabled[key] = true
                }, toDisplayString$1(_ctx.$t("modify")), 9, _hoisted_15$4),
                createBaseVNode("button", {
                  class: "btn-danger",
                  onKeyup: withKeys(($event) => $options.remove(key, "gauges"), ["enter"]),
                  onClick: ($event) => $options.remove(key, "gauges"),
                  ref_for: true,
                  ref: index === 0 ? "step_settings_gauge_delete" : null
                }, toDisplayString$1(_ctx.$t("delete")), 41, _hoisted_16$4)
              ])) : createCommentVNode("", true)
            ], 512);
          }), 256)),
          $data.add_gauge_enabled ? (openBlock(), createElementBlock("div", _hoisted_17$4, [
            createBaseVNode("label", _hoisted_18$4, toDisplayString$1(_ctx.$t("name")), 1),
            withDirectives(createBaseVNode("input", {
              id: "temp_gauge",
              type: "text",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.temp_gauge_name = $event),
              onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => $options.addGauge(), ["enter"]))
            }, null, 544), [
              [vModelText, $data.temp_gauge_name]
            ]),
            createBaseVNode("label", _hoisted_19$4, toDisplayString$1(_ctx.$t("starts_at")), 1),
            withDirectives(createBaseVNode("input", {
              id: "temp_gauge_value",
              type: "number",
              min: "1",
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.temp_gauge_value = $event)
            }, null, 512), [
              [vModelText, $data.temp_gauge_value]
            ]),
            createBaseVNode("button", {
              class: "btn-valid",
              onClick: _cache[4] || (_cache[4] = ($event) => $options.addGauge())
            }, toDisplayString$1(_ctx.$t("submit")), 1),
            createBaseVNode("button", {
              onClick: _cache[5] || (_cache[5] = ($event) => $data.add_gauge_enabled = false)
            }, toDisplayString$1(_ctx.$t("cancel")), 1)
          ])) : createCommentVNode("", true)
        ])
      ], 512),
      createBaseVNode("div", _hoisted_20$4, [
        createBaseVNode("div", _hoisted_21$4, [
          createBaseVNode("h2", null, toDisplayString$1(_ctx.$t("stats")), 1),
          !$data.add_stat_enabled ? (openBlock(), createElementBlock("button", {
            key: 0,
            ref: "step_settings_add_stat",
            class: "icon-add btn-valid",
            onClick: _cache[6] || (_cache[6] = ($event) => $data.add_stat_enabled = true)
          }, toDisplayString$1(_ctx.$t("add")), 513)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_22$4, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.stats, (stat, key, index) => {
            return openBlock(), createElementBlock("div", {
              class: "stat list-item",
              ref_for: true,
              ref: index === 0 ? "step_settings_stat" : null
            }, [
              !$data.change_label_enabled[key] ? (openBlock(), createElementBlock("label", {
                key: 0,
                for: "stat_" + key
              }, toDisplayString$1(stat.name), 9, _hoisted_23$3)) : createCommentVNode("", true),
              $data.change_label_enabled[key] ? (openBlock(), createElementBlock("input", {
                key: 1,
                ref_for: true,
                ref: "stat_" + key,
                value: stat.name,
                id: "'stat_'+key",
                type: "text"
              }, null, 8, _hoisted_24$2)) : createCommentVNode("", true),
              $data.change_label_enabled[key] ? (openBlock(), createElementBlock("button", {
                key: 2,
                class: "btn-valid",
                onClick: ($event) => $options.changeStatLabel(key)
              }, toDisplayString$1(_ctx.$t("submit")), 9, _hoisted_25$2)) : createCommentVNode("", true),
              $data.change_label_enabled[key] ? (openBlock(), createElementBlock("button", {
                key: 3,
                onClick: ($event) => $data.change_label_enabled[key] = false
              }, toDisplayString$1(_ctx.$t("cancel")), 9, _hoisted_26$2)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_27$2, [
                !$data.change_label_enabled[key] ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  onClick: ($event) => $data.change_label_enabled[key] = true
                }, toDisplayString$1(_ctx.$t("rename")), 9, _hoisted_28$2)) : createCommentVNode("", true),
                !$data.change_label_enabled[key] ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  class: "btn-danger",
                  onKeyup: withKeys(($event) => $options.remove(key, "stats"), ["enter"]),
                  onClick: ($event) => $options.remove(key, "stats"),
                  ref_for: true,
                  ref: index === 0 ? "step_settings_stat_delete" : null
                }, toDisplayString$1(_ctx.$t("delete")), 41, _hoisted_29$1)) : createCommentVNode("", true)
              ])
            ], 512);
          }), 256)),
          $data.add_stat_enabled ? (openBlock(), createElementBlock("div", _hoisted_30$1, [
            createBaseVNode("label", _hoisted_31$1, toDisplayString$1(_ctx.$t("name")), 1),
            withDirectives(createBaseVNode("input", {
              onKeyup: _cache[7] || (_cache[7] = withKeys(($event) => $options.addStat(), ["enter"])),
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.temp_stat_name = $event),
              id: "temp_stat",
              type: "text"
            }, null, 544), [
              [vModelText, $data.temp_stat_name]
            ]),
            createBaseVNode("button", {
              class: "btn-valid",
              onClick: _cache[9] || (_cache[9] = ($event) => $options.addStat())
            }, toDisplayString$1(_ctx.$t("submit")), 1),
            createBaseVNode("button", {
              onClick: _cache[10] || (_cache[10] = ($event) => $data.add_stat_enabled = false)
            }, toDisplayString$1(_ctx.$t("cancel")), 1)
          ])) : createCommentVNode("", true)
        ])
      ], 512)
    ])
  ], 512);
}
const AdminTabSettings = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$7], ["__scopeId", "data-v-7d13a1fc"]]);
const AdminTabPoll_vue_vue_type_style_index_0_scoped_7e3c4dd5_lang = "";
const _sfc_main$7 = {
  components: {
    VueMultiselect: script$1
  },
  data() {
    const store = usePlayerStore();
    const nb_options = 0;
    const answers = {};
    const label = "";
    const poll_tab = "active";
    const open_past_poll = ref(null);
    const poll_show = [];
    const tags_poll = [];
    const chosen_tags = [];
    return {
      store,
      nb_options,
      answers,
      label,
      poll_tab,
      open_past_poll,
      poll_show,
      tags_poll,
      chosen_tags
    };
  },
  mounted() {
  },
  methods: {
    startPoll() {
      const date = Date.now();
      let poll = {
        code: date,
        label: this.label,
        answers: this.answers,
        active: true
      };
      this.addPoll(poll);
      this.poll_tab = "active";
    },
    toggle_poll(id_poll) {
      if (this.open_past_poll != null) {
        this.open_past_poll[0].classList.remove("open");
      }
      this.open_past_poll = this.$refs["past_poll_" + id_poll];
      this.open_past_poll[0].classList.add("open");
    },
    finishPoll(id_poll) {
      const vm = this;
      this.store.polls[id_poll].active = false;
      this.store.characters.forEach(function(character) {
        if (character.polls[id_poll] !== void 0) {
          if (character.polls[id_poll].answer !== void 0 && vm.store.polls[id_poll].options[character.polls[id_poll].answer].tags !== void 0) {
            let new_tags = vm.store.polls[id_poll].options[character.polls[id_poll].answer].tags;
            new_tags.forEach((tag) => character.tags.push(tag));
          }
          delete character.polls[id_poll];
        }
      });
      if (this.store.active_polls.length === 0) {
        this.poll_tab = "past";
      }
    },
    focus(n) {
      if (n === this.nb_options) {
        this.nb_options += 1;
      }
      if (n <= this.nb_options) {
        this.$nextTick(() => {
          this.$refs["choice_" + (n + 1)][0].focus();
        });
      }
    },
    attendance(poll) {
      let count = Object.entries(poll.options).map((obj) => obj[1].count).reduce((accumulator, current) => accumulator + current, 0);
      if (count === 0) {
        return 0;
      } else {
        return (100 / poll.nb_targets * count).toFixed(2);
      }
    },
    addPoll(poll) {
      const vm = this;
      this.store.polls[poll.code] = {
        label: poll.label,
        active: true,
        options: {}
      };
      for (const key in poll.answers) {
        this.store.polls[poll.code].options[key] = {
          label: poll.answers[key],
          count: 0,
          tags: this.chosen_tags[key]
        };
      }
      let selectedCharacters;
      if (this.tags_poll.length) {
        selectedCharacters = this.store.connected_characters(true).filter((character) => vm.store.filterCharacterByTagsAndPicked(character, vm.tags_poll));
      } else {
        selectedCharacters = this.store.connected_characters(true);
      }
      this.store.polls[poll.code].nb_targets = selectedCharacters.length;
      selectedCharacters.forEach(function(character) {
        character.polls[poll.code] = { label: poll.label, options: poll.answers, active: true };
      });
      this.nb_options = 0;
      this.label = "";
      this.tags_poll = [];
      this.chosen_tags = [];
      this.answers = {};
    },
    delete_poll(code2) {
      delete this.store.polls[code2];
    },
    addTag(tag_label, key) {
      let group = this.store.tag_groups.find((element2) => element2.code === "freetag");
      if (group === void 0) {
        group = this.store.addGroupTag(true);
      }
      let tag = this.store.addTag(tag_label, group);
      if (this.chosen_tags[key] === void 0) {
        this.chosen_tags[key] = [];
      }
      this.chosen_tags[key].push(tag);
    }
  }
};
const _hoisted_1$6 = {
  class: "tab",
  ref: "tab"
};
const _hoisted_2$6 = { id: "tab-poll-content" };
const _hoisted_3$6 = { class: "actions" };
const _hoisted_4$6 = {
  key: 0,
  class: "vertical-wrapper add-poll"
};
const _hoisted_5$5 = { for: "poll_targets" };
const _hoisted_6$4 = { for: "question" };
const _hoisted_7$4 = { class: "poll-choice" };
const _hoisted_8$4 = ["for"];
const _hoisted_9$4 = ["id", "onKeyup", "onUpdate:modelValue"];
const _hoisted_10$4 = ["for"];
const _hoisted_11$4 = ["disabled"];
const _hoisted_12$4 = {
  key: 1,
  class: "vertical-wrapper"
};
const _hoisted_13$4 = { class: "title" };
const _hoisted_14$3 = { class: "results" };
const _hoisted_15$3 = { class: "actions" };
const _hoisted_16$3 = ["onClick"];
const _hoisted_17$3 = ["onClick"];
const _hoisted_18$3 = {
  key: 2,
  class: "vertical-wrapper"
};
const _hoisted_19$3 = { class: "wrapper-title" };
const _hoisted_20$3 = { class: "title" };
const _hoisted_21$3 = ["onClick"];
const _hoisted_22$3 = ["onClick"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vue_multiselect = resolveComponent("vue-multiselect");
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createBaseVNode("div", _hoisted_2$6, [
      createBaseVNode("div", _hoisted_3$6, [
        createBaseVNode("button", {
          onClick: _cache[0] || (_cache[0] = ($event) => $data.poll_tab = "add"),
          class: normalizeClass(["icon-add", { active: $data.poll_tab === "add" }])
        }, toDisplayString$1(_ctx.$t("add_poll")), 3),
        createBaseVNode("button", {
          onClick: _cache[1] || (_cache[1] = ($event) => $data.poll_tab = "active"),
          class: normalizeClass({ active: $data.poll_tab === "active" })
        }, toDisplayString$1(_ctx.$t("active_polls")), 3),
        createBaseVNode("button", {
          onClick: _cache[2] || (_cache[2] = ($event) => $data.poll_tab = "past"),
          class: normalizeClass({ active: $data.poll_tab === "past" })
        }, toDisplayString$1(_ctx.$t("past_polls")), 3)
      ]),
      $data.poll_tab === "add" ? (openBlock(), createElementBlock("div", _hoisted_4$6, [
        createBaseVNode("div", null, [
          createBaseVNode("label", _hoisted_5$5, toDisplayString$1(_ctx.$t("targets")), 1),
          createVNode(_component_vue_multiselect, {
            ref: "poll_targets",
            id: "poll_targets",
            class: "left-multiselect",
            modelValue: $data.tags_poll,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.tags_poll = $event),
            label: "label",
            "track-by": "code",
            "group-values": "tags",
            "group-label": "label",
            "group-select": true,
            placeholder: _ctx.$t("select_tag"),
            tagPlaceholder: _ctx.$t("select_tag"),
            noOptions: _ctx.$t("everyone"),
            options: $data.store.tag_groups_plus_targets,
            multiple: true,
            taggable: false,
            hideSelected: true
          }, null, 8, ["modelValue", "placeholder", "tagPlaceholder", "noOptions", "options"])
        ]),
        createBaseVNode("div", null, [
          createBaseVNode("label", _hoisted_6$4, toDisplayString$1(_ctx.$t("question")), 1),
          withDirectives(createBaseVNode("input", {
            onKeyup: _cache[4] || (_cache[4] = withKeys(($event) => $options.focus(0), ["enter"])),
            id: "question",
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.label = $event),
            type: "text"
          }, null, 544), [
            [vModelText, $data.label]
          ])
        ]),
        createBaseVNode("div", null, [
          createBaseVNode("span", null, toDisplayString$1(_ctx.$t("possible_choices")), 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.nb_options, (n) => {
            return openBlock(), createElementBlock("div", _hoisted_7$4, [
              createBaseVNode("div", null, [
                createBaseVNode("label", {
                  for: "choice_" + n
                }, toDisplayString$1(_ctx.$t("nb_choice", { "nb": n })), 9, _hoisted_8$4),
                withDirectives(createBaseVNode("input", {
                  id: "choice_" + n,
                  ref_for: true,
                  ref: "choice_" + n,
                  onKeyup: withKeys(($event) => $options.focus(n), ["enter"]),
                  "onUpdate:modelValue": ($event) => $data.answers[n] = $event,
                  type: "text"
                }, null, 40, _hoisted_9$4), [
                  [vModelText, $data.answers[n]]
                ])
              ]),
              createBaseVNode("div", null, [
                createBaseVNode("label", {
                  for: "chosen_tags_" + n
                }, toDisplayString$1(_ctx.$t("choice_gives_tag")), 9, _hoisted_10$4),
                createVNode(_component_vue_multiselect, {
                  id: "chosen_tags_" + n,
                  modelValue: $data.chosen_tags[n],
                  "onUpdate:modelValue": ($event) => $data.chosen_tags[n] = $event,
                  class: "left-multiselect",
                  label: "label",
                  "track-by": "code",
                  "tag-placeholder": _ctx.$t("add_tag"),
                  placeholder: _ctx.$t("input_word"),
                  noOptions: _ctx.$t("no_tag_create"),
                  "group-values": "tags",
                  "group-label": "label",
                  "group-select": false,
                  options: $data.store.tag_groups,
                  multiple: true,
                  taggable: true,
                  hideSelected: true,
                  onTag: ($event) => $options.addTag($event, n)
                }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "tag-placeholder", "placeholder", "noOptions", "options", "onTag"])
              ])
            ]);
          }), 256)),
          createBaseVNode("button", {
            onClick: _cache[6] || (_cache[6] = ($event) => $data.nb_options += 1)
          }, toDisplayString$1(_ctx.$t("add_poll_choice")), 1)
        ]),
        createBaseVNode("button", {
          class: "btn-valid",
          disabled: $data.nb_options < 2 || $data.label === "",
          onClick: _cache[7] || (_cache[7] = (...args) => $options.startPoll && $options.startPoll(...args))
        }, toDisplayString$1(_ctx.$t("start_poll")), 9, _hoisted_11$4)
      ])) : createCommentVNode("", true),
      $data.poll_tab === "active" ? (openBlock(), createElementBlock("div", _hoisted_12$4, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.active_polls, (poll, key) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass(["list-polls poll-active", { show: $data.poll_show[key] }])
          }, [
            createBaseVNode("span", _hoisted_13$4, toDisplayString$1(poll.label), 1),
            createBaseVNode("span", null, [
              createBaseVNode("span", null, toDisplayString$1(_ctx.$t("turnout")), 1),
              createBaseVNode("span", {
                class: normalizeClass({ full_attendance: $options.attendance(poll) === "100.00" })
              }, toDisplayString$1($options.attendance(poll)) + "%", 3)
            ]),
            createBaseVNode("div", _hoisted_14$3, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(Object.entries(poll.options).sort(function(a, b) {
                return b[1].count - a[1].count;
              }), (option) => {
                return openBlock(), createElementBlock("div", null, toDisplayString$1(option[1].label) + " : " + toDisplayString$1(option[1].count > 0 ? (100 / poll.nb_targets * option[1].count).toFixed(2) : 0) + "% ", 1);
              }), 256))
            ]),
            createBaseVNode("div", _hoisted_15$3, [
              createBaseVNode("button", {
                onClick: ($event) => $data.poll_show[key] = $data.poll_show[key] !== void 0 ? !$data.poll_show[key] : true
              }, toDisplayString$1(_ctx.$t("show_poll_results")), 9, _hoisted_16$3),
              createBaseVNode("button", {
                class: "btn-danger",
                onClick: ($event) => $options.finishPoll(key)
              }, toDisplayString$1(_ctx.$t("close_poll")), 9, _hoisted_17$3)
            ])
          ], 2);
        }), 256))
      ])) : createCommentVNode("", true),
      $data.poll_tab === "past" ? (openBlock(), createElementBlock("div", _hoisted_18$3, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.past_polls, (poll, key) => {
          return openBlock(), createElementBlock("div", {
            ref_for: true,
            ref: "past_poll_" + key,
            class: "list-polls poll-past"
          }, [
            createBaseVNode("div", _hoisted_19$3, [
              createBaseVNode("span", _hoisted_20$3, toDisplayString$1(poll.label), 1),
              createBaseVNode("button", {
                class: "see-more",
                onClick: ($event) => $options.toggle_poll(key)
              }, toDisplayString$1(_ctx.$t("see_more")), 9, _hoisted_21$3),
              createBaseVNode("button", {
                class: "btn-danger",
                onClick: ($event) => $options.delete_poll(key)
              }, toDisplayString$1(_ctx.$t("delete")), 9, _hoisted_22$3)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList(Object.entries(poll.options).sort(function(a, b) {
              return b[1].count - a[1].count;
            }), (option) => {
              return openBlock(), createElementBlock("div", null, toDisplayString$1(option[1].label) + " : " + toDisplayString$1(option[1].count > 0 ? (100 / poll.nb_targets * option[1].count).toFixed(2) : 0) + "% ", 1);
            }), 256))
          ], 512);
        }), 256))
      ])) : createCommentVNode("", true)
    ])
  ], 512);
}
const AdminTabPoll = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$6], ["__scopeId", "data-v-7e3c4dd5"]]);
function u(e) {
  return -1 !== [null, void 0, false].indexOf(e);
}
function c(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function p(e) {
  var t = { exports: {} };
  return e(t, t.exports), t.exports;
}
var d = p(function(e, t) {
  e.exports = function() {
    var e2 = ["decimals", "thousand", "mark", "prefix", "suffix", "encoder", "decoder", "negativeBefore", "negative", "edit", "undo"];
    function t2(e3) {
      return e3.split("").reverse().join("");
    }
    function r(e3, t3) {
      return e3.substring(0, t3.length) === t3;
    }
    function i(e3, t3) {
      return e3.slice(-1 * t3.length) === t3;
    }
    function n(e3, t3, r2) {
      if ((e3[t3] || e3[r2]) && e3[t3] === e3[r2])
        throw new Error(t3);
    }
    function o(e3) {
      return "number" == typeof e3 && isFinite(e3);
    }
    function a(e3, t3) {
      return e3 = e3.toString().split("e"), (+((e3 = (e3 = Math.round(+(e3[0] + "e" + (e3[1] ? +e3[1] + t3 : t3)))).toString().split("e"))[0] + "e" + (e3[1] ? +e3[1] - t3 : -t3))).toFixed(t3);
    }
    function s(e3, r2, i2, n2, s2, l2, u3, c3, p3, d2, f2, h2) {
      var m2, v, g, b = h2, y2 = "", S = "";
      return l2 && (h2 = l2(h2)), !!o(h2) && (false !== e3 && 0 === parseFloat(h2.toFixed(e3)) && (h2 = 0), h2 < 0 && (m2 = true, h2 = Math.abs(h2)), false !== e3 && (h2 = a(h2, e3)), -1 !== (h2 = h2.toString()).indexOf(".") ? (g = (v = h2.split("."))[0], i2 && (y2 = i2 + v[1])) : g = h2, r2 && (g = t2(g).match(/.{1,3}/g), g = t2(g.join(t2(r2)))), m2 && c3 && (S += c3), n2 && (S += n2), m2 && p3 && (S += p3), S += g, S += y2, s2 && (S += s2), d2 && (S = d2(S, b)), S);
    }
    function l(e3, t3, n2, a2, s2, l2, u3, c3, p3, d2, f2, h2) {
      var m2, v = "";
      return f2 && (h2 = f2(h2)), !(!h2 || "string" != typeof h2) && (c3 && r(h2, c3) && (h2 = h2.replace(c3, ""), m2 = true), a2 && r(h2, a2) && (h2 = h2.replace(a2, "")), p3 && r(h2, p3) && (h2 = h2.replace(p3, ""), m2 = true), s2 && i(h2, s2) && (h2 = h2.slice(0, -1 * s2.length)), t3 && (h2 = h2.split(t3).join("")), n2 && (h2 = h2.replace(n2, ".")), m2 && (v += "-"), "" !== (v = (v += h2).replace(/[^0-9\.\-.]/g, "")) && (v = Number(v), u3 && (v = u3(v)), !!o(v) && v));
    }
    function u2(t3) {
      var r2, i2, o2, a2 = {};
      for (void 0 === t3.suffix && (t3.suffix = t3.postfix), r2 = 0; r2 < e2.length; r2 += 1)
        if (void 0 === (o2 = t3[i2 = e2[r2]]))
          "negative" !== i2 || a2.negativeBefore ? "mark" === i2 && "." !== a2.thousand ? a2[i2] = "." : a2[i2] = false : a2[i2] = "-";
        else if ("decimals" === i2) {
          if (!(o2 >= 0 && o2 < 8))
            throw new Error(i2);
          a2[i2] = o2;
        } else if ("encoder" === i2 || "decoder" === i2 || "edit" === i2 || "undo" === i2) {
          if ("function" != typeof o2)
            throw new Error(i2);
          a2[i2] = o2;
        } else {
          if ("string" != typeof o2)
            throw new Error(i2);
          a2[i2] = o2;
        }
      return n(a2, "mark", "thousand"), n(a2, "prefix", "negative"), n(a2, "prefix", "negativeBefore"), a2;
    }
    function c2(t3, r2, i2) {
      var n2, o2 = [];
      for (n2 = 0; n2 < e2.length; n2 += 1)
        o2.push(t3[e2[n2]]);
      return o2.push(i2), r2.apply("", o2);
    }
    function p2(e3) {
      if (!(this instanceof p2))
        return new p2(e3);
      "object" == typeof e3 && (e3 = u2(e3), this.to = function(t3) {
        return c2(e3, s, t3);
      }, this.from = function(t3) {
        return c2(e3, l, t3);
      });
    }
    return p2;
  }();
});
var f = c(p(function(e, t) {
  !function(e2) {
    function t2(e3) {
      return r(e3) && "function" == typeof e3.from;
    }
    function r(e3) {
      return "object" == typeof e3 && "function" == typeof e3.to;
    }
    function i(e3) {
      e3.parentElement.removeChild(e3);
    }
    function n(e3) {
      return null != e3;
    }
    function o(e3) {
      e3.preventDefault();
    }
    function a(e3) {
      return e3.filter(function(e4) {
        return !this[e4] && (this[e4] = true);
      }, {});
    }
    function s(e3, t3) {
      return Math.round(e3 / t3) * t3;
    }
    function l(e3, t3) {
      var r2 = e3.getBoundingClientRect(), i2 = e3.ownerDocument, n2 = i2.documentElement, o2 = g(i2);
      return /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (o2.x = 0), t3 ? r2.top + o2.y - n2.clientTop : r2.left + o2.x - n2.clientLeft;
    }
    function u2(e3) {
      return "number" == typeof e3 && !isNaN(e3) && isFinite(e3);
    }
    function c2(e3, t3, r2) {
      r2 > 0 && (h2(e3, t3), setTimeout(function() {
        m2(e3, t3);
      }, r2));
    }
    function p2(e3) {
      return Math.max(Math.min(e3, 100), 0);
    }
    function d2(e3) {
      return Array.isArray(e3) ? e3 : [e3];
    }
    function f2(e3) {
      var t3 = (e3 = String(e3)).split(".");
      return t3.length > 1 ? t3[1].length : 0;
    }
    function h2(e3, t3) {
      e3.classList && !/\s/.test(t3) ? e3.classList.add(t3) : e3.className += " " + t3;
    }
    function m2(e3, t3) {
      e3.classList && !/\s/.test(t3) ? e3.classList.remove(t3) : e3.className = e3.className.replace(new RegExp("(^|\\b)" + t3.split(" ").join("|") + "(\\b|$)", "gi"), " ");
    }
    function v(e3, t3) {
      return e3.classList ? e3.classList.contains(t3) : new RegExp("\\b" + t3 + "\\b").test(e3.className);
    }
    function g(e3) {
      var t3 = void 0 !== window.pageXOffset, r2 = "CSS1Compat" === (e3.compatMode || "");
      return { x: t3 ? window.pageXOffset : r2 ? e3.documentElement.scrollLeft : e3.body.scrollLeft, y: t3 ? window.pageYOffset : r2 ? e3.documentElement.scrollTop : e3.body.scrollTop };
    }
    function b() {
      return window.navigator.pointerEnabled ? { start: "pointerdown", move: "pointermove", end: "pointerup" } : window.navigator.msPointerEnabled ? { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" } : { start: "mousedown touchstart", move: "mousemove touchmove", end: "mouseup touchend" };
    }
    function y2() {
      var e3 = false;
      try {
        var t3 = Object.defineProperty({}, "passive", { get: function() {
          e3 = true;
        } });
        window.addEventListener("test", null, t3);
      } catch (e4) {
      }
      return e3;
    }
    function S() {
      return window.CSS && CSS.supports && CSS.supports("touch-action", "none");
    }
    function x(e3, t3) {
      return 100 / (t3 - e3);
    }
    function w(e3, t3, r2) {
      return 100 * t3 / (e3[r2 + 1] - e3[r2]);
    }
    function E(e3, t3) {
      return w(e3, e3[0] < 0 ? t3 + Math.abs(e3[0]) : t3 - e3[0], 0);
    }
    function P(e3, t3) {
      return t3 * (e3[1] - e3[0]) / 100 + e3[0];
    }
    function N(e3, t3) {
      for (var r2 = 1; e3 >= t3[r2]; )
        r2 += 1;
      return r2;
    }
    function C(e3, t3, r2) {
      if (r2 >= e3.slice(-1)[0])
        return 100;
      var i2 = N(r2, e3), n2 = e3[i2 - 1], o2 = e3[i2], a2 = t3[i2 - 1], s2 = t3[i2];
      return a2 + E([n2, o2], r2) / x(a2, s2);
    }
    function k(e3, t3, r2) {
      if (r2 >= 100)
        return e3.slice(-1)[0];
      var i2 = N(r2, t3), n2 = e3[i2 - 1], o2 = e3[i2], a2 = t3[i2 - 1];
      return P([n2, o2], (r2 - a2) * x(a2, t3[i2]));
    }
    function V2(e3, t3, r2, i2) {
      if (100 === i2)
        return i2;
      var n2 = N(i2, e3), o2 = e3[n2 - 1], a2 = e3[n2];
      return r2 ? i2 - o2 > (a2 - o2) / 2 ? a2 : o2 : t3[n2 - 1] ? e3[n2 - 1] + s(i2 - e3[n2 - 1], t3[n2 - 1]) : i2;
    }
    var A, M;
    e2.PipsMode = void 0, (M = e2.PipsMode || (e2.PipsMode = {})).Range = "range", M.Steps = "steps", M.Positions = "positions", M.Count = "count", M.Values = "values", e2.PipsType = void 0, (A = e2.PipsType || (e2.PipsType = {}))[A.None = -1] = "None", A[A.NoValue = 0] = "NoValue", A[A.LargeValue = 1] = "LargeValue", A[A.SmallValue = 2] = "SmallValue";
    var L = function() {
      function e3(e4, t3, r2) {
        var i2;
        this.xPct = [], this.xVal = [], this.xSteps = [], this.xNumSteps = [], this.xHighestCompleteStep = [], this.xSteps = [r2 || false], this.xNumSteps = [false], this.snap = t3;
        var n2 = [];
        for (Object.keys(e4).forEach(function(t4) {
          n2.push([d2(e4[t4]), t4]);
        }), n2.sort(function(e5, t4) {
          return e5[0][0] - t4[0][0];
        }), i2 = 0; i2 < n2.length; i2++)
          this.handleEntryPoint(n2[i2][1], n2[i2][0]);
        for (this.xNumSteps = this.xSteps.slice(0), i2 = 0; i2 < this.xNumSteps.length; i2++)
          this.handleStepPoint(i2, this.xNumSteps[i2]);
      }
      return e3.prototype.getDistance = function(e4) {
        for (var t3 = [], r2 = 0; r2 < this.xNumSteps.length - 1; r2++)
          t3[r2] = w(this.xVal, e4, r2);
        return t3;
      }, e3.prototype.getAbsoluteDistance = function(e4, t3, r2) {
        var i2, n2 = 0;
        if (e4 < this.xPct[this.xPct.length - 1])
          for (; e4 > this.xPct[n2 + 1]; )
            n2++;
        else
          e4 === this.xPct[this.xPct.length - 1] && (n2 = this.xPct.length - 2);
        r2 || e4 !== this.xPct[n2 + 1] || n2++, null === t3 && (t3 = []);
        var o2 = 1, a2 = t3[n2], s2 = 0, l2 = 0, u3 = 0, c3 = 0;
        for (i2 = r2 ? (e4 - this.xPct[n2]) / (this.xPct[n2 + 1] - this.xPct[n2]) : (this.xPct[n2 + 1] - e4) / (this.xPct[n2 + 1] - this.xPct[n2]); a2 > 0; )
          s2 = this.xPct[n2 + 1 + c3] - this.xPct[n2 + c3], t3[n2 + c3] * o2 + 100 - 100 * i2 > 100 ? (l2 = s2 * i2, o2 = (a2 - 100 * i2) / t3[n2 + c3], i2 = 1) : (l2 = t3[n2 + c3] * s2 / 100 * o2, o2 = 0), r2 ? (u3 -= l2, this.xPct.length + c3 >= 1 && c3--) : (u3 += l2, this.xPct.length - c3 >= 1 && c3++), a2 = t3[n2 + c3] * o2;
        return e4 + u3;
      }, e3.prototype.toStepping = function(e4) {
        return e4 = C(this.xVal, this.xPct, e4);
      }, e3.prototype.fromStepping = function(e4) {
        return k(this.xVal, this.xPct, e4);
      }, e3.prototype.getStep = function(e4) {
        return e4 = V2(this.xPct, this.xSteps, this.snap, e4);
      }, e3.prototype.getDefaultStep = function(e4, t3, r2) {
        var i2 = N(e4, this.xPct);
        return (100 === e4 || t3 && e4 === this.xPct[i2 - 1]) && (i2 = Math.max(i2 - 1, 1)), (this.xVal[i2] - this.xVal[i2 - 1]) / r2;
      }, e3.prototype.getNearbySteps = function(e4) {
        var t3 = N(e4, this.xPct);
        return { stepBefore: { startValue: this.xVal[t3 - 2], step: this.xNumSteps[t3 - 2], highestStep: this.xHighestCompleteStep[t3 - 2] }, thisStep: { startValue: this.xVal[t3 - 1], step: this.xNumSteps[t3 - 1], highestStep: this.xHighestCompleteStep[t3 - 1] }, stepAfter: { startValue: this.xVal[t3], step: this.xNumSteps[t3], highestStep: this.xHighestCompleteStep[t3] } };
      }, e3.prototype.countStepDecimals = function() {
        var e4 = this.xNumSteps.map(f2);
        return Math.max.apply(null, e4);
      }, e3.prototype.hasNoSize = function() {
        return this.xVal[0] === this.xVal[this.xVal.length - 1];
      }, e3.prototype.convert = function(e4) {
        return this.getStep(this.toStepping(e4));
      }, e3.prototype.handleEntryPoint = function(e4, t3) {
        var r2;
        if (!u2(r2 = "min" === e4 ? 0 : "max" === e4 ? 100 : parseFloat(e4)) || !u2(t3[0]))
          throw new Error("noUiSlider: 'range' value isn't numeric.");
        this.xPct.push(r2), this.xVal.push(t3[0]);
        var i2 = Number(t3[1]);
        r2 ? this.xSteps.push(!isNaN(i2) && i2) : isNaN(i2) || (this.xSteps[0] = i2), this.xHighestCompleteStep.push(0);
      }, e3.prototype.handleStepPoint = function(e4, t3) {
        if (t3)
          if (this.xVal[e4] !== this.xVal[e4 + 1]) {
            this.xSteps[e4] = w([this.xVal[e4], this.xVal[e4 + 1]], t3, 0) / x(this.xPct[e4], this.xPct[e4 + 1]);
            var r2 = (this.xVal[e4 + 1] - this.xVal[e4]) / this.xNumSteps[e4], i2 = Math.ceil(Number(r2.toFixed(3)) - 1), n2 = this.xVal[e4] + this.xNumSteps[e4] * i2;
            this.xHighestCompleteStep[e4] = n2;
          } else
            this.xSteps[e4] = this.xHighestCompleteStep[e4] = this.xVal[e4];
      }, e3;
    }(), U2 = { to: function(e3) {
      return void 0 === e3 ? "" : e3.toFixed(2);
    }, from: Number }, O2 = { target: "target", base: "base", origin: "origin", handle: "handle", handleLower: "handle-lower", handleUpper: "handle-upper", touchArea: "touch-area", horizontal: "horizontal", vertical: "vertical", background: "background", connect: "connect", connects: "connects", ltr: "ltr", rtl: "rtl", textDirectionLtr: "txt-dir-ltr", textDirectionRtl: "txt-dir-rtl", draggable: "draggable", drag: "state-drag", tap: "state-tap", active: "active", tooltip: "tooltip", pips: "pips", pipsHorizontal: "pips-horizontal", pipsVertical: "pips-vertical", marker: "marker", markerHorizontal: "marker-horizontal", markerVertical: "marker-vertical", markerNormal: "marker-normal", markerLarge: "marker-large", markerSub: "marker-sub", value: "value", valueHorizontal: "value-horizontal", valueVertical: "value-vertical", valueNormal: "value-normal", valueLarge: "value-large", valueSub: "value-sub" }, D = { tooltips: ".__tooltips", aria: ".__aria" };
    function j(e3, t3) {
      if (!u2(t3))
        throw new Error("noUiSlider: 'step' is not numeric.");
      e3.singleStep = t3;
    }
    function F(e3, t3) {
      if (!u2(t3))
        throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
      e3.keyboardPageMultiplier = t3;
    }
    function T(e3, t3) {
      if (!u2(t3))
        throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
      e3.keyboardMultiplier = t3;
    }
    function z2(e3, t3) {
      if (!u2(t3))
        throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
      e3.keyboardDefaultStep = t3;
    }
    function H2(e3, t3) {
      if ("object" != typeof t3 || Array.isArray(t3))
        throw new Error("noUiSlider: 'range' is not an object.");
      if (void 0 === t3.min || void 0 === t3.max)
        throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
      e3.spectrum = new L(t3, e3.snap || false, e3.singleStep);
    }
    function q2(e3, t3) {
      if (t3 = d2(t3), !Array.isArray(t3) || !t3.length)
        throw new Error("noUiSlider: 'start' option is incorrect.");
      e3.handles = t3.length, e3.start = t3;
    }
    function R(e3, t3) {
      if ("boolean" != typeof t3)
        throw new Error("noUiSlider: 'snap' option must be a boolean.");
      e3.snap = t3;
    }
    function B(e3, t3) {
      if ("boolean" != typeof t3)
        throw new Error("noUiSlider: 'animate' option must be a boolean.");
      e3.animate = t3;
    }
    function _(e3, t3) {
      if ("number" != typeof t3)
        throw new Error("noUiSlider: 'animationDuration' option must be a number.");
      e3.animationDuration = t3;
    }
    function $(e3, t3) {
      var r2, i2 = [false];
      if ("lower" === t3 ? t3 = [true, false] : "upper" === t3 && (t3 = [false, true]), true === t3 || false === t3) {
        for (r2 = 1; r2 < e3.handles; r2++)
          i2.push(t3);
        i2.push(false);
      } else {
        if (!Array.isArray(t3) || !t3.length || t3.length !== e3.handles + 1)
          throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
        i2 = t3;
      }
      e3.connect = i2;
    }
    function X2(e3, t3) {
      switch (t3) {
        case "horizontal":
          e3.ort = 0;
          break;
        case "vertical":
          e3.ort = 1;
          break;
        default:
          throw new Error("noUiSlider: 'orientation' option is invalid.");
      }
    }
    function Y2(e3, t3) {
      if (!u2(t3))
        throw new Error("noUiSlider: 'margin' option must be numeric.");
      0 !== t3 && (e3.margin = e3.spectrum.getDistance(t3));
    }
    function I(e3, t3) {
      if (!u2(t3))
        throw new Error("noUiSlider: 'limit' option must be numeric.");
      if (e3.limit = e3.spectrum.getDistance(t3), !e3.limit || e3.handles < 2)
        throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.");
    }
    function W2(e3, t3) {
      var r2;
      if (!u2(t3) && !Array.isArray(t3))
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
      if (Array.isArray(t3) && 2 !== t3.length && !u2(t3[0]) && !u2(t3[1]))
        throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
      if (0 !== t3) {
        for (Array.isArray(t3) || (t3 = [t3, t3]), e3.padding = [e3.spectrum.getDistance(t3[0]), e3.spectrum.getDistance(t3[1])], r2 = 0; r2 < e3.spectrum.xNumSteps.length - 1; r2++)
          if (e3.padding[0][r2] < 0 || e3.padding[1][r2] < 0)
            throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
        var i2 = t3[0] + t3[1], n2 = e3.spectrum.xVal[0];
        if (i2 / (e3.spectrum.xVal[e3.spectrum.xVal.length - 1] - n2) > 1)
          throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.");
      }
    }
    function G2(e3, t3) {
      switch (t3) {
        case "ltr":
          e3.dir = 0;
          break;
        case "rtl":
          e3.dir = 1;
          break;
        default:
          throw new Error("noUiSlider: 'direction' option was not recognized.");
      }
    }
    function J2(e3, t3) {
      if ("string" != typeof t3)
        throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
      var r2 = t3.indexOf("tap") >= 0, i2 = t3.indexOf("drag") >= 0, n2 = t3.indexOf("fixed") >= 0, o2 = t3.indexOf("snap") >= 0, a2 = t3.indexOf("hover") >= 0, s2 = t3.indexOf("unconstrained") >= 0, l2 = t3.indexOf("drag-all") >= 0, u3 = t3.indexOf("smooth-steps") >= 0;
      if (n2) {
        if (2 !== e3.handles)
          throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
        Y2(e3, e3.start[1] - e3.start[0]);
      }
      if (s2 && (e3.margin || e3.limit))
        throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
      e3.events = { tap: r2 || o2, drag: i2, dragAll: l2, smoothSteps: u3, fixed: n2, snap: o2, hover: a2, unconstrained: s2 };
    }
    function K(e3, t3) {
      if (false !== t3)
        if (true === t3 || r(t3)) {
          e3.tooltips = [];
          for (var i2 = 0; i2 < e3.handles; i2++)
            e3.tooltips.push(t3);
        } else {
          if ((t3 = d2(t3)).length !== e3.handles)
            throw new Error("noUiSlider: must pass a formatter for all handles.");
          t3.forEach(function(e4) {
            if ("boolean" != typeof e4 && !r(e4))
              throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.");
          }), e3.tooltips = t3;
        }
    }
    function Q2(e3, t3) {
      if (t3.length !== e3.handles)
        throw new Error("noUiSlider: must pass a attributes for all handles.");
      e3.handleAttributes = t3;
    }
    function Z2(e3, t3) {
      if (!r(t3))
        throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
      e3.ariaFormat = t3;
    }
    function ee(e3, r2) {
      if (!t2(r2))
        throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
      e3.format = r2;
    }
    function te2(e3, t3) {
      if ("boolean" != typeof t3)
        throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
      e3.keyboardSupport = t3;
    }
    function re(e3, t3) {
      e3.documentElement = t3;
    }
    function ie2(e3, t3) {
      if ("string" != typeof t3 && false !== t3)
        throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
      e3.cssPrefix = t3;
    }
    function ne(e3, t3) {
      if ("object" != typeof t3)
        throw new Error("noUiSlider: 'cssClasses' must be an object.");
      "string" == typeof e3.cssPrefix ? (e3.cssClasses = {}, Object.keys(t3).forEach(function(r2) {
        e3.cssClasses[r2] = e3.cssPrefix + t3[r2];
      })) : e3.cssClasses = t3;
    }
    function oe2(e3) {
      var t3 = { margin: null, limit: null, padding: null, animate: true, animationDuration: 300, ariaFormat: U2, format: U2 }, r2 = { step: { r: false, t: j }, keyboardPageMultiplier: { r: false, t: F }, keyboardMultiplier: { r: false, t: T }, keyboardDefaultStep: { r: false, t: z2 }, start: { r: true, t: q2 }, connect: { r: true, t: $ }, direction: { r: true, t: G2 }, snap: { r: false, t: R }, animate: { r: false, t: B }, animationDuration: { r: false, t: _ }, range: { r: true, t: H2 }, orientation: { r: false, t: X2 }, margin: { r: false, t: Y2 }, limit: { r: false, t: I }, padding: { r: false, t: W2 }, behaviour: { r: true, t: J2 }, ariaFormat: { r: false, t: Z2 }, format: { r: false, t: ee }, tooltips: { r: false, t: K }, keyboardSupport: { r: true, t: te2 }, documentElement: { r: false, t: re }, cssPrefix: { r: true, t: ie2 }, cssClasses: { r: true, t: ne }, handleAttributes: { r: false, t: Q2 } }, i2 = { connect: false, direction: "ltr", behaviour: "tap", orientation: "horizontal", keyboardSupport: true, cssPrefix: "noUi-", cssClasses: O2, keyboardPageMultiplier: 5, keyboardMultiplier: 1, keyboardDefaultStep: 10 };
      e3.format && !e3.ariaFormat && (e3.ariaFormat = e3.format), Object.keys(r2).forEach(function(o3) {
        if (n(e3[o3]) || void 0 !== i2[o3])
          r2[o3].t(t3, n(e3[o3]) ? e3[o3] : i2[o3]);
        else if (r2[o3].r)
          throw new Error("noUiSlider: '" + o3 + "' is required.");
      }), t3.pips = e3.pips;
      var o2 = document.createElement("div"), a2 = void 0 !== o2.style.msTransform, s2 = void 0 !== o2.style.transform;
      t3.transformRule = s2 ? "transform" : a2 ? "msTransform" : "webkitTransform";
      var l2 = [["left", "top"], ["right", "bottom"]];
      return t3.style = l2[t3.dir][t3.ort], t3;
    }
    function ae(t3, r2, s2) {
      var u3, f3, x2, w2, E2, P2 = b(), N2 = S() && y2(), C2 = t3, k2 = r2.spectrum, V3 = [], A2 = [], M2 = [], L2 = 0, U3 = {}, O3 = t3.ownerDocument, j2 = r2.documentElement || O3.documentElement, F2 = O3.body, T2 = "rtl" === O3.dir || 1 === r2.ort ? 0 : 100;
      function z3(e3, t4) {
        var r3 = O3.createElement("div");
        return t4 && h2(r3, t4), e3.appendChild(r3), r3;
      }
      function H3(e3, t4) {
        var i2 = z3(e3, r2.cssClasses.origin), n2 = z3(i2, r2.cssClasses.handle);
        if (z3(n2, r2.cssClasses.touchArea), n2.setAttribute("data-handle", String(t4)), r2.keyboardSupport && (n2.setAttribute("tabindex", "0"), n2.addEventListener("keydown", function(e4) {
          return fe2(e4, t4);
        })), void 0 !== r2.handleAttributes) {
          var o2 = r2.handleAttributes[t4];
          Object.keys(o2).forEach(function(e4) {
            n2.setAttribute(e4, o2[e4]);
          });
        }
        return n2.setAttribute("role", "slider"), n2.setAttribute("aria-orientation", r2.ort ? "vertical" : "horizontal"), 0 === t4 ? h2(n2, r2.cssClasses.handleLower) : t4 === r2.handles - 1 && h2(n2, r2.cssClasses.handleUpper), i2;
      }
      function q3(e3, t4) {
        return !!t4 && z3(e3, r2.cssClasses.connect);
      }
      function R2(e3, t4) {
        var i2 = z3(t4, r2.cssClasses.connects);
        f3 = [], (x2 = []).push(q3(i2, e3[0]));
        for (var n2 = 0; n2 < r2.handles; n2++)
          f3.push(H3(t4, n2)), M2[n2] = n2, x2.push(q3(i2, e3[n2 + 1]));
      }
      function B2(e3) {
        return h2(e3, r2.cssClasses.target), 0 === r2.dir ? h2(e3, r2.cssClasses.ltr) : h2(e3, r2.cssClasses.rtl), 0 === r2.ort ? h2(e3, r2.cssClasses.horizontal) : h2(e3, r2.cssClasses.vertical), h2(e3, "rtl" === getComputedStyle(e3).direction ? r2.cssClasses.textDirectionRtl : r2.cssClasses.textDirectionLtr), z3(e3, r2.cssClasses.base);
      }
      function _2(e3, t4) {
        return !(!r2.tooltips || !r2.tooltips[t4]) && z3(e3.firstChild, r2.cssClasses.tooltip);
      }
      function $2() {
        return C2.hasAttribute("disabled");
      }
      function X3(e3) {
        return f3[e3].hasAttribute("disabled");
      }
      function Y3() {
        E2 && (ge2("update" + D.tooltips), E2.forEach(function(e3) {
          e3 && i(e3);
        }), E2 = null);
      }
      function I2() {
        Y3(), E2 = f3.map(_2), me2("update" + D.tooltips, function(e3, t4, i2) {
          if (E2 && r2.tooltips && false !== E2[t4]) {
            var n2 = e3[t4];
            true !== r2.tooltips[t4] && (n2 = r2.tooltips[t4].to(i2[t4])), E2[t4].innerHTML = n2;
          }
        });
      }
      function W3() {
        ge2("update" + D.aria), me2("update" + D.aria, function(e3, t4, i2, n2, o2) {
          M2.forEach(function(e4) {
            var t5 = f3[e4], n3 = ye2(A2, e4, 0, true, true, true), a2 = ye2(A2, e4, 100, true, true, true), s3 = o2[e4], l2 = String(r2.ariaFormat.to(i2[e4]));
            n3 = k2.fromStepping(n3).toFixed(1), a2 = k2.fromStepping(a2).toFixed(1), s3 = k2.fromStepping(s3).toFixed(1), t5.children[0].setAttribute("aria-valuemin", n3), t5.children[0].setAttribute("aria-valuemax", a2), t5.children[0].setAttribute("aria-valuenow", s3), t5.children[0].setAttribute("aria-valuetext", l2);
          });
        });
      }
      function G3(t4) {
        if (t4.mode === e2.PipsMode.Range || t4.mode === e2.PipsMode.Steps)
          return k2.xVal;
        if (t4.mode === e2.PipsMode.Count) {
          if (t4.values < 2)
            throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
          for (var r3 = t4.values - 1, i2 = 100 / r3, n2 = []; r3--; )
            n2[r3] = r3 * i2;
          return n2.push(100), J3(n2, t4.stepped);
        }
        return t4.mode === e2.PipsMode.Positions ? J3(t4.values, t4.stepped) : t4.mode === e2.PipsMode.Values ? t4.stepped ? t4.values.map(function(e3) {
          return k2.fromStepping(k2.getStep(k2.toStepping(e3)));
        }) : t4.values : [];
      }
      function J3(e3, t4) {
        return e3.map(function(e4) {
          return k2.fromStepping(t4 ? k2.getStep(e4) : e4);
        });
      }
      function K2(t4) {
        function r3(e3, t5) {
          return Number((e3 + t5).toFixed(7));
        }
        var i2 = G3(t4), n2 = {}, o2 = k2.xVal[0], s3 = k2.xVal[k2.xVal.length - 1], l2 = false, u4 = false, c3 = 0;
        return (i2 = a(i2.slice().sort(function(e3, t5) {
          return e3 - t5;
        })))[0] !== o2 && (i2.unshift(o2), l2 = true), i2[i2.length - 1] !== s3 && (i2.push(s3), u4 = true), i2.forEach(function(o3, a2) {
          var s4, p3, d3, f4, h3, m3, v2, g2, b2, y3, S2 = o3, x3 = i2[a2 + 1], w3 = t4.mode === e2.PipsMode.Steps;
          for (w3 && (s4 = k2.xNumSteps[a2]), s4 || (s4 = x3 - S2), void 0 === x3 && (x3 = S2), s4 = Math.max(s4, 1e-7), p3 = S2; p3 <= x3; p3 = r3(p3, s4)) {
            for (g2 = (h3 = (f4 = k2.toStepping(p3)) - c3) / (t4.density || 1), y3 = h3 / (b2 = Math.round(g2)), d3 = 1; d3 <= b2; d3 += 1)
              n2[(m3 = c3 + d3 * y3).toFixed(5)] = [k2.fromStepping(m3), 0];
            v2 = i2.indexOf(p3) > -1 ? e2.PipsType.LargeValue : w3 ? e2.PipsType.SmallValue : e2.PipsType.NoValue, !a2 && l2 && p3 !== x3 && (v2 = 0), p3 === x3 && u4 || (n2[f4.toFixed(5)] = [p3, v2]), c3 = f4;
          }
        }), n2;
      }
      function Q3(t4, i2, n2) {
        var o2, a2, s3 = O3.createElement("div"), l2 = ((o2 = {})[e2.PipsType.None] = "", o2[e2.PipsType.NoValue] = r2.cssClasses.valueNormal, o2[e2.PipsType.LargeValue] = r2.cssClasses.valueLarge, o2[e2.PipsType.SmallValue] = r2.cssClasses.valueSub, o2), u4 = ((a2 = {})[e2.PipsType.None] = "", a2[e2.PipsType.NoValue] = r2.cssClasses.markerNormal, a2[e2.PipsType.LargeValue] = r2.cssClasses.markerLarge, a2[e2.PipsType.SmallValue] = r2.cssClasses.markerSub, a2), c3 = [r2.cssClasses.valueHorizontal, r2.cssClasses.valueVertical], p3 = [r2.cssClasses.markerHorizontal, r2.cssClasses.markerVertical];
        function d3(e3, t5) {
          var i3 = t5 === r2.cssClasses.value, n3 = i3 ? l2 : u4;
          return t5 + " " + (i3 ? c3 : p3)[r2.ort] + " " + n3[e3];
        }
        function f4(t5, o3, a3) {
          if ((a3 = i2 ? i2(o3, a3) : a3) !== e2.PipsType.None) {
            var l3 = z3(s3, false);
            l3.className = d3(a3, r2.cssClasses.marker), l3.style[r2.style] = t5 + "%", a3 > e2.PipsType.NoValue && ((l3 = z3(s3, false)).className = d3(a3, r2.cssClasses.value), l3.setAttribute("data-value", String(o3)), l3.style[r2.style] = t5 + "%", l3.innerHTML = String(n2.to(o3)));
          }
        }
        return h2(s3, r2.cssClasses.pips), h2(s3, 0 === r2.ort ? r2.cssClasses.pipsHorizontal : r2.cssClasses.pipsVertical), Object.keys(t4).forEach(function(e3) {
          f4(e3, t4[e3][0], t4[e3][1]);
        }), s3;
      }
      function Z3() {
        w2 && (i(w2), w2 = null);
      }
      function ee2(e3) {
        Z3();
        var t4 = K2(e3), r3 = e3.filter, i2 = e3.format || { to: function(e4) {
          return String(Math.round(e4));
        } };
        return w2 = C2.appendChild(Q3(t4, r3, i2));
      }
      function te3() {
        var e3 = u3.getBoundingClientRect(), t4 = "offset" + ["Width", "Height"][r2.ort];
        return 0 === r2.ort ? e3.width || u3[t4] : e3.height || u3[t4];
      }
      function re2(e3, t4, i2, n2) {
        var o2 = function(o3) {
          var a3 = ie3(o3, n2.pageOffset, n2.target || t4);
          return !!a3 && !($2() && !n2.doNotReject) && !(v(C2, r2.cssClasses.tap) && !n2.doNotReject) && !(e3 === P2.start && void 0 !== a3.buttons && a3.buttons > 1) && (!n2.hover || !a3.buttons) && (N2 || a3.preventDefault(), a3.calcPoint = a3.points[r2.ort], void i2(a3, n2));
        }, a2 = [];
        return e3.split(" ").forEach(function(e4) {
          t4.addEventListener(e4, o2, !!N2 && { passive: true }), a2.push([e4, o2]);
        }), a2;
      }
      function ie3(e3, t4, r3) {
        var i2 = 0 === e3.type.indexOf("touch"), n2 = 0 === e3.type.indexOf("mouse"), o2 = 0 === e3.type.indexOf("pointer"), a2 = 0, s3 = 0;
        if (0 === e3.type.indexOf("MSPointer") && (o2 = true), "mousedown" === e3.type && !e3.buttons && !e3.touches)
          return false;
        if (i2) {
          var l2 = function(t5) {
            var i3 = t5.target;
            return i3 === r3 || r3.contains(i3) || e3.composed && e3.composedPath().shift() === r3;
          };
          if ("touchstart" === e3.type) {
            var u4 = Array.prototype.filter.call(e3.touches, l2);
            if (u4.length > 1)
              return false;
            a2 = u4[0].pageX, s3 = u4[0].pageY;
          } else {
            var c3 = Array.prototype.find.call(e3.changedTouches, l2);
            if (!c3)
              return false;
            a2 = c3.pageX, s3 = c3.pageY;
          }
        }
        return t4 = t4 || g(O3), (n2 || o2) && (a2 = e3.clientX + t4.x, s3 = e3.clientY + t4.y), e3.pageOffset = t4, e3.points = [a2, s3], e3.cursor = n2 || o2, e3;
      }
      function ne2(e3) {
        var t4 = 100 * (e3 - l(u3, r2.ort)) / te3();
        return t4 = p2(t4), r2.dir ? 100 - t4 : t4;
      }
      function ae2(e3) {
        var t4 = 100, r3 = false;
        return f3.forEach(function(i2, n2) {
          if (!X3(n2)) {
            var o2 = A2[n2], a2 = Math.abs(o2 - e3);
            (a2 < t4 || a2 <= t4 && e3 > o2 || 100 === a2 && 100 === t4) && (r3 = n2, t4 = a2);
          }
        }), r3;
      }
      function se3(e3, t4) {
        "mouseout" === e3.type && "HTML" === e3.target.nodeName && null === e3.relatedTarget && ue2(e3, t4);
      }
      function le3(e3, t4) {
        if (-1 === navigator.appVersion.indexOf("MSIE 9") && 0 === e3.buttons && 0 !== t4.buttonsProperty)
          return ue2(e3, t4);
        var i2 = (r2.dir ? -1 : 1) * (e3.calcPoint - t4.startCalcPoint);
        xe(i2 > 0, 100 * i2 / t4.baseSize, t4.locations, t4.handleNumbers, t4.connect);
      }
      function ue2(e3, t4) {
        t4.handle && (m2(t4.handle, r2.cssClasses.active), L2 -= 1), t4.listeners.forEach(function(e4) {
          j2.removeEventListener(e4[0], e4[1]);
        }), 0 === L2 && (m2(C2, r2.cssClasses.drag), Pe2(), e3.cursor && (F2.style.cursor = "", F2.removeEventListener("selectstart", o))), r2.events.smoothSteps && (t4.handleNumbers.forEach(function(e4) {
          Ne(e4, A2[e4], true, true, false, false);
        }), t4.handleNumbers.forEach(function(e4) {
          be2("update", e4);
        })), t4.handleNumbers.forEach(function(e4) {
          be2("change", e4), be2("set", e4), be2("end", e4);
        });
      }
      function ce2(e3, t4) {
        if (!t4.handleNumbers.some(X3)) {
          var i2;
          1 === t4.handleNumbers.length && (i2 = f3[t4.handleNumbers[0]].children[0], L2 += 1, h2(i2, r2.cssClasses.active)), e3.stopPropagation();
          var n2 = [], a2 = re2(P2.move, j2, le3, { target: e3.target, handle: i2, connect: t4.connect, listeners: n2, startCalcPoint: e3.calcPoint, baseSize: te3(), pageOffset: e3.pageOffset, handleNumbers: t4.handleNumbers, buttonsProperty: e3.buttons, locations: A2.slice() }), s3 = re2(P2.end, j2, ue2, { target: e3.target, handle: i2, listeners: n2, doNotReject: true, handleNumbers: t4.handleNumbers }), l2 = re2("mouseout", j2, se3, { target: e3.target, handle: i2, listeners: n2, doNotReject: true, handleNumbers: t4.handleNumbers });
          n2.push.apply(n2, a2.concat(s3, l2)), e3.cursor && (F2.style.cursor = getComputedStyle(e3.target).cursor, f3.length > 1 && h2(C2, r2.cssClasses.drag), F2.addEventListener("selectstart", o, false)), t4.handleNumbers.forEach(function(e4) {
            be2("start", e4);
          });
        }
      }
      function pe2(e3) {
        e3.stopPropagation();
        var t4 = ne2(e3.calcPoint), i2 = ae2(t4);
        false !== i2 && (r2.events.snap || c2(C2, r2.cssClasses.tap, r2.animationDuration), Ne(i2, t4, true, true), Pe2(), be2("slide", i2, true), be2("update", i2, true), r2.events.snap ? ce2(e3, { handleNumbers: [i2] }) : (be2("change", i2, true), be2("set", i2, true)));
      }
      function de2(e3) {
        var t4 = ne2(e3.calcPoint), r3 = k2.getStep(t4), i2 = k2.fromStepping(r3);
        Object.keys(U3).forEach(function(e4) {
          "hover" === e4.split(".")[0] && U3[e4].forEach(function(e5) {
            e5.call(Te, i2);
          });
        });
      }
      function fe2(e3, t4) {
        if ($2() || X3(t4))
          return false;
        var i2 = ["Left", "Right"], n2 = ["Down", "Up"], o2 = ["PageDown", "PageUp"], a2 = ["Home", "End"];
        r2.dir && !r2.ort ? i2.reverse() : r2.ort && !r2.dir && (n2.reverse(), o2.reverse());
        var s3, l2 = e3.key.replace("Arrow", ""), u4 = l2 === o2[0], c3 = l2 === o2[1], p3 = l2 === n2[0] || l2 === i2[0] || u4, d3 = l2 === n2[1] || l2 === i2[1] || c3, f4 = l2 === a2[0], h3 = l2 === a2[1];
        if (!(p3 || d3 || f4 || h3))
          return true;
        if (e3.preventDefault(), d3 || p3) {
          var m3 = p3 ? 0 : 1, v2 = Oe(t4)[m3];
          if (null === v2)
            return false;
          false === v2 && (v2 = k2.getDefaultStep(A2[t4], p3, r2.keyboardDefaultStep)), v2 *= c3 || u4 ? r2.keyboardPageMultiplier : r2.keyboardMultiplier, v2 = Math.max(v2, 1e-7), v2 *= p3 ? -1 : 1, s3 = V3[t4] + v2;
        } else
          s3 = h3 ? r2.spectrum.xVal[r2.spectrum.xVal.length - 1] : r2.spectrum.xVal[0];
        return Ne(t4, k2.toStepping(s3), true, true), be2("slide", t4), be2("update", t4), be2("change", t4), be2("set", t4), false;
      }
      function he2(e3) {
        e3.fixed || f3.forEach(function(e4, t4) {
          re2(P2.start, e4.children[0], ce2, { handleNumbers: [t4] });
        }), e3.tap && re2(P2.start, u3, pe2, {}), e3.hover && re2(P2.move, u3, de2, { hover: true }), e3.drag && x2.forEach(function(t4, i2) {
          if (false !== t4 && 0 !== i2 && i2 !== x2.length - 1) {
            var n2 = f3[i2 - 1], o2 = f3[i2], a2 = [t4], s3 = [n2, o2], l2 = [i2 - 1, i2];
            h2(t4, r2.cssClasses.draggable), e3.fixed && (a2.push(n2.children[0]), a2.push(o2.children[0])), e3.dragAll && (s3 = f3, l2 = M2), a2.forEach(function(e4) {
              re2(P2.start, e4, ce2, { handles: s3, handleNumbers: l2, connect: t4 });
            });
          }
        });
      }
      function me2(e3, t4) {
        U3[e3] = U3[e3] || [], U3[e3].push(t4), "update" === e3.split(".")[0] && f3.forEach(function(e4, t5) {
          be2("update", t5);
        });
      }
      function ve2(e3) {
        return e3 === D.aria || e3 === D.tooltips;
      }
      function ge2(e3) {
        var t4 = e3 && e3.split(".")[0], r3 = t4 ? e3.substring(t4.length) : e3;
        Object.keys(U3).forEach(function(e4) {
          var i2 = e4.split(".")[0], n2 = e4.substring(i2.length);
          t4 && t4 !== i2 || r3 && r3 !== n2 || ve2(n2) && r3 !== n2 || delete U3[e4];
        });
      }
      function be2(e3, t4, i2) {
        Object.keys(U3).forEach(function(n2) {
          var o2 = n2.split(".")[0];
          e3 === o2 && U3[n2].forEach(function(e4) {
            e4.call(Te, V3.map(r2.format.to), t4, V3.slice(), i2 || false, A2.slice(), Te);
          });
        });
      }
      function ye2(e3, t4, i2, n2, o2, a2, s3) {
        var l2;
        return f3.length > 1 && !r2.events.unconstrained && (n2 && t4 > 0 && (l2 = k2.getAbsoluteDistance(e3[t4 - 1], r2.margin, false), i2 = Math.max(i2, l2)), o2 && t4 < f3.length - 1 && (l2 = k2.getAbsoluteDistance(e3[t4 + 1], r2.margin, true), i2 = Math.min(i2, l2))), f3.length > 1 && r2.limit && (n2 && t4 > 0 && (l2 = k2.getAbsoluteDistance(e3[t4 - 1], r2.limit, false), i2 = Math.min(i2, l2)), o2 && t4 < f3.length - 1 && (l2 = k2.getAbsoluteDistance(e3[t4 + 1], r2.limit, true), i2 = Math.max(i2, l2))), r2.padding && (0 === t4 && (l2 = k2.getAbsoluteDistance(0, r2.padding[0], false), i2 = Math.max(i2, l2)), t4 === f3.length - 1 && (l2 = k2.getAbsoluteDistance(100, r2.padding[1], true), i2 = Math.min(i2, l2))), s3 || (i2 = k2.getStep(i2)), !((i2 = p2(i2)) === e3[t4] && !a2) && i2;
      }
      function Se2(e3, t4) {
        var i2 = r2.ort;
        return (i2 ? t4 : e3) + ", " + (i2 ? e3 : t4);
      }
      function xe(e3, t4, i2, n2, o2) {
        var a2 = i2.slice(), s3 = n2[0], l2 = r2.events.smoothSteps, u4 = [!e3, e3], c3 = [e3, !e3];
        n2 = n2.slice(), e3 && n2.reverse(), n2.length > 1 ? n2.forEach(function(e4, r3) {
          var i3 = ye2(a2, e4, a2[e4] + t4, u4[r3], c3[r3], false, l2);
          false === i3 ? t4 = 0 : (t4 = i3 - a2[e4], a2[e4] = i3);
        }) : u4 = c3 = [true];
        var p3 = false;
        n2.forEach(function(e4, r3) {
          p3 = Ne(e4, i2[e4] + t4, u4[r3], c3[r3], false, l2) || p3;
        }), p3 && (n2.forEach(function(e4) {
          be2("update", e4), be2("slide", e4);
        }), null != o2 && be2("drag", s3));
      }
      function we(e3, t4) {
        return r2.dir ? 100 - e3 - t4 : e3;
      }
      function Ee(e3, t4) {
        A2[e3] = t4, V3[e3] = k2.fromStepping(t4);
        var i2 = "translate(" + Se2(we(t4, 0) - T2 + "%", "0") + ")";
        f3[e3].style[r2.transformRule] = i2, Ce(e3), Ce(e3 + 1);
      }
      function Pe2() {
        M2.forEach(function(e3) {
          var t4 = A2[e3] > 50 ? -1 : 1, r3 = 3 + (f3.length + t4 * e3);
          f3[e3].style.zIndex = String(r3);
        });
      }
      function Ne(e3, t4, r3, i2, n2, o2) {
        return n2 || (t4 = ye2(A2, e3, t4, r3, i2, false, o2)), false !== t4 && (Ee(e3, t4), true);
      }
      function Ce(e3) {
        if (x2[e3]) {
          var t4 = 0, i2 = 100;
          0 !== e3 && (t4 = A2[e3 - 1]), e3 !== x2.length - 1 && (i2 = A2[e3]);
          var n2 = i2 - t4, o2 = "translate(" + Se2(we(t4, n2) + "%", "0") + ")", a2 = "scale(" + Se2(n2 / 100, "1") + ")";
          x2[e3].style[r2.transformRule] = o2 + " " + a2;
        }
      }
      function ke(e3, t4) {
        return null === e3 || false === e3 || void 0 === e3 ? A2[t4] : ("number" == typeof e3 && (e3 = String(e3)), false !== (e3 = r2.format.from(e3)) && (e3 = k2.toStepping(e3)), false === e3 || isNaN(e3) ? A2[t4] : e3);
      }
      function Ve(e3, t4, i2) {
        var n2 = d2(e3), o2 = void 0 === A2[0];
        t4 = void 0 === t4 || t4, r2.animate && !o2 && c2(C2, r2.cssClasses.tap, r2.animationDuration), M2.forEach(function(e4) {
          Ne(e4, ke(n2[e4], e4), true, false, i2);
        });
        var a2 = 1 === M2.length ? 0 : 1;
        if (o2 && k2.hasNoSize() && (i2 = true, A2[0] = 0, M2.length > 1)) {
          var s3 = 100 / (M2.length - 1);
          M2.forEach(function(e4) {
            A2[e4] = e4 * s3;
          });
        }
        for (; a2 < M2.length; ++a2)
          M2.forEach(function(e4) {
            Ne(e4, A2[e4], true, true, i2);
          });
        Pe2(), M2.forEach(function(e4) {
          be2("update", e4), null !== n2[e4] && t4 && be2("set", e4);
        });
      }
      function Ae(e3) {
        Ve(r2.start, e3);
      }
      function Me(e3, t4, r3, i2) {
        if (!((e3 = Number(e3)) >= 0 && e3 < M2.length))
          throw new Error("noUiSlider: invalid handle number, got: " + e3);
        Ne(e3, ke(t4, e3), true, true, i2), be2("update", e3), r3 && be2("set", e3);
      }
      function Le(e3) {
        if (void 0 === e3 && (e3 = false), e3)
          return 1 === V3.length ? V3[0] : V3.slice(0);
        var t4 = V3.map(r2.format.to);
        return 1 === t4.length ? t4[0] : t4;
      }
      function Ue() {
        for (ge2(D.aria), ge2(D.tooltips), Object.keys(r2.cssClasses).forEach(function(e3) {
          m2(C2, r2.cssClasses[e3]);
        }); C2.firstChild; )
          C2.removeChild(C2.firstChild);
        delete C2.noUiSlider;
      }
      function Oe(e3) {
        var t4 = A2[e3], i2 = k2.getNearbySteps(t4), n2 = V3[e3], o2 = i2.thisStep.step, a2 = null;
        if (r2.snap)
          return [n2 - i2.stepBefore.startValue || null, i2.stepAfter.startValue - n2 || null];
        false !== o2 && n2 + o2 > i2.stepAfter.startValue && (o2 = i2.stepAfter.startValue - n2), a2 = n2 > i2.thisStep.startValue ? i2.thisStep.step : false !== i2.stepBefore.step && n2 - i2.stepBefore.highestStep, 100 === t4 ? o2 = null : 0 === t4 && (a2 = null);
        var s3 = k2.countStepDecimals();
        return null !== o2 && false !== o2 && (o2 = Number(o2.toFixed(s3))), null !== a2 && false !== a2 && (a2 = Number(a2.toFixed(s3))), [a2, o2];
      }
      function De() {
        return M2.map(Oe);
      }
      function je(e3, t4) {
        var i2 = Le(), o2 = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips"];
        o2.forEach(function(t5) {
          void 0 !== e3[t5] && (s2[t5] = e3[t5]);
        });
        var a2 = oe2(s2);
        o2.forEach(function(t5) {
          void 0 !== e3[t5] && (r2[t5] = a2[t5]);
        }), k2 = a2.spectrum, r2.margin = a2.margin, r2.limit = a2.limit, r2.padding = a2.padding, r2.pips ? ee2(r2.pips) : Z3(), r2.tooltips ? I2() : Y3(), A2 = [], Ve(n(e3.start) ? e3.start : i2, t4);
      }
      function Fe() {
        u3 = B2(C2), R2(r2.connect, u3), he2(r2.events), Ve(r2.start), r2.pips && ee2(r2.pips), r2.tooltips && I2(), W3();
      }
      Fe();
      var Te = { destroy: Ue, steps: De, on: me2, off: ge2, get: Le, set: Ve, setHandle: Me, reset: Ae, __moveHandles: function(e3, t4, r3) {
        xe(e3, t4, A2, r3);
      }, options: s2, updateOptions: je, target: C2, removePips: Z3, removeTooltips: Y3, getPositions: function() {
        return A2.slice();
      }, getTooltips: function() {
        return E2;
      }, getOrigins: function() {
        return f3;
      }, pips: ee2 };
      return Te;
    }
    function se2(e3, t3) {
      if (!e3 || !e3.nodeName)
        throw new Error("noUiSlider: create requires a single element, got: " + e3);
      if (e3.noUiSlider)
        throw new Error("noUiSlider: Slider was already initialized.");
      var r2 = ae(e3, oe2(t3), t3);
      return e3.noUiSlider = r2, r2;
    }
    var le2 = { __spectrum: L, cssClasses: O2, create: se2 };
    e2.create = se2, e2.cssClasses = O2, e2.default = le2, Object.defineProperty(e2, "__esModule", { value: true });
  }(t);
}));
function h(e, t) {
  if (!Array.isArray(e) || !Array.isArray(t))
    return false;
  const r = t.slice().sort();
  return e.length === t.length && e.slice().sort().every(function(e2, t2) {
    return e2 === r[t2];
  });
}
var m = { name: "Slider", emits: ["input", "update:modelValue", "start", "slide", "drag", "update", "change", "set", "end"], props: { ...{ value: { validator: function(e) {
  return (e2) => "number" == typeof e2 || e2 instanceof Array || null == e2 || false === e2;
}, required: false }, modelValue: { validator: function(e) {
  return (e2) => "number" == typeof e2 || e2 instanceof Array || null == e2 || false === e2;
}, required: false } }, id: { type: [String, Number], required: false }, disabled: { type: Boolean, required: false, default: false }, min: { type: Number, required: false, default: 0 }, max: { type: Number, required: false, default: 100 }, step: { type: Number, required: false, default: 1 }, orientation: { type: String, required: false, default: "horizontal" }, direction: { type: String, required: false, default: "ltr" }, tooltips: { type: Boolean, required: false, default: true }, options: { type: Object, required: false, default: () => ({}) }, merge: { type: Number, required: false, default: -1 }, format: { type: [Object, Function, Boolean], required: false, default: null }, classes: { type: Object, required: false, default: () => ({}) }, showTooltip: { type: String, required: false, default: "always" }, tooltipPosition: { type: String, required: false, default: null }, lazy: { type: Boolean, required: false, default: true }, ariaLabelledby: { type: String, required: false, default: void 0 }, aria: { required: false, type: Object, default: () => ({}) } }, setup(a, s) {
  const l = function(r, i, n) {
    const { value: o, modelValue: a2, min: s2 } = toRefs(r);
    let l2 = a2 && void 0 !== a2.value ? a2 : o;
    const c3 = ref(l2.value);
    if (u(l2.value) && (l2 = ref(s2.value)), Array.isArray(l2.value) && 0 == l2.value.length)
      throw new Error("Slider v-model must not be an empty array");
    return { value: l2, initialValue: c3 };
  }(a), c2 = function(t, i, n) {
    const { classes: o, showTooltip: a2, tooltipPosition: s2, orientation: l2 } = toRefs(t), u2 = computed(() => ({ target: "slider-target", focused: "slider-focused", tooltipFocus: "slider-tooltip-focus", tooltipDrag: "slider-tooltip-drag", ltr: "slider-ltr", rtl: "slider-rtl", horizontal: "slider-horizontal", vertical: "slider-vertical", textDirectionRtl: "slider-txt-dir-rtl", textDirectionLtr: "slider-txt-dir-ltr", base: "slider-base", connects: "slider-connects", connect: "slider-connect", origin: "slider-origin", handle: "slider-handle", handleLower: "slider-handle-lower", handleUpper: "slider-handle-upper", touchArea: "slider-touch-area", tooltip: "slider-tooltip", tooltipTop: "slider-tooltip-top", tooltipBottom: "slider-tooltip-bottom", tooltipLeft: "slider-tooltip-left", tooltipRight: "slider-tooltip-right", tooltipHidden: "slider-tooltip-hidden", active: "slider-active", draggable: "slider-draggable", tap: "slider-state-tap", drag: "slider-state-drag", pips: "slider-pips", pipsHorizontal: "slider-pips-horizontal", pipsVertical: "slider-pips-vertical", marker: "slider-marker", markerHorizontal: "slider-marker-horizontal", markerVertical: "slider-marker-vertical", markerNormal: "slider-marker-normal", markerLarge: "slider-marker-large", markerSub: "slider-marker-sub", value: "slider-value", valueHorizontal: "slider-value-horizontal", valueVertical: "slider-value-vertical", valueNormal: "slider-value-normal", valueLarge: "slider-value-large", valueSub: "slider-value-sub", ...o.value }));
    return { classList: computed(() => {
      const e = { ...u2.value };
      return Object.keys(e).forEach((t2) => {
        e[t2] = Array.isArray(e[t2]) ? e[t2].filter((e2) => null !== e2).join(" ") : e[t2];
      }), "always" !== a2.value && (e.target += ` ${"drag" === a2.value ? e.tooltipDrag : e.tooltipFocus}`), "horizontal" === l2.value && (e.tooltip += "bottom" === s2.value ? ` ${e.tooltipBottom}` : ` ${e.tooltipTop}`), "vertical" === l2.value && (e.tooltip += "right" === s2.value ? ` ${e.tooltipRight}` : ` ${e.tooltipLeft}`), e;
    }) };
  }(a), p2 = function(t, i, n) {
    const { format: o, step: a2 } = toRefs(t), s2 = n.value, l2 = n.classList, u2 = computed(() => o && o.value ? "function" == typeof o.value ? { to: o.value } : d({ ...o.value }) : d({ decimals: a2.value >= 0 ? 0 : 2 })), c3 = computed(() => Array.isArray(s2.value) ? s2.value.map((e) => u2.value) : u2.value);
    return { tooltipFormat: u2, tooltipsFormat: c3, tooltipsMerge: (e, t2, r) => {
      var i2 = "rtl" === getComputedStyle(e).direction, n2 = "rtl" === e.noUiSlider.options.direction, o2 = "vertical" === e.noUiSlider.options.orientation, a3 = e.noUiSlider.getTooltips(), s3 = e.noUiSlider.getOrigins();
      a3.forEach(function(e2, t3) {
        e2 && s3[t3].appendChild(e2);
      }), e.noUiSlider.on("update", function(e2, s4, c4, p3, d2) {
        var f2 = [[]], h2 = [[]], m3 = [[]], v = 0;
        a3[0] && (f2[0][0] = 0, h2[0][0] = d2[0], m3[0][0] = u2.value.to(parseFloat(e2[0])));
        for (var g = 1; g < e2.length; g++)
          (!a3[g] || e2[g] - e2[g - 1] > t2) && (f2[++v] = [], m3[v] = [], h2[v] = []), a3[g] && (f2[v].push(g), m3[v].push(u2.value.to(parseFloat(e2[g]))), h2[v].push(d2[g]));
        f2.forEach(function(e3, t3) {
          for (var s5 = e3.length, u3 = 0; u3 < s5; u3++) {
            var c5 = e3[u3];
            if (u3 === s5 - 1) {
              var p4 = 0;
              h2[t3].forEach(function(e4) {
                p4 += 1e3 - e4;
              });
              var d3 = o2 ? "bottom" : "right", f3 = n2 ? 0 : s5 - 1, v2 = 1e3 - h2[t3][f3];
              p4 = (i2 && !o2 ? 100 : 0) + p4 / s5 - v2, a3[c5].innerHTML = m3[t3].join(r), a3[c5].style.display = "block", a3[c5].style[d3] = p4 + "%", l2.value.tooltipHidden.split(" ").forEach((e4) => {
                a3[c5].classList.contains(e4) && a3[c5].classList.remove(e4);
              });
            } else
              a3[c5].style.display = "none", l2.value.tooltipHidden.split(" ").forEach((e4) => {
                a3[c5].classList.add(e4);
              });
          }
        });
      });
    } };
  }(a, 0, { value: l.value, classList: c2.classList }), m2 = function(a2, s2, l2) {
    const { orientation: c3, direction: p3, tooltips: d2, step: m3, min: v, max: g, merge: b, id: y2, disabled: S, options: x, classes: w, format: E, lazy: P, ariaLabelledby: N, aria: C } = toRefs(a2), k = l2.value, V2 = l2.initialValue, A = l2.tooltipsFormat, M = l2.tooltipsMerge, L = l2.tooltipFormat, U2 = l2.classList, O2 = ref(null), D = ref(null), j = ref(false), F = computed(() => {
      let e = { cssPrefix: "", cssClasses: U2.value, orientation: c3.value, direction: p3.value, tooltips: !!d2.value && A.value, connect: "lower", start: u(k.value) ? v.value : k.value, range: { min: v.value, max: g.value } };
      if (m3.value > 0 && (e.step = m3.value), Array.isArray(k.value) && (e.connect = true), N && N.value || C && Object.keys(C.value).length) {
        let t = Array.isArray(k.value) ? k.value : [k.value];
        e.handleAttributes = t.map((e2) => Object.assign({}, C.value, N && N.value ? { "aria-labelledby": N.value } : {}));
      }
      return E.value && (e.ariaFormat = L.value), e;
    }), T = computed(() => {
      let e = { id: y2 && y2.value ? y2.value : void 0 };
      return S.value && (e.disabled = true), e;
    }), z2 = computed(() => Array.isArray(k.value)), H2 = () => {
      let e = D.value.get();
      return Array.isArray(e) ? e.map((e2) => parseFloat(e2)) : parseFloat(e);
    }, q2 = function(e) {
      let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      D.value.set(e, t);
    }, R = (e) => {
      s2.emit("input", e), s2.emit("update:modelValue", e), s2.emit("update", e);
    }, B = () => {
      D.value = f.create(O2.value, Object.assign({}, F.value, x.value)), d2.value && z2.value && b.value >= 0 && M(O2.value, b.value, " - "), D.value.on("set", () => {
        const e = H2();
        s2.emit("change", e), s2.emit("set", e), P.value && R(e);
      }), D.value.on("update", () => {
        if (!j.value)
          return;
        const e = H2();
        z2.value && h(k.value, e) || !z2.value && k.value == e ? s2.emit("update", e) : P.value || R(e);
      }), D.value.on("start", () => {
        s2.emit("start", H2());
      }), D.value.on("end", () => {
        s2.emit("end", H2());
      }), D.value.on("slide", () => {
        s2.emit("slide", H2());
      }), D.value.on("drag", () => {
        s2.emit("drag", H2());
      }), O2.value.querySelectorAll("[data-handle]").forEach((e) => {
        e.onblur = () => {
          O2.value && U2.value.focused.split(" ").forEach((e2) => {
            O2.value.classList.remove(e2);
          });
        }, e.onfocus = () => {
          U2.value.focused.split(" ").forEach((e2) => {
            O2.value.classList.add(e2);
          });
        };
      }), j.value = true;
    }, _ = () => {
      D.value.off(), D.value.destroy(), D.value = null;
    }, $ = (e, t) => {
      j.value = false, _(), B();
    };
    return onMounted(B), onUnmounted(_), watch(z2, $, { immediate: false }), watch(v, $, { immediate: false }), watch(g, $, { immediate: false }), watch(m3, $, { immediate: false }), watch(c3, $, { immediate: false }), watch(p3, $, { immediate: false }), watch(d2, $, { immediate: false }), watch(b, $, { immediate: false }), watch(E, $, { immediate: false, deep: true }), watch(x, $, { immediate: false, deep: true }), watch(w, $, { immediate: false, deep: true }), watch(k, (e, t) => {
      t && ("object" == typeof t && "object" == typeof e && e && Object.keys(t) > Object.keys(e) || "object" == typeof t && "object" != typeof e || u(e)) && $();
    }, { immediate: false }), watch(k, (e) => {
      if (u(e))
        return void q2(v.value, false);
      let t = H2();
      z2.value && !Array.isArray(t) && (t = [t]), (z2.value && !h(e, t) || !z2.value && e != t) && q2(e, false);
    }, { deep: true }), { slider: O2, slider$: D, isRange: z2, sliderProps: T, init: B, destroy: _, refresh: $, update: q2, reset: () => {
      R(V2.value);
    } };
  }(a, s, { value: l.value, initialValue: l.initialValue, tooltipFormat: p2.tooltipFormat, tooltipsFormat: p2.tooltipsFormat, tooltipsMerge: p2.tooltipsMerge, classList: c2.classList });
  return { ...c2, ...p2, ...m2 };
} };
m.render = function(e, t, r, i, n, o) {
  return openBlock(), createElementBlock("div", mergeProps(e.sliderProps, { ref: "slider" }), null, 16);
}, m.__file = "src/Slider.vue";
const AdminTabChallenge_vue_vue_type_style_index_0_lang = "";
const _sfc_main$6 = {
  components: { VueMultiselect: script$1, Slider: m },
  data() {
    const store = usePlayerStore();
    const types = ["success", "failure"];
    const chosen_stat = "";
    const chosen_tags = [];
    const stat_modifier = { "success": {}, "failure": {} };
    const gauge_modifier = { "success": {}, "failure": {} };
    const chosen_modifier_tags_add = { "success": [], "failure": [] };
    const chosen_modifier_tags_remove = { "success": [], "failure": [] };
    const challenge_difficulty = 0;
    return {
      store,
      types,
      chosen_tags,
      chosen_stat,
      stat_modifier,
      gauge_modifier,
      chosen_modifier_tags_add,
      chosen_modifier_tags_remove,
      challenge_difficulty
    };
  },
  mounted() {
    this.updateColorDifficulty();
  },
  computed: {
    labelDifficulty: function() {
      let levels = [
        { value: -8, label: this.$t("dif_cake") },
        { value: -6, label: this.$t("dif_ext_easy") },
        { value: -4, label: this.$t("dif_very_easy") },
        { value: -2, label: this.$t("dif_easy") },
        { value: 0, label: this.$t("dif_moderate") },
        { value: 2, label: this.$t("dif_hard") },
        { value: 4, label: this.$t("dif_very_hard") },
        { value: 6, label: this.$t("dif_extreme") },
        { value: 8, label: this.$t("dif_impossible") }
      ];
      for (let level of levels) {
        if (this.challenge_difficulty <= level.value) {
          return level.label;
        }
      }
    }
  },
  methods: {
    updateColorDifficulty() {
      let green;
      let red;
      if (this.challenge_difficulty >= 0) {
        red = 255;
      }
      if (this.challenge_difficulty <= 0) {
        green = 255;
      }
      if (this.challenge_difficulty > 0) {
        green = 255 - this.challenge_difficulty / 8 * 255;
      } else if (this.challenge_difficulty < 0) {
        red = 255 - -this.challenge_difficulty / 8 * 255;
      }
      let rgba = "rgba(" + red + "," + green + ",0,1)";
      document.documentElement.style.setProperty("--slider-connect-bg", rgba);
    },
    modifierChange(name, type, key, value) {
      if (this[name + "_modifier"][type][key] === void 0) {
        this[name + "_modifier"][type][key] = value;
      } else {
        this[name + "_modifier"][type][key] += value;
      }
      if (this[name + "_modifier"][type][key] === 0) {
        delete this[name + "_modifier"][type][key];
      }
    },
    addTag(tag_label, type) {
      let group = this.store.tag_groups.find((element2) => element2.code === "freetag");
      if (group === void 0) {
        group = this.store.addGroupTag(true);
      }
      let tag = this.store.addTag(tag_label, group);
      this.chosen_modifier_tags_add[type].push(tag);
    },
    startChallenge() {
      const date = Date.now();
      let nb_success = 0;
      const vm = this;
      let selectedCharacters;
      if (this.chosen_tags.length) {
        selectedCharacters = this.store.alive_characters.filter(
          function(character) {
            return vm.store.filterCharacterByTagsAndPicked(character, vm.chosen_tags);
          }
        );
      } else {
        selectedCharacters = this.store.alive_characters;
      }
      selectedCharacters.forEach(function(character) {
        character.in_progress = true;
        let messages2 = [];
        let result = "failure";
        let die_throw = Math.floor(Math.random() * 20 + 1) + vm.challenge_difficulty;
        if (die_throw === 1 || die_throw <= character.stats[vm.chosen_stat].value) {
          result = "success";
          nb_success += 1;
        }
        messages2.push(vm.$t("challenge_" + result, { stat: vm.store.current_game.stats[vm.chosen_stat].name }));
        if (vm.gauge_modifier[result] !== void 0) {
          for (const [key, bonus] of Object.entries(vm.gauge_modifier[result])) {
            messages2.push(vm.$t("result_" + (bonus >= 0 ? "bonus" : "malus"), { points: bonus, name: vm.store.current_game.gauges[key].name }));
            character.gauges[key].value += bonus;
          }
        }
        if (vm.stat_modifier[result] !== void 0) {
          for (const [key, bonus] of Object.entries(vm.stat_modifier[result])) {
            messages2.push(vm.$t("result_" + (bonus >= 0 ? "bonus" : "malus"), { points: bonus, name: vm.store.current_game.stats[key].name }));
            character.stats[key].value += bonus;
          }
        }
        if (vm.chosen_modifier_tags_add[result] !== void 0) {
          vm.chosen_modifier_tags_add[result].forEach(function(tag) {
            let found = character.tags.findIndex((character_tag) => character_tag.code === tag.code);
            if (found === -1) {
              character.tags.push(tag);
              messages2.push(vm.$t("added_tag", { tag_label: tag.label }));
            }
          });
        }
        if (vm.chosen_modifier_tags_remove[result] !== void 0) {
          vm.chosen_modifier_tags_remove[result].forEach(function(tag) {
            let found = character.tags.findIndex((character_tag) => character_tag.code === tag.code);
            if (found !== -1) {
              character.tags.splice(found, 1);
              messages2.push(vm.$t("removed_tag", { tag_label: tag.label }));
            }
          });
        }
        character.challenge = { date, result, message: messages2 };
        delete character.in_progress;
      });
      let nb_failure = selectedCharacters.length - nb_success;
      this.store._last_challenge = {
        date,
        nb_success,
        nb_failure,
        rate: Math.floor(100 / selectedCharacters.length * nb_success)
      };
      this.$parent.changeTab("characters");
      this.challenge_difficulty = 0;
      this.chosen_stat = "";
      this.chosen_tags = [];
      this.stat_modifier.success = {};
      this.stat_modifier.failure = {};
      this.gauge_modifier.success = {};
      this.gauge_modifier.failure = {};
      this.chosen_modifier_tags_add.success = [];
      this.chosen_modifier_tags_add.failure = [];
      this.chosen_modifier_tags_remove.success = [];
      this.chosen_modifier_tags_remove.failure = [];
    }
  }
};
const _hoisted_1$5 = {
  class: "tab",
  ref: "tab"
};
const _hoisted_2$5 = { key: 0 };
const _hoisted_3$5 = {
  key: 1,
  ref: "step_challenge_1",
  id: "tab-challenge-content"
};
const _hoisted_4$5 = { id: "chosen-targets" };
const _hoisted_5$4 = { for: "chosen_stat" };
const _hoisted_6$3 = { value: "" };
const _hoisted_7$3 = ["value"];
const _hoisted_8$3 = { for: "difficulty" };
const _hoisted_9$3 = { class: "label-difficulty" };
const _hoisted_10$3 = { for: "chosen_tags" };
const _hoisted_11$3 = ["id"];
const _hoisted_12$3 = { class: "label-wrapper" };
const _hoisted_13$3 = { class: "modifiers-buttons" };
const _hoisted_14$2 = { class: "modifier-label" };
const _hoisted_15$2 = ["onClick"];
const _hoisted_16$2 = { class: "modifier-value" };
const _hoisted_17$2 = ["onClick"];
const _hoisted_18$2 = { class: "modifiers-buttons" };
const _hoisted_19$2 = { class: "modifier-label" };
const _hoisted_20$2 = ["onClick"];
const _hoisted_21$2 = { class: "modifier-value" };
const _hoisted_22$2 = ["onClick"];
const _hoisted_23$2 = ["for"];
const _hoisted_24$1 = { class: "full" };
const _hoisted_25$1 = ["for"];
const _hoisted_26$1 = {
  key: 0,
  id: "summary-target"
};
const _hoisted_27$1 = { key: 0 };
const _hoisted_28$1 = { key: 1 };
const _hoisted_29 = { key: 0 };
const _hoisted_30 = { class: "inline" };
const _hoisted_31 = {
  key: 1,
  class: "full"
};
const _hoisted_32 = {
  key: 2,
  class: "full"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Slider = resolveComponent("Slider");
  const _component_vue_multiselect = resolveComponent("vue-multiselect");
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    $data.store.stats !== void 0 && Object.keys($data.store.stats).length === 0 ? (openBlock(), createElementBlock("span", _hoisted_2$5, [
      createTextVNode(toDisplayString$1(_ctx.$t("must_first")), 1),
      createBaseVNode("button", {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$parent.changeTab("settings"))
      }, toDisplayString$1(_ctx.$t("add_stat")), 1)
    ])) : createCommentVNode("", true),
    $data.store.stats !== void 0 && Object.keys($data.store.stats).length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$5, [
      createBaseVNode("div", _hoisted_4$5, [
        createBaseVNode("div", null, [
          createBaseVNode("label", _hoisted_5$4, toDisplayString$1(_ctx.$t("tested_stat")), 1),
          withDirectives(createBaseVNode("select", {
            id: "chosen_stat",
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.chosen_stat = $event)
          }, [
            createBaseVNode("option", _hoisted_6$3, toDisplayString$1(_ctx.$t("choose_stat")), 1),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.current_game.stats, (stat, key) => {
              return openBlock(), createElementBlock("option", { value: key }, toDisplayString$1(stat.name), 9, _hoisted_7$3);
            }), 256))
          ], 512), [
            [vModelSelect, $data.chosen_stat]
          ])
        ]),
        createBaseVNode("div", null, [
          createBaseVNode("label", _hoisted_8$3, [
            createTextVNode(toDisplayString$1(_ctx.$t("difficulty")), 1),
            createBaseVNode("span", _hoisted_9$3, toDisplayString$1($options.labelDifficulty), 1)
          ]),
          createVNode(_component_Slider, {
            modelValue: $data.challenge_difficulty,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.challenge_difficulty = $event),
            min: -8,
            max: 8,
            lazy: false,
            tooltipPosition: "bottom",
            onUpdate: $options.updateColorDifficulty
          }, null, 8, ["modelValue", "onUpdate"])
        ]),
        createBaseVNode("div", null, [
          createBaseVNode("label", _hoisted_10$3, toDisplayString$1(_ctx.$t("targets")), 1),
          createVNode(_component_vue_multiselect, {
            ref: "chosen_tags",
            id: "chosen_tags",
            modelValue: $data.chosen_tags,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.chosen_tags = $event),
            label: "label",
            "track-by": "code",
            "group-values": "tags",
            "group-label": "label",
            "group-select": true,
            placeholder: _ctx.$t("add_target"),
            tagPlaceholder: _ctx.$t("add_target"),
            noOptions: _ctx.$t("everyone"),
            options: $data.store.tag_groups_plus_targets,
            multiple: true,
            taggable: false,
            hideSelected: true
          }, null, 8, ["modelValue", "placeholder", "tagPlaceholder", "noOptions", "options"])
        ])
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.types, (type) => {
        return openBlock(), createElementBlock(Fragment, null, [
          $data.chosen_stat !== "" ? (openBlock(), createElementBlock("div", {
            key: 0,
            id: "chosen-" + type,
            class: normalizeClass("type-" + type)
          }, [
            createBaseVNode("span", _hoisted_12$3, toDisplayString$1(type === "success" ? _ctx.$t("positive_csq") : _ctx.$t("negative_csq")), 1),
            createBaseVNode("div", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.current_game.gauges, (gauge, key) => {
                return openBlock(), createElementBlock("div", _hoisted_13$3, [
                  createBaseVNode("span", _hoisted_14$2, toDisplayString$1(gauge.name), 1),
                  createBaseVNode("div", null, [
                    createBaseVNode("button", {
                      onClick: ($event) => $options.modifierChange("gauge", type, key, -1)
                    }, "-", 8, _hoisted_15$2),
                    createBaseVNode("span", _hoisted_16$2, toDisplayString$1($data.gauge_modifier[type][key] !== void 0 ? ($data.gauge_modifier[type][key] >= 0 ? "+" : "") + $data.gauge_modifier[type][key] : "+0"), 1),
                    createBaseVNode("button", {
                      onClick: ($event) => $options.modifierChange("gauge", type, key, 1)
                    }, "+", 8, _hoisted_17$2)
                  ])
                ]);
              }), 256)),
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.current_game.stats, (stat, key) => {
                return openBlock(), createElementBlock("div", _hoisted_18$2, [
                  createBaseVNode("span", _hoisted_19$2, toDisplayString$1(stat.name), 1),
                  createBaseVNode("div", null, [
                    createBaseVNode("button", {
                      onClick: ($event) => $options.modifierChange("stat", type, key, -1)
                    }, "-", 8, _hoisted_20$2),
                    createBaseVNode("span", _hoisted_21$2, toDisplayString$1($data.stat_modifier[type][key] !== void 0 ? ($data.stat_modifier[type][key] >= 0 ? "+" : "") + $data.stat_modifier[type][key] : "+0"), 1),
                    createBaseVNode("button", {
                      onClick: ($event) => $options.modifierChange("stat", type, key, 1)
                    }, "+", 8, _hoisted_22$2)
                  ])
                ]);
              }), 256))
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("label", {
                for: "chosen_modifier_tags_add_" + type
              }, toDisplayString$1(_ctx.$t("add_tags")), 9, _hoisted_23$2),
              createVNode(_component_vue_multiselect, {
                id: "chosen_modifier_tags_add_" + type,
                modelValue: $data.chosen_modifier_tags_add[type],
                "onUpdate:modelValue": ($event) => $data.chosen_modifier_tags_add[type] = $event,
                label: "label",
                "track-by": "code",
                "tag-placeholder": _ctx.$t("add_tag"),
                placeholder: _ctx.$t("input_word"),
                noOptions: _ctx.$t("no_tag_create"),
                "group-values": "tags",
                "group-label": "label",
                "group-select": false,
                options: $data.store.tag_groups,
                multiple: true,
                taggable: true,
                hideSelected: true,
                onTag: ($event) => $options.addTag($event, type)
              }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "tag-placeholder", "placeholder", "noOptions", "options", "onTag"])
            ]),
            createBaseVNode("div", _hoisted_24$1, [
              createBaseVNode("label", {
                for: "chosen_modifier_tags_remove_" + type
              }, toDisplayString$1(_ctx.$t("remove_tag")), 9, _hoisted_25$1),
              createVNode(_component_vue_multiselect, {
                id: "chosen_modifier_tags_remove_" + type,
                modelValue: $data.chosen_modifier_tags_remove[type],
                "onUpdate:modelValue": ($event) => $data.chosen_modifier_tags_remove[type] = $event,
                label: "label",
                "track-by": "code",
                placeholder: _ctx.$t("input_word"),
                showNoOptions: false,
                "group-values": "tags",
                "group-label": "label",
                "group-select": false,
                options: $data.store.tag_groups,
                multiple: true,
                hideSelected: true,
                onTag: ($event) => $options.addTag($event, type)
              }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "placeholder", "options", "onTag"])
            ])
          ], 10, _hoisted_11$3)) : createCommentVNode("", true)
        ], 64);
      }), 256)),
      $data.chosen_stat !== "" ? (openBlock(), createElementBlock("div", _hoisted_26$1, [
        createBaseVNode("div", null, [
          createBaseVNode("span", null, toDisplayString$1(_ctx.$t("this_will_test")) + toDisplayString$1($data.store.stats[$data.chosen_stat].name.toLowerCase()), 1),
          $data.chosen_tags.length === 0 ? (openBlock(), createElementBlock("span", _hoisted_27$1, toDisplayString$1(_ctx.$t("for_everyone")), 1)) : createCommentVNode("", true),
          $data.chosen_tags.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_28$1, [
            createBaseVNode("span", null, toDisplayString$1(_ctx.$t("for_every")), 1),
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.chosen_tags, (tag, key) => {
              return openBlock(), createElementBlock("span", null, toDisplayString$1(key > 0 ? "," : "") + " " + toDisplayString$1(tag.label), 1);
            }), 256))
          ])) : createCommentVNode("", true)
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.types, (type) => {
          return openBlock(), createElementBlock("div", null, [
            Object.keys($data.gauge_modifier[type]).length || Object.keys($data.stat_modifier[type]).length || $data.chosen_modifier_tags_add[type].length || $data.chosen_modifier_tags_remove[type].length ? (openBlock(), createElementBlock("span", _hoisted_29, toDisplayString$1(_ctx.$t("challenge_characters")) + toDisplayString$1(type === "success" ? _ctx.$t("that_pass") : _ctx.$t("that_fail")) + toDisplayString$1(_ctx.$t("will_have")), 1)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_30, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.gauge_modifier[type], (modifier, key) => {
                return openBlock(), createElementBlock("span", null, toDisplayString$1($data.store.gauges[key].name) + " " + toDisplayString$1(modifier > 0 ? "+" + modifier : modifier), 1);
              }), 256)),
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.stat_modifier[type], (modifier, key) => {
                return openBlock(), createElementBlock("span", null, toDisplayString$1($data.store.stats[key].name) + " " + toDisplayString$1(modifier > 0 ? "+" + modifier : modifier), 1);
              }), 256))
            ]),
            $data.chosen_modifier_tags_add[type].length > 0 ? (openBlock(), createElementBlock("div", _hoisted_31, [
              createBaseVNode("span", null, toDisplayString$1(_ctx.$t("get_following_tags")), 1),
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.chosen_modifier_tags_add[type], (tag) => {
                return openBlock(), createElementBlock("span", null, toDisplayString$1(tag.label), 1);
              }), 256))
            ])) : createCommentVNode("", true),
            $data.chosen_modifier_tags_remove[type].length > 0 ? (openBlock(), createElementBlock("div", _hoisted_32, [
              createBaseVNode("span", null, toDisplayString$1(_ctx.$t("lose_following_tags")), 1),
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.chosen_modifier_tags_remove[type], (tag) => {
                return openBlock(), createElementBlock("span", null, toDisplayString$1(tag.label), 1);
              }), 256))
            ])) : createCommentVNode("", true)
          ]);
        }), 256)),
        createBaseVNode("button", {
          onClick: _cache[4] || (_cache[4] = ($event) => $options.startChallenge())
        }, toDisplayString$1(_ctx.$t("start_challenge")), 1)
      ])) : createCommentVNode("", true)
    ], 512)) : createCommentVNode("", true)
  ], 512);
}
const AdminTabChallenge = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$5]]);
const AdminTabPick_vue_vue_type_style_index_0_scoped_208e2001_lang = "";
const _sfc_main$5 = {
  components: {
    VueMultiselect: script$1
  },
  data() {
    const store = usePlayerStore();
    const pick_multiselect = [];
    const type_pick = "all";
    const nb_targets = 1;
    const stat_modifier = {};
    const gauge_modifier = {};
    const chosen_modifier_pick_add = [];
    const chosen_modifier_pick_remove = [];
    return {
      store,
      pick_multiselect,
      type_pick,
      nb_targets,
      stat_modifier,
      gauge_modifier,
      chosen_modifier_pick_add,
      chosen_modifier_pick_remove
    };
  },
  mounted() {
  },
  methods: {
    launchPick: function() {
      this.store.resetPickedCharacters();
      this.store.current_game.has_picked = true;
      const vm = this;
      let relevant_characters = this.store.alive_characters;
      if (this.pick_multiselect.length) {
        if (this.type_pick === "one") {
          relevant_characters = relevant_characters.filter(function(character) {
            return character.tags.find(
              (tag) => vm.pick_multiselect.find((chosen_tag) => chosen_tag.code === tag.code)
            );
          });
        } else if (this.type_pick === "all") {
          relevant_characters = relevant_characters.filter(
            function(character) {
              let found = 0;
              vm.pick_multiselect.every(function(tag) {
                found = character.tags.findIndex((character_tag) => character_tag.code === tag.code);
                return found > -1;
              });
              return found > -1;
            }
          );
        } else if (this.type_pick === "none") {
          relevant_characters = relevant_characters.filter(
            function(character) {
              let found = -1;
              vm.pick_multiselect.every(function(tag) {
                found = character.tags.findIndex((character_tag) => character_tag.code === tag.code);
                return found === -1;
              });
              return found === -1;
            }
          );
        } else if (this.type_pick === "each")
          ;
      }
      if (relevant_characters.length) {
        let picked_characters = this.store.getRandom(relevant_characters, this.nb_targets);
        this.store.setPickedCharacters(picked_characters);
        picked_characters.forEach(function(character) {
          character.in_progress = true;
          if (vm.gauge_modifier !== void 0) {
            for (const [key, bonus] of Object.entries(vm.gauge_modifier)) {
              character.gauges[key].value += bonus;
            }
          }
          if (vm.stat_modifier !== void 0) {
            for (const [key, bonus] of Object.entries(vm.stat_modifier)) {
              character.stats[key].value += bonus;
            }
          }
          if (vm.chosen_modifier_pick_add !== void 0) {
            vm.chosen_modifier_pick_add.forEach(function(tag) {
              let found = character.tags.findIndex((character_tag) => character_tag.code === tag.code);
              if (found === -1) {
                character.tags.push(tag);
              }
            });
          }
          if (vm.chosen_modifier_pick_remove !== void 0) {
            vm.chosen_modifier_pick_remove.forEach(function(tag) {
              let found = character.tags.findIndex((character_tag) => character_tag.code === tag.code);
              if (found !== -1) {
                character.tags.splice(found, 1);
              }
            });
          }
          delete character.in_progress;
        });
      }
      this.nb_targets = 1;
      this.stat_modifier = {};
      this.gauge_modifier = {};
      this.chosen_modifier_pick_add = [];
      this.chosen_modifier_pick_remove = [];
      this.$parent.changeTab("characters");
    },
    modifierChange(name, key, value) {
      if (this[name + "_modifier"][key] === void 0) {
        this[name + "_modifier"][key] = value;
      } else {
        this[name + "_modifier"][key] += value;
      }
      if (this[name + "_modifier"][key] === 0) {
        delete this[name + "_modifier"][key];
      }
    },
    addTag(tag_label, type) {
      let group = this.store.tag_groups.find((element2) => element2.code === "freetag");
      if (group === void 0) {
        group = this.store.addGroupTag(true);
      }
      let tag = this.store.addTag(tag_label, group);
      group.picking_array.push(tag.code);
      this.chosen_modifier_pick_add.push(tag);
    }
  }
};
const _hoisted_1$4 = {
  class: "tab",
  ref: "tab"
};
const _hoisted_2$4 = { id: "tab-pick-content" };
const _hoisted_3$4 = { class: "vertical-wrapper" };
const _hoisted_4$4 = { value: "one" };
const _hoisted_5$3 = { value: "all" };
const _hoisted_6$2 = { value: "none" };
const _hoisted_7$2 = {
  disabled: "",
  value: "each"
};
const _hoisted_8$2 = {
  id: "consequences",
  class: "vertical-wrapper"
};
const _hoisted_9$2 = { class: "label-wrapper" };
const _hoisted_10$2 = { class: "modifiers-buttons" };
const _hoisted_11$2 = { class: "modifier-label" };
const _hoisted_12$2 = ["onClick"];
const _hoisted_13$2 = { class: "modifier-value" };
const _hoisted_14$1 = ["onClick"];
const _hoisted_15$1 = { class: "modifiers-buttons" };
const _hoisted_16$1 = { class: "modifier-label" };
const _hoisted_17$1 = ["onClick"];
const _hoisted_18$1 = { class: "modifier-value" };
const _hoisted_19$1 = ["onClick"];
const _hoisted_20$1 = { class: "full" };
const _hoisted_21$1 = { for: "chosen_modifier_pick_add" };
const _hoisted_22$1 = { class: "full" };
const _hoisted_23$1 = { for: "chosen_modifier_pick_remove" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vue_multiselect = resolveComponent("vue-multiselect");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createBaseVNode("div", _hoisted_2$4, [
      createBaseVNode("div", _hoisted_3$4, [
        withDirectives(createBaseVNode("input", {
          ref: "step_pick_1",
          type: "number",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.nb_targets = $event),
          min: "1"
        }, null, 512), [
          [vModelText, $data.nb_targets]
        ]),
        withDirectives(createBaseVNode("select", {
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.type_pick = $event)
        }, [
          createBaseVNode("option", _hoisted_4$4, toDisplayString$1(_ctx.$t("admin_pick_one")), 1),
          createBaseVNode("option", _hoisted_5$3, toDisplayString$1(_ctx.$t("admin_pick_all")), 1),
          createBaseVNode("option", _hoisted_6$2, toDisplayString$1(_ctx.$t("admin_pick_none")), 1),
          createBaseVNode("option", _hoisted_7$2, toDisplayString$1(_ctx.$t("admin_pick_each")) + " - " + toDisplayString$1(_ctx.$t("future_feature")), 1)
        ], 512), [
          [vModelSelect, $data.type_pick]
        ]),
        createVNode(_component_vue_multiselect, {
          ref: "pick_multiselect",
          id: "pick_multiselect",
          modelValue: $data.pick_multiselect,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.pick_multiselect = $event),
          label: "label",
          "track-by": "code",
          "group-values": "tags",
          "group-label": "label",
          "group-select": true,
          placeholder: _ctx.$t("select_tag"),
          tagPlaceholder: _ctx.$t("select_tag"),
          noOptions: _ctx.$t("everyone"),
          options: $data.store.tag_groups,
          multiple: true,
          taggable: false,
          hideSelected: true
        }, null, 8, ["modelValue", "placeholder", "tagPlaceholder", "noOptions", "options"])
      ]),
      createBaseVNode("div", _hoisted_8$2, [
        createBaseVNode("span", _hoisted_9$2, toDisplayString$1(_ctx.$t("admin_pick_add_csq")), 1),
        createBaseVNode("div", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.current_game.gauges, (gauge, key) => {
            return openBlock(), createElementBlock("div", _hoisted_10$2, [
              createBaseVNode("span", _hoisted_11$2, toDisplayString$1(gauge.name), 1),
              createBaseVNode("div", null, [
                createBaseVNode("button", {
                  onClick: ($event) => $options.modifierChange("gauge", key, -1)
                }, "-", 8, _hoisted_12$2),
                createBaseVNode("span", _hoisted_13$2, toDisplayString$1($data.gauge_modifier[key] !== void 0 ? ($data.gauge_modifier[key] >= 0 ? "+" : "") + $data.gauge_modifier[key] : "+0"), 1),
                createBaseVNode("button", {
                  onClick: ($event) => $options.modifierChange("gauge", key, 1)
                }, "+", 8, _hoisted_14$1)
              ])
            ]);
          }), 256)),
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.store.current_game.stats, (stat, key) => {
            return openBlock(), createElementBlock("div", _hoisted_15$1, [
              createBaseVNode("span", _hoisted_16$1, toDisplayString$1(stat.name), 1),
              createBaseVNode("div", null, [
                createBaseVNode("button", {
                  onClick: ($event) => $options.modifierChange("stat", key, -1)
                }, "-", 8, _hoisted_17$1),
                createBaseVNode("span", _hoisted_18$1, toDisplayString$1($data.stat_modifier[key] !== void 0 ? ($data.stat_modifier[key] >= 0 ? "+" : "") + $data.stat_modifier[key] : "+0"), 1),
                createBaseVNode("button", {
                  onClick: ($event) => $options.modifierChange("stat", key, 1)
                }, "+", 8, _hoisted_19$1)
              ])
            ]);
          }), 256))
        ]),
        createBaseVNode("div", _hoisted_20$1, [
          createBaseVNode("label", _hoisted_21$1, toDisplayString$1(_ctx.$t("add_tags")), 1),
          createVNode(_component_vue_multiselect, {
            id: "chosen_modifier_pick_add",
            modelValue: $data.chosen_modifier_pick_add,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.chosen_modifier_pick_add = $event),
            label: "label",
            "track-by": "code",
            "tag-placeholder": _ctx.$t("add_tag"),
            placeholder: _ctx.$t("input_word"),
            noOptions: _ctx.$t("no_tag_create"),
            "group-values": "tags",
            "group-label": "label",
            "group-select": false,
            options: $data.store.tag_groups,
            multiple: true,
            taggable: true,
            hideSelected: true,
            onTag: _cache[4] || (_cache[4] = ($event) => $options.addTag($event))
          }, null, 8, ["modelValue", "tag-placeholder", "placeholder", "noOptions", "options"])
        ]),
        createBaseVNode("div", _hoisted_22$1, [
          createBaseVNode("label", _hoisted_23$1, toDisplayString$1(_ctx.$t("remove_tag")), 1),
          createVNode(_component_vue_multiselect, {
            id: "chosen_modifier_pick_remove",
            modelValue: $data.chosen_modifier_pick_remove,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.chosen_modifier_pick_remove = $event),
            label: "label",
            "track-by": "code",
            placeholder: _ctx.$t("input_word"),
            showNoOptions: false,
            "group-values": "tags",
            "group-label": "label",
            "group-select": false,
            options: $data.store.tag_groups,
            multiple: true,
            hideSelected: true,
            onTag: _cache[6] || (_cache[6] = ($event) => $options.addTag($event))
          }, null, 8, ["modelValue", "placeholder", "options"])
        ])
      ]),
      createBaseVNode("button", {
        id: "admin_pick_button",
        class: "btn-valid",
        onClick: _cache[7] || (_cache[7] = (...args) => $options.launchPick && $options.launchPick(...args))
      }, toDisplayString$1(_ctx.$t("admin_pick_launch")), 1)
    ])
  ], 512);
}
const AdminTabPick = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$4], ["__scopeId", "data-v-208e2001"]]);
/*! shepherd.js 11.2.0 */
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target2, source, options) {
  return target2.concat(source).map(function(element2) {
    return cloneUnlessOtherwiseSpecified(element2, options);
  });
}
function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return deepmerge;
  }
  var customMerge = options.customMerge(key);
  return typeof customMerge === "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target2) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target2).filter(function(symbol) {
    return Object.propertyIsEnumerable.call(target2, symbol);
  }) : [];
}
function getKeys(target2) {
  return Object.keys(target2).concat(getEnumerableOwnPropertySymbols(target2));
}
function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
}
function propertyIsUnsafe(target2, key) {
  return propertyIsOnObject(target2, key) && !(Object.hasOwnProperty.call(target2, key) && Object.propertyIsEnumerable.call(target2, key));
}
function mergeObject(target2, source, options) {
  var destination = {};
  if (options.isMergeableObject(target2)) {
    getKeys(target2).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target2[key], options);
    });
  }
  getKeys(source).forEach(function(key) {
    if (propertyIsUnsafe(target2, key)) {
      return;
    }
    if (propertyIsOnObject(target2, key) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options)(target2[key], source[key], options);
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    }
  });
  return destination;
}
function deepmerge(target2, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target2);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target2, source, options);
  } else {
    return mergeObject(target2, source, options);
  }
}
deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var deepmerge_1 = deepmerge;
var cjs = deepmerge_1;
function isElement$1(value) {
  return value instanceof Element;
}
function isHTMLElement$1(value) {
  return value instanceof HTMLElement;
}
function isFunction(value) {
  return typeof value === "function";
}
function isString(value) {
  return typeof value === "string";
}
function isUndefined(value) {
  return value === void 0;
}
class Evented {
  on(event, handler, ctx, once2 = false) {
    if (isUndefined(this.bindings)) {
      this.bindings = {};
    }
    if (isUndefined(this.bindings[event])) {
      this.bindings[event] = [];
    }
    this.bindings[event].push({
      handler,
      ctx,
      once: once2
    });
    return this;
  }
  once(event, handler, ctx) {
    return this.on(event, handler, ctx, true);
  }
  off(event, handler) {
    if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {
      return this;
    }
    if (isUndefined(handler)) {
      delete this.bindings[event];
    } else {
      this.bindings[event].forEach((binding, index) => {
        if (binding.handler === handler) {
          this.bindings[event].splice(index, 1);
        }
      });
    }
    return this;
  }
  trigger(event, ...args) {
    if (!isUndefined(this.bindings) && this.bindings[event]) {
      this.bindings[event].forEach((binding, index) => {
        const {
          ctx,
          handler,
          once: once2
        } = binding;
        const context = ctx || this;
        handler.apply(context, args);
        if (once2) {
          this.bindings[event].splice(index, 1);
        }
      });
    }
    return this;
  }
}
function autoBind(self2) {
  const keys2 = Object.getOwnPropertyNames(self2.constructor.prototype);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    const val = self2[key];
    if (key !== "constructor" && typeof val === "function") {
      self2[key] = val.bind(self2);
    }
  }
  return self2;
}
function _setupAdvanceOnHandler(selector, step) {
  return (event) => {
    if (step.isOpen()) {
      const targetIsEl = step.el && event.currentTarget === step.el;
      const targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);
      if (targetIsSelector || targetIsEl) {
        step.tour.next();
      }
    }
  };
}
function bindAdvance(step) {
  const {
    event,
    selector
  } = step.options.advanceOn || {};
  if (event) {
    const handler = _setupAdvanceOnHandler(selector, step);
    let el;
    try {
      el = document.querySelector(selector);
    } catch (e) {
    }
    if (!isUndefined(selector) && !el) {
      return console.error(`No element was found for the selector supplied to advanceOn: ${selector}`);
    } else if (el) {
      el.addEventListener(event, handler);
      step.on("destroy", () => {
        return el.removeEventListener(event, handler);
      });
    } else {
      document.body.addEventListener(event, handler, true);
      step.on("destroy", () => {
        return document.body.removeEventListener(event, handler, true);
      });
    }
  } else {
    return console.error("advanceOn was defined, but no event name was passed.");
  }
}
function normalizePrefix(prefix) {
  if (!isString(prefix) || prefix === "") {
    return "";
  }
  return prefix.charAt(prefix.length - 1) !== "-" ? `${prefix}-` : prefix;
}
function parseAttachTo(step) {
  const options = step.options.attachTo || {};
  const returnOpts = Object.assign({}, options);
  if (isFunction(returnOpts.element)) {
    returnOpts.element = returnOpts.element.call(step);
  }
  if (isString(returnOpts.element)) {
    try {
      returnOpts.element = document.querySelector(returnOpts.element);
    } catch (e) {
    }
    if (!returnOpts.element) {
      console.error(`The element for this Shepherd step was not found ${options.element}`);
    }
  }
  return returnOpts;
}
function shouldCenterStep(resolvedAttachToOptions) {
  if (resolvedAttachToOptions === void 0 || resolvedAttachToOptions === null) {
    return true;
  }
  return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;
}
function uuid() {
  let d2 = Date.now();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r = (d2 + Math.random() * 16) % 16 | 0;
    d2 = Math.floor(d2 / 16);
    return (c2 == "x" ? r : r & 3 | 8).toString(16);
  });
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return _extends({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return _extends({}, rect, {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
const _excluded2 = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"], _excluded4 = ["mainAxis", "crossAxis", "limiter"];
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data: data2,
      reset
    } = await fn({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y2 = nextY != null ? nextY : y2;
    middlewareData = _extends({}, middlewareData, {
      [name]: _extends({}, middlewareData[name], data2)
    });
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? _extends({}, rects.floating, {
    x,
    y: y2
  }) : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements
    } = state;
    const {
      element: element2,
      padding = 0
    } = evaluate(options, state) || {};
    if (element2 == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element2);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element2));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = clamp(min$1, center, max2);
    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max2 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset,
        centerOffset: center - offset + alignmentOffset
      }
    };
  }
});
const flip = function flip2(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const _evaluate2 = evaluate(options, state), {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true
      } = _evaluate2, detectOverflowOptions = _objectWithoutPropertiesLoose(_evaluate2, _excluded2);
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
const shift = function shift2(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y: y2,
        placement
      } = state;
      const _evaluate4 = evaluate(options, state), {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y3
            } = _ref;
            return {
              x: x2,
              y: y3
            };
          }
        }
      } = _evaluate4, detectOverflowOptions = _objectWithoutPropertiesLoose(_evaluate4, _excluded4);
      const coords = {
        x,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn(_extends({}, state, {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return _extends({}, limitedCoords, {
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y2
        }
      });
    }
  };
};
const limitShift = function limitShift2(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : _extends({
        mainAxis: 0,
        crossAxis: 0
      }, rawOffset);
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
function isContainingBlock(element2) {
  const webkit = isWebKit();
  const css = getComputedStyle$1(element2);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.pageXOffset,
    scrollTop: element2.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getCssDimensions(element2) {
  const css = getComputedStyle$1(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y2 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getNodeScroll(element2).scrollLeft;
}
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = _extends({}, clippingAncestor, {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    });
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache2) {
  const cachedResult = cache2.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element2).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element2, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  return getCssDimensions(element2);
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element2, polyfill2) {
  if (!isHTMLElement(element2) || getComputedStyle$1(element2).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element2);
  }
  return element2.offsetParent;
}
function getOffsetParent(element2, polyfill2) {
  const window2 = getWindow(element2);
  if (!isHTMLElement(element2)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}
const getElementRects = async function getElementRects2(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: _extends({
      x: 0,
      y: 0
    }, await getDimensionsFn(floating))
  };
};
function isRTL(element2) {
  return getComputedStyle$1(element2).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element2);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element2.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, _extends({}, options, {
        // Handle <iframe>s
        root: root.ownerDocument
      }));
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element2);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = _extends({
    platform
  }, options);
  const platformWithCache = _extends({}, mergedOptions.platform, {
    _c: cache2
  });
  return computePosition$1(reference, floating, _extends({}, mergedOptions, {
    platform: platformWithCache
  }));
};
function setupTooltip(step) {
  if (step.cleanup) {
    step.cleanup();
  }
  const attachToOptions = step._getResolvedAttachToOptions();
  let target2 = attachToOptions.element;
  const floatingUIOptions = getFloatingUIOptions(attachToOptions, step);
  const shouldCenter = shouldCenterStep(attachToOptions);
  if (shouldCenter) {
    target2 = document.body;
    const content = step.shepherdElementComponent.getElement();
    content.classList.add("shepherd-centered");
  }
  step.cleanup = autoUpdate(target2, step.el, () => {
    if (!step.el) {
      step.cleanup();
      return;
    }
    setPosition(target2, step, floatingUIOptions, shouldCenter);
  });
  step.target = attachToOptions.element;
  return floatingUIOptions;
}
function mergeTooltipConfig(tourOptions, options) {
  return {
    floatingUIOptions: cjs(tourOptions.floatingUIOptions || {}, options.floatingUIOptions || {})
  };
}
function destroyTooltip(step) {
  if (step.cleanup) {
    step.cleanup();
  }
  step.cleanup = null;
}
function setPosition(target2, step, floatingUIOptions, shouldCenter) {
  return computePosition(target2, step.el, floatingUIOptions).then(floatingUIposition(step, shouldCenter)).then((step2) => new Promise((resolve2) => {
    setTimeout(() => resolve2(step2), 300);
  })).then((step2) => {
    if (step2 && step2.el) {
      step2.el.focus({
        preventScroll: true
      });
    }
  });
}
function floatingUIposition(step, shouldCenter) {
  return ({
    x,
    y: y2,
    placement,
    middlewareData
  }) => {
    if (!step.el) {
      return step;
    }
    if (shouldCenter) {
      Object.assign(step.el.style, {
        position: "fixed",
        left: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)"
      });
    } else {
      Object.assign(step.el.style, {
        position: "absolute",
        left: `${x}px`,
        top: `${y2}px`
      });
    }
    step.el.dataset.popperPlacement = placement;
    placeArrow(step.el, middlewareData);
    return step;
  };
}
function placeArrow(el, middlewareData) {
  const arrowEl = el.querySelector(".shepherd-arrow");
  if (arrowEl && middlewareData.arrow) {
    const {
      x: arrowX,
      y: arrowY
    } = middlewareData.arrow;
    Object.assign(arrowEl.style, {
      left: arrowX != null ? `${arrowX}px` : "",
      top: arrowY != null ? `${arrowY}px` : ""
    });
  }
}
function getFloatingUIOptions(attachToOptions, step) {
  const options = {
    strategy: "absolute",
    middleware: []
  };
  const arrowEl = addArrow(step);
  const shouldCenter = shouldCenterStep(attachToOptions);
  if (!shouldCenter) {
    options.middleware.push(
      flip(),
      // Replicate PopperJS default behavior.
      shift({
        limiter: limitShift(),
        crossAxis: true
      })
    );
    if (arrowEl) {
      options.middleware.push(arrow({
        element: arrowEl
      }));
    }
    options.placement = attachToOptions.on;
  }
  return cjs(step.options.floatingUIOptions || {}, options);
}
function addArrow(step) {
  if (step.options.arrow && step.el) {
    return step.el.querySelector(".shepherd-arrow");
  }
  return false;
}
function noop() {
}
function assign(tar, src2) {
  for (const k in src2)
    tar[k] = src2[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function append(target2, node) {
  target2.appendChild(node);
}
function insert(target2, node, anchor) {
  target2.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element$1(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data2) {
  return document.createTextNode(data2);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
const always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c2) => fns.indexOf(c2) === -1 ? filtered.push(c2) : targets.push(c2));
  targets.forEach((c2) => c2());
  render_callbacks = filtered;
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = {
    $$scope: 1
  };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target2, anchor, customElement) {
  const {
    fragment,
    after_update
  } = component.$$;
  fragment && fragment.m(target2, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
}
function create_fragment$8(ctx) {
  let button;
  let button_aria_label_value;
  let button_class_value;
  let mounted2;
  let dispose;
  return {
    c() {
      button = element$1("button");
      attr(button, "aria-label", button_aria_label_value = /*label*/
      ctx[3] ? (
        /*label*/
        ctx[3]
      ) : null);
      attr(button, "class", button_class_value = `${/*classes*/
      ctx[1] || ""} shepherd-button ${/*secondary*/
      ctx[4] ? "shepherd-button-secondary" : ""}`);
      button.disabled = /*disabled*/
      ctx[2];
      attr(button, "tabindex", "0");
    },
    m(target2, anchor) {
      insert(target2, button, anchor);
      button.innerHTML = /*text*/
      ctx[5];
      if (!mounted2) {
        dispose = listen(button, "click", function() {
          if (is_function(
            /*action*/
            ctx[0]
          ))
            ctx[0].apply(this, arguments);
        });
        mounted2 = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*text*/
      32)
        button.innerHTML = /*text*/
        ctx[5];
      if (dirty & /*label*/
      8 && button_aria_label_value !== (button_aria_label_value = /*label*/
      ctx[3] ? (
        /*label*/
        ctx[3]
      ) : null)) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (dirty & /*classes, secondary*/
      18 && button_class_value !== (button_class_value = `${/*classes*/
      ctx[1] || ""} shepherd-button ${/*secondary*/
      ctx[4] ? "shepherd-button-secondary" : ""}`)) {
        attr(button, "class", button_class_value);
      }
      if (dirty & /*disabled*/
      4) {
        button.disabled = /*disabled*/
        ctx[2];
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted2 = false;
      dispose();
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let {
    config,
    step
  } = $$props;
  let action, classes, disabled, label, secondary, text2;
  function getConfigOption(option) {
    if (isFunction(option)) {
      return option = option.call(step);
    }
    return option;
  }
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(6, config = $$props2.config);
    if ("step" in $$props2)
      $$invalidate(7, step = $$props2.step);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*config, step*/
    192) {
      {
        $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);
        $$invalidate(1, classes = config.classes);
        $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);
        $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);
        $$invalidate(4, secondary = config.secondary);
        $$invalidate(5, text2 = config.text ? getConfigOption(config.text) : null);
      }
    }
  };
  return [action, classes, disabled, label, secondary, text2, config, step];
}
class Shepherd_button extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$8, safe_not_equal, {
      config: 6,
      step: 7
    });
  }
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_if_block$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*buttons*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target2, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target2, anchor);
        }
      }
      insert(target2, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*buttons, step*/
      3) {
        each_value = /*buttons*/
        ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block(ctx) {
  let shepherdbutton;
  let current;
  shepherdbutton = new Shepherd_button({
    props: {
      config: (
        /*config*/
        ctx[2]
      ),
      step: (
        /*step*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(shepherdbutton.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(shepherdbutton, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const shepherdbutton_changes = {};
      if (dirty & /*buttons*/
      2)
        shepherdbutton_changes.config = /*config*/
        ctx2[2];
      if (dirty & /*step*/
      1)
        shepherdbutton_changes.step = /*step*/
        ctx2[0];
      shepherdbutton.$set(shepherdbutton_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(shepherdbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shepherdbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(shepherdbutton, detaching);
    }
  };
}
function create_fragment$7(ctx) {
  let footer;
  let current;
  let if_block = (
    /*buttons*/
    ctx[1] && create_if_block$3(ctx)
  );
  return {
    c() {
      footer = element$1("footer");
      if (if_block)
        if_block.c();
      attr(footer, "class", "shepherd-footer");
    },
    m(target2, anchor) {
      insert(target2, footer, anchor);
      if (if_block)
        if_block.m(footer, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*buttons*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*buttons*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(footer, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(footer);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let buttons;
  let {
    step
  } = $$props;
  $$self.$$set = ($$props2) => {
    if ("step" in $$props2)
      $$invalidate(0, step = $$props2.step);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*step*/
    1) {
      $$invalidate(1, buttons = step.options.buttons);
    }
  };
  return [step, buttons];
}
class Shepherd_footer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, {
      step: 0
    });
  }
}
function create_fragment$6(ctx) {
  let button;
  let span;
  let button_aria_label_value;
  let mounted2;
  let dispose;
  return {
    c() {
      button = element$1("button");
      span = element$1("span");
      span.textContent = "";
      attr(span, "aria-hidden", "true");
      attr(button, "aria-label", button_aria_label_value = /*cancelIcon*/
      ctx[0].label ? (
        /*cancelIcon*/
        ctx[0].label
      ) : "Close Tour");
      attr(button, "class", "shepherd-cancel-icon");
      attr(button, "type", "button");
    },
    m(target2, anchor) {
      insert(target2, button, anchor);
      append(button, span);
      if (!mounted2) {
        dispose = listen(
          button,
          "click",
          /*handleCancelClick*/
          ctx[1]
        );
        mounted2 = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*cancelIcon*/
      1 && button_aria_label_value !== (button_aria_label_value = /*cancelIcon*/
      ctx2[0].label ? (
        /*cancelIcon*/
        ctx2[0].label
      ) : "Close Tour")) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted2 = false;
      dispose();
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let {
    cancelIcon,
    step
  } = $$props;
  const handleCancelClick = (e) => {
    e.preventDefault();
    step.cancel();
  };
  $$self.$$set = ($$props2) => {
    if ("cancelIcon" in $$props2)
      $$invalidate(0, cancelIcon = $$props2.cancelIcon);
    if ("step" in $$props2)
      $$invalidate(2, step = $$props2.step);
  };
  return [cancelIcon, handleCancelClick, step];
}
class Shepherd_cancel_icon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$6, safe_not_equal, {
      cancelIcon: 0,
      step: 2
    });
  }
}
function create_fragment$5(ctx) {
  let h3;
  return {
    c() {
      h3 = element$1("h3");
      attr(
        h3,
        "id",
        /*labelId*/
        ctx[1]
      );
      attr(h3, "class", "shepherd-title");
    },
    m(target2, anchor) {
      insert(target2, h3, anchor);
      ctx[3](h3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*labelId*/
      2) {
        attr(
          h3,
          "id",
          /*labelId*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(h3);
      ctx[3](null);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let {
    labelId,
    element: element2,
    title
  } = $$props;
  afterUpdate(() => {
    if (isFunction(title)) {
      $$invalidate(2, title = title());
    }
    $$invalidate(0, element2.innerHTML = title, element2);
  });
  function h3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("labelId" in $$props2)
      $$invalidate(1, labelId = $$props2.labelId);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
  };
  return [element2, labelId, title, h3_binding];
}
class Shepherd_title extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, {
      labelId: 1,
      element: 0,
      title: 2
    });
  }
}
function create_if_block_1$1(ctx) {
  let shepherdtitle;
  let current;
  shepherdtitle = new Shepherd_title({
    props: {
      labelId: (
        /*labelId*/
        ctx[0]
      ),
      title: (
        /*title*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(shepherdtitle.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(shepherdtitle, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const shepherdtitle_changes = {};
      if (dirty & /*labelId*/
      1)
        shepherdtitle_changes.labelId = /*labelId*/
        ctx2[0];
      if (dirty & /*title*/
      4)
        shepherdtitle_changes.title = /*title*/
        ctx2[2];
      shepherdtitle.$set(shepherdtitle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(shepherdtitle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shepherdtitle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(shepherdtitle, detaching);
    }
  };
}
function create_if_block$2(ctx) {
  let shepherdcancelicon;
  let current;
  shepherdcancelicon = new Shepherd_cancel_icon({
    props: {
      cancelIcon: (
        /*cancelIcon*/
        ctx[3]
      ),
      step: (
        /*step*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(shepherdcancelicon.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(shepherdcancelicon, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const shepherdcancelicon_changes = {};
      if (dirty & /*cancelIcon*/
      8)
        shepherdcancelicon_changes.cancelIcon = /*cancelIcon*/
        ctx2[3];
      if (dirty & /*step*/
      2)
        shepherdcancelicon_changes.step = /*step*/
        ctx2[1];
      shepherdcancelicon.$set(shepherdcancelicon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(shepherdcancelicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shepherdcancelicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(shepherdcancelicon, detaching);
    }
  };
}
function create_fragment$4(ctx) {
  let header;
  let t;
  let current;
  let if_block0 = (
    /*title*/
    ctx[2] && create_if_block_1$1(ctx)
  );
  let if_block1 = (
    /*cancelIcon*/
    ctx[3] && /*cancelIcon*/
    ctx[3].enabled && create_if_block$2(ctx)
  );
  return {
    c() {
      header = element$1("header");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(header, "class", "shepherd-header");
    },
    m(target2, anchor) {
      insert(target2, header, anchor);
      if (if_block0)
        if_block0.m(header, null);
      append(header, t);
      if (if_block1)
        if_block1.m(header, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*title*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(header, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*cancelIcon*/
        ctx2[3] && /*cancelIcon*/
        ctx2[3].enabled
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*cancelIcon*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(header, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(header);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let {
    labelId,
    step
  } = $$props;
  let title, cancelIcon;
  $$self.$$set = ($$props2) => {
    if ("labelId" in $$props2)
      $$invalidate(0, labelId = $$props2.labelId);
    if ("step" in $$props2)
      $$invalidate(1, step = $$props2.step);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*step*/
    2) {
      {
        $$invalidate(2, title = step.options.title);
        $$invalidate(3, cancelIcon = step.options.cancelIcon);
      }
    }
  };
  return [labelId, step, title, cancelIcon];
}
class Shepherd_header extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, {
      labelId: 0,
      step: 1
    });
  }
}
function create_fragment$3(ctx) {
  let div;
  return {
    c() {
      div = element$1("div");
      attr(div, "class", "shepherd-text");
      attr(
        div,
        "id",
        /*descriptionId*/
        ctx[1]
      );
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      ctx[3](div);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*descriptionId*/
      2) {
        attr(
          div,
          "id",
          /*descriptionId*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[3](null);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let {
    descriptionId,
    element: element2,
    step
  } = $$props;
  afterUpdate(() => {
    let {
      text: text2
    } = step.options;
    if (isFunction(text2)) {
      text2 = text2.call(step);
    }
    if (isHTMLElement$1(text2)) {
      element2.appendChild(text2);
    } else {
      $$invalidate(0, element2.innerHTML = text2, element2);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("descriptionId" in $$props2)
      $$invalidate(1, descriptionId = $$props2.descriptionId);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("step" in $$props2)
      $$invalidate(2, step = $$props2.step);
  };
  return [element2, descriptionId, step, div_binding];
}
class Shepherd_text extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, {
      descriptionId: 1,
      element: 0,
      step: 2
    });
  }
}
function create_if_block_2(ctx) {
  let shepherdheader;
  let current;
  shepherdheader = new Shepherd_header({
    props: {
      labelId: (
        /*labelId*/
        ctx[1]
      ),
      step: (
        /*step*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(shepherdheader.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(shepherdheader, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const shepherdheader_changes = {};
      if (dirty & /*labelId*/
      2)
        shepherdheader_changes.labelId = /*labelId*/
        ctx2[1];
      if (dirty & /*step*/
      4)
        shepherdheader_changes.step = /*step*/
        ctx2[2];
      shepherdheader.$set(shepherdheader_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(shepherdheader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shepherdheader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(shepherdheader, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let shepherdtext;
  let current;
  shepherdtext = new Shepherd_text({
    props: {
      descriptionId: (
        /*descriptionId*/
        ctx[0]
      ),
      step: (
        /*step*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(shepherdtext.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(shepherdtext, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const shepherdtext_changes = {};
      if (dirty & /*descriptionId*/
      1)
        shepherdtext_changes.descriptionId = /*descriptionId*/
        ctx2[0];
      if (dirty & /*step*/
      4)
        shepherdtext_changes.step = /*step*/
        ctx2[2];
      shepherdtext.$set(shepherdtext_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(shepherdtext.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shepherdtext.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(shepherdtext, detaching);
    }
  };
}
function create_if_block$1(ctx) {
  let shepherdfooter;
  let current;
  shepherdfooter = new Shepherd_footer({
    props: {
      step: (
        /*step*/
        ctx[2]
      )
    }
  });
  return {
    c() {
      create_component(shepherdfooter.$$.fragment);
    },
    m(target2, anchor) {
      mount_component(shepherdfooter, target2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const shepherdfooter_changes = {};
      if (dirty & /*step*/
      4)
        shepherdfooter_changes.step = /*step*/
        ctx2[2];
      shepherdfooter.$set(shepherdfooter_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(shepherdfooter.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shepherdfooter.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(shepherdfooter, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let div;
  let show_if_2 = !isUndefined(
    /*step*/
    ctx[2].options.title
  ) || /*step*/
  ctx[2].options.cancelIcon && /*step*/
  ctx[2].options.cancelIcon.enabled;
  let t0;
  let show_if_1 = !isUndefined(
    /*step*/
    ctx[2].options.text
  );
  let t1;
  let show_if = Array.isArray(
    /*step*/
    ctx[2].options.buttons
  ) && /*step*/
  ctx[2].options.buttons.length;
  let current;
  let if_block0 = show_if_2 && create_if_block_2(ctx);
  let if_block1 = show_if_1 && create_if_block_1(ctx);
  let if_block2 = show_if && create_if_block$1(ctx);
  return {
    c() {
      div = element$1("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div, "class", "shepherd-content");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*step*/
      4)
        show_if_2 = !isUndefined(
          /*step*/
          ctx2[2].options.title
        ) || /*step*/
        ctx2[2].options.cancelIcon && /*step*/
        ctx2[2].options.cancelIcon.enabled;
      if (show_if_2) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*step*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & /*step*/
      4)
        show_if_1 = !isUndefined(
          /*step*/
          ctx2[2].options.text
        );
      if (show_if_1) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*step*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty & /*step*/
      4)
        show_if = Array.isArray(
          /*step*/
          ctx2[2].options.buttons
        ) && /*step*/
        ctx2[2].options.buttons.length;
      if (show_if) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*step*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let {
    descriptionId,
    labelId,
    step
  } = $$props;
  $$self.$$set = ($$props2) => {
    if ("descriptionId" in $$props2)
      $$invalidate(0, descriptionId = $$props2.descriptionId);
    if ("labelId" in $$props2)
      $$invalidate(1, labelId = $$props2.labelId);
    if ("step" in $$props2)
      $$invalidate(2, step = $$props2.step);
  };
  return [descriptionId, labelId, step];
}
class Shepherd_content extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {
      descriptionId: 0,
      labelId: 1,
      step: 2
    });
  }
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element$1("div");
      attr(div, "class", "shepherd-arrow");
      attr(div, "data-popper-arrow", "");
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$1(ctx) {
  let div;
  let t;
  let shepherdcontent;
  let div_aria_describedby_value;
  let div_aria_labelledby_value;
  let current;
  let mounted2;
  let dispose;
  let if_block = (
    /*step*/
    ctx[4].options.arrow && /*step*/
    ctx[4].options.attachTo && /*step*/
    ctx[4].options.attachTo.element && /*step*/
    ctx[4].options.attachTo.on && create_if_block()
  );
  shepherdcontent = new Shepherd_content({
    props: {
      descriptionId: (
        /*descriptionId*/
        ctx[2]
      ),
      labelId: (
        /*labelId*/
        ctx[3]
      ),
      step: (
        /*step*/
        ctx[4]
      )
    }
  });
  let div_levels = [
    {
      "aria-describedby": div_aria_describedby_value = !isUndefined(
        /*step*/
        ctx[4].options.text
      ) ? (
        /*descriptionId*/
        ctx[2]
      ) : null
    },
    {
      "aria-labelledby": div_aria_labelledby_value = /*step*/
      ctx[4].options.title ? (
        /*labelId*/
        ctx[3]
      ) : null
    },
    /*dataStepId*/
    ctx[1],
    {
      role: "dialog"
    },
    {
      tabindex: "0"
    }
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  return {
    c() {
      div = element$1("div");
      if (if_block)
        if_block.c();
      t = space();
      create_component(shepherdcontent.$$.fragment);
      set_attributes(div, div_data);
      toggle_class(
        div,
        "shepherd-has-cancel-icon",
        /*hasCancelIcon*/
        ctx[5]
      );
      toggle_class(
        div,
        "shepherd-has-title",
        /*hasTitle*/
        ctx[6]
      );
      toggle_class(div, "shepherd-element", true);
    },
    m(target2, anchor) {
      insert(target2, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      mount_component(shepherdcontent, div, null);
      ctx[13](div);
      current = true;
      if (!mounted2) {
        dispose = listen(
          div,
          "keydown",
          /*handleKeyDown*/
          ctx[7]
        );
        mounted2 = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*step*/
        ctx2[4].options.arrow && /*step*/
        ctx2[4].options.attachTo && /*step*/
        ctx2[4].options.attachTo.element && /*step*/
        ctx2[4].options.attachTo.on
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block();
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const shepherdcontent_changes = {};
      if (dirty & /*descriptionId*/
      4)
        shepherdcontent_changes.descriptionId = /*descriptionId*/
        ctx2[2];
      if (dirty & /*labelId*/
      8)
        shepherdcontent_changes.labelId = /*labelId*/
        ctx2[3];
      if (dirty & /*step*/
      16)
        shepherdcontent_changes.step = /*step*/
        ctx2[4];
      shepherdcontent.$set(shepherdcontent_changes);
      set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty & /*step, descriptionId*/
      20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined(
        /*step*/
        ctx2[4].options.text
      ) ? (
        /*descriptionId*/
        ctx2[2]
      ) : null)) && {
        "aria-describedby": div_aria_describedby_value
      }, (!current || dirty & /*step, labelId*/
      24 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*step*/
      ctx2[4].options.title ? (
        /*labelId*/
        ctx2[3]
      ) : null)) && {
        "aria-labelledby": div_aria_labelledby_value
      }, dirty & /*dataStepId*/
      2 && /*dataStepId*/
      ctx2[1], {
        role: "dialog"
      }, {
        tabindex: "0"
      }]));
      toggle_class(
        div,
        "shepherd-has-cancel-icon",
        /*hasCancelIcon*/
        ctx2[5]
      );
      toggle_class(
        div,
        "shepherd-has-title",
        /*hasTitle*/
        ctx2[6]
      );
      toggle_class(div, "shepherd-element", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(shepherdcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(shepherdcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_component(shepherdcontent);
      ctx[13](null);
      mounted2 = false;
      dispose();
    }
  };
}
const KEY_TAB = 9;
const KEY_ESC = 27;
const LEFT_ARROW = 37;
const RIGHT_ARROW = 39;
function getClassesArray(classes) {
  return classes.split(" ").filter((className) => !!className.length);
}
function instance$1($$self, $$props, $$invalidate) {
  let {
    classPrefix,
    element: element2,
    descriptionId,
    firstFocusableElement,
    focusableElements,
    labelId,
    lastFocusableElement,
    step,
    dataStepId
  } = $$props;
  let hasCancelIcon, hasTitle, classes;
  const getElement = () => element2;
  onMount(() => {
    $$invalidate(1, dataStepId = {
      [`data-${classPrefix}shepherd-step-id`]: step.id
    });
    $$invalidate(9, focusableElements = element2.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]'));
    $$invalidate(8, firstFocusableElement = focusableElements[0]);
    $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);
  });
  afterUpdate(() => {
    if (classes !== step.options.classes) {
      updateDynamicClasses();
    }
  });
  function updateDynamicClasses() {
    removeClasses(classes);
    classes = step.options.classes;
    addClasses(classes);
  }
  function removeClasses(classes2) {
    if (isString(classes2)) {
      const oldClasses = getClassesArray(classes2);
      if (oldClasses.length) {
        element2.classList.remove(...oldClasses);
      }
    }
  }
  function addClasses(classes2) {
    if (isString(classes2)) {
      const newClasses = getClassesArray(classes2);
      if (newClasses.length) {
        element2.classList.add(...newClasses);
      }
    }
  }
  const handleKeyDown = (e) => {
    const {
      tour
    } = step;
    switch (e.keyCode) {
      case KEY_TAB:
        if (focusableElements.length === 0) {
          e.preventDefault();
          break;
        }
        if (e.shiftKey) {
          if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains("shepherd-element")) {
            e.preventDefault();
            lastFocusableElement.focus();
          }
        } else {
          if (document.activeElement === lastFocusableElement) {
            e.preventDefault();
            firstFocusableElement.focus();
          }
        }
        break;
      case KEY_ESC:
        if (tour.options.exitOnEsc) {
          e.stopPropagation();
          step.cancel();
        }
        break;
      case LEFT_ARROW:
        if (tour.options.keyboardNavigation) {
          e.stopPropagation();
          tour.back();
        }
        break;
      case RIGHT_ARROW:
        if (tour.options.keyboardNavigation) {
          e.stopPropagation();
          tour.next();
        }
        break;
    }
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("classPrefix" in $$props2)
      $$invalidate(11, classPrefix = $$props2.classPrefix);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("descriptionId" in $$props2)
      $$invalidate(2, descriptionId = $$props2.descriptionId);
    if ("firstFocusableElement" in $$props2)
      $$invalidate(8, firstFocusableElement = $$props2.firstFocusableElement);
    if ("focusableElements" in $$props2)
      $$invalidate(9, focusableElements = $$props2.focusableElements);
    if ("labelId" in $$props2)
      $$invalidate(3, labelId = $$props2.labelId);
    if ("lastFocusableElement" in $$props2)
      $$invalidate(10, lastFocusableElement = $$props2.lastFocusableElement);
    if ("step" in $$props2)
      $$invalidate(4, step = $$props2.step);
    if ("dataStepId" in $$props2)
      $$invalidate(1, dataStepId = $$props2.dataStepId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*step*/
    16) {
      {
        $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);
        $$invalidate(6, hasTitle = step.options && step.options.title);
      }
    }
  };
  return [element2, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];
}
class Shepherd_element extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {
      classPrefix: 11,
      element: 0,
      descriptionId: 2,
      firstFocusableElement: 8,
      focusableElements: 9,
      labelId: 3,
      lastFocusableElement: 10,
      step: 4,
      dataStepId: 1,
      getElement: 12
    });
  }
  get getElement() {
    return this.$$.ctx[12];
  }
}
class Step extends Evented {
  /**
   * Create a step
   * @param {Tour} tour The tour for the step
   * @param {object} options The options for the step
   * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.
   * @param {object} options.attachTo The element the step should be attached to on the page.
   * An object with properties `element` and `on`.
   *
   * ```js
   * const step = new Step(tour, {
   *   attachTo: { element: '.some .selector-path', on: 'left' },
   *   ...moreOptions
   * });
   * ```
   *
   * If you dont specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.
   * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear
   * in the middle of the screen, without an arrow pointing to the target.
   * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.
   * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).
   * @param {string} options.attachTo.on The optional direction to place the FloatingUI tooltip relative to the element.
   *   - Possible string values: 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'
   * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.
   * It should be an object with a string `selector` and an `event` name
   * ```js
   * const step = new Step(tour, {
   *   advanceOn: { selector: '.some .selector-path', event: 'click' },
   *   ...moreOptions
   * });
   * ```
   * `event` doesnt have to be an event inside the tour, it can be any event fired on any element on the page.
   * You can also always manually advance the Tour by calling `myTour.next()`.
   * @param {function} options.beforeShowPromise A function that returns a promise.
   * When the promise resolves, the rest of the `show` code for the step will execute.
   * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a
   * footer below the main body text.
   * @param {function} options.buttons.button.action A function executed when the button is clicked on.
   * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will
   * work inside the action.
   * You can use action to skip steps or navigate to specific steps, with something like:
   * ```js
   * action() {
   *   return this.show('some_step_name');
   * }
   * ```
   * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`
   * @param {boolean} options.buttons.button.disabled Should the button be disabled?
   * @param {string} options.buttons.button.label The aria-label text of the button
   * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button
   * @param {string} options.buttons.button.text The HTML text of the button
   * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target
   * @param {object} options.cancelIcon Options for the cancel icon
   * @param {boolean} options.cancelIcon.enabled Should a cancel  be shown in the header of the step?
   * @param {string} options.cancelIcon.label The label to add for `aria-label`
   * @param {string} options.classes A string of extra classes to add to the step's content element.
   * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is
   * highlighted (that is, when its step is active). You can then target that selector in your CSS.
   * @param {string} options.id The string to use as the `id` for the step.
   * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening
   * @param {number | { topLeft: number, bottomLeft: number, bottomRight: number, topRight: number }} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening
   * @param {object} options.floatingUIOptions Extra options to pass to FloatingUI
   * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,
   * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`
   * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and
   * define a custom action to do the scrolling, and possibly other logic.
   * @param {function} options.showOn A function that, when it returns `true`, will show the step.
   * If it returns false, the step will be skipped.
   * @param {string} options.text The text in the body of the step. It can be one of three types:
   * ```
   * - HTML string
   * - `HTMLElement` object
   * - `Function` to be executed when the step is built. It must return one the two options above.
   * ```
   * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:
   * ```
   * - HTML string
   * - `Function` to be executed when the step is built. It must return HTML string.
   * ```
   * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:
   * ```js
   * when: {
   *   show: function() {
   *     window.scrollTo(0, 0);
   *   }
   * }
   * ```
   * @return {Step} The newly created Step instance
   */
  constructor(tour, options = {}) {
    super(tour, options);
    this.tour = tour;
    this.classPrefix = this.tour.options ? normalizePrefix(this.tour.options.classPrefix) : "";
    this.styles = tour.styles;
    this._resolvedAttachTo = null;
    autoBind(this);
    this._setOptions(options);
    return this;
  }
  /**
   * Cancel the tour
   * Triggers the `cancel` event
   */
  cancel() {
    this.tour.cancel();
    this.trigger("cancel");
  }
  /**
   * Complete the tour
   * Triggers the `complete` event
   */
  complete() {
    this.tour.complete();
    this.trigger("complete");
  }
  /**
   * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.
   * Triggers `destroy` event
   */
  destroy() {
    destroyTooltip(this);
    if (isHTMLElement$1(this.el)) {
      this.el.remove();
      this.el = null;
    }
    this._updateStepTargetOnHide();
    this.trigger("destroy");
  }
  /**
   * Returns the tour for the step
   * @return {Tour} The tour instance
   */
  getTour() {
    return this.tour;
  }
  /**
   * Hide the step
   */
  hide() {
    this.tour.modal.hide();
    this.trigger("before-hide");
    if (this.el) {
      this.el.hidden = true;
    }
    this._updateStepTargetOnHide();
    this.trigger("hide");
  }
  /**
   * Resolves attachTo options.
   * @returns {{}|{element, on}}
   * @private
   */
  _resolveAttachToOptions() {
    this._resolvedAttachTo = parseAttachTo(this);
    return this._resolvedAttachTo;
  }
  /**
   * A selector for resolved attachTo options.
   * @returns {{}|{element, on}}
   * @private
   */
  _getResolvedAttachToOptions() {
    if (this._resolvedAttachTo === null) {
      return this._resolveAttachToOptions();
    }
    return this._resolvedAttachTo;
  }
  /**
   * Check if the step is open and visible
   * @return {boolean} True if the step is open and visible
   */
  isOpen() {
    return Boolean(this.el && !this.el.hidden);
  }
  /**
   * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show
   * @return {*|Promise}
   */
  show() {
    if (isFunction(this.options.beforeShowPromise)) {
      return Promise.resolve(this.options.beforeShowPromise()).then(() => this._show());
    }
    return Promise.resolve(this._show());
  }
  /**
   * Updates the options of the step.
   *
   * @param {Object} options The options for the step
   */
  updateStepOptions(options) {
    Object.assign(this.options, options);
    if (this.shepherdElementComponent) {
      this.shepherdElementComponent.$set({
        step: this
      });
    }
  }
  /**
   * Returns the element for the step
   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed
   */
  getElement() {
    return this.el;
  }
  /**
   * Returns the target for the step
   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found
   */
  getTarget() {
    return this.target;
  }
  /**
   * Creates Shepherd element for step based on options
   *
   * @return {Element} The DOM element for the step tooltip
   * @private
   */
  _createTooltipContent() {
    const descriptionId = `${this.id}-description`;
    const labelId = `${this.id}-label`;
    this.shepherdElementComponent = new Shepherd_element({
      target: this.tour.options.stepsContainer || document.body,
      props: {
        classPrefix: this.classPrefix,
        descriptionId,
        labelId,
        step: this,
        styles: this.styles
      }
    });
    return this.shepherdElementComponent.getElement();
  }
  /**
   * If a custom scrollToHandler is defined, call that, otherwise do the generic
   * scrollIntoView call.
   *
   * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,
   * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`
   * @private
   */
  _scrollTo(scrollToOptions) {
    const {
      element: element2
    } = this._getResolvedAttachToOptions();
    if (isFunction(this.options.scrollToHandler)) {
      this.options.scrollToHandler(element2);
    } else if (isElement$1(element2) && typeof element2.scrollIntoView === "function") {
      element2.scrollIntoView(scrollToOptions);
    }
  }
  /**
   * _getClassOptions gets all possible classes for the step
   * @param {Object} stepOptions The step specific options
   * @returns {String} unique string from array of classes
   * @private
   */
  _getClassOptions(stepOptions) {
    const defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;
    const stepClasses = stepOptions.classes ? stepOptions.classes : "";
    const defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : "";
    const allClasses = [...stepClasses.split(" "), ...defaultStepOptionsClasses.split(" ")];
    const uniqClasses = new Set(allClasses);
    return Array.from(uniqClasses).join(" ").trim();
  }
  /**
   * Sets the options for the step, maps `when` to events, sets up buttons
   * @param {Object} options The options for the step
   * @private
   */
  _setOptions(options = {}) {
    let tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;
    tourOptions = cjs({}, tourOptions || {});
    this.options = Object.assign({
      arrow: true
    }, tourOptions, options, mergeTooltipConfig(tourOptions, options));
    const {
      when
    } = this.options;
    this.options.classes = this._getClassOptions(options);
    this.destroy();
    this.id = this.options.id || `step-${uuid()}`;
    if (when) {
      Object.keys(when).forEach((event) => {
        this.on(event, when[event], this);
      });
    }
  }
  /**
   * Create the element and set up the FloatingUI instance
   * @private
   */
  _setupElements() {
    if (!isUndefined(this.el)) {
      this.destroy();
    }
    this.el = this._createTooltipContent();
    if (this.options.advanceOn) {
      bindAdvance(this);
    }
    setupTooltip(this);
  }
  /**
   * Triggers `before-show`, generates the tooltip DOM content,
   * sets up a FloatingUI instance for the tooltip, then triggers `show`.
   * @private
   */
  _show() {
    this.trigger("before-show");
    this._resolveAttachToOptions();
    this._setupElements();
    if (!this.tour.modal) {
      this.tour._setupModal();
    }
    this.tour.modal.setupForStep(this);
    this._styleTargetElementForStep(this);
    this.el.hidden = false;
    if (this.options.scrollTo) {
      setTimeout(() => {
        this._scrollTo(this.options.scrollTo);
      });
    }
    this.el.hidden = false;
    const content = this.shepherdElementComponent.getElement();
    const target2 = this.target || document.body;
    target2.classList.add(`${this.classPrefix}shepherd-enabled`);
    target2.classList.add(`${this.classPrefix}shepherd-target`);
    content.classList.add("shepherd-enabled");
    this.trigger("show");
  }
  /**
   * Modulates the styles of the passed step's target element, based on the step's options and
   * the tour's `modal` option, to visually emphasize the element
   *
   * @param step The step object that attaches to the element
   * @private
   */
  _styleTargetElementForStep(step) {
    const targetElement = step.target;
    if (!targetElement) {
      return;
    }
    if (step.options.highlightClass) {
      targetElement.classList.add(step.options.highlightClass);
    }
    targetElement.classList.remove("shepherd-target-click-disabled");
    if (step.options.canClickTarget === false) {
      targetElement.classList.add("shepherd-target-click-disabled");
    }
  }
  /**
   * When a step is hidden, remove the highlightClass and 'shepherd-enabled'
   * and 'shepherd-target' classes
   * @private
   */
  _updateStepTargetOnHide() {
    const target2 = this.target || document.body;
    if (this.options.highlightClass) {
      target2.classList.remove(this.options.highlightClass);
    }
    target2.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`);
  }
}
function cleanupSteps(tour) {
  if (tour) {
    const {
      steps
    } = tour;
    steps.forEach((step) => {
      if (step.options && step.options.canClickTarget === false && step.options.attachTo) {
        if (step.target instanceof HTMLElement) {
          step.target.classList.remove("shepherd-target-click-disabled");
        }
      }
    });
  }
}
function makeOverlayPath({
  width,
  height,
  x = 0,
  y: y2 = 0,
  r = 0
}) {
  const {
    innerWidth: w,
    innerHeight: h2
  } = window;
  const {
    topLeft = 0,
    topRight = 0,
    bottomRight = 0,
    bottomLeft = 0
  } = typeof r === "number" ? {
    topLeft: r,
    topRight: r,
    bottomRight: r,
    bottomLeft: r
  } : r;
  return `M${w},${h2}H0V0H${w}V${h2}ZM${x + topLeft},${y2}a${topLeft},${topLeft},0,0,0-${topLeft},${topLeft}V${height + y2 - bottomLeft}a${bottomLeft},${bottomLeft},0,0,0,${bottomLeft},${bottomLeft}H${width + x - bottomRight}a${bottomRight},${bottomRight},0,0,0,${bottomRight}-${bottomRight}V${y2 + topRight}a${topRight},${topRight},0,0,0-${topRight}-${topRight}Z`;
}
function create_fragment(ctx) {
  let svg;
  let path;
  let svg_class_value;
  let mounted2;
  let dispose;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(
        path,
        "d",
        /*pathDefinition*/
        ctx[2]
      );
      attr(svg, "class", svg_class_value = `${/*modalIsVisible*/
      ctx[1] ? "shepherd-modal-is-visible" : ""} shepherd-modal-overlay-container`);
    },
    m(target2, anchor) {
      insert(target2, svg, anchor);
      append(svg, path);
      ctx[11](svg);
      if (!mounted2) {
        dispose = listen(
          svg,
          "touchmove",
          /*_preventModalOverlayTouch*/
          ctx[3]
        );
        mounted2 = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*pathDefinition*/
      4) {
        attr(
          path,
          "d",
          /*pathDefinition*/
          ctx2[2]
        );
      }
      if (dirty & /*modalIsVisible*/
      2 && svg_class_value !== (svg_class_value = `${/*modalIsVisible*/
      ctx2[1] ? "shepherd-modal-is-visible" : ""} shepherd-modal-overlay-container`)) {
        attr(svg, "class", svg_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      ctx[11](null);
      mounted2 = false;
      dispose();
    }
  };
}
function _getScrollParent(element2) {
  if (!element2) {
    return null;
  }
  const isHtmlElement = element2 instanceof HTMLElement;
  const overflowY = isHtmlElement && window.getComputedStyle(element2).overflowY;
  const isScrollable = overflowY !== "hidden" && overflowY !== "visible";
  if (isScrollable && element2.scrollHeight >= element2.clientHeight) {
    return element2;
  }
  return _getScrollParent(element2.parentElement);
}
function _getVisibleHeight(element2, scrollParent) {
  const elementRect = element2.getBoundingClientRect();
  let top = elementRect.y || elementRect.top;
  let bottom = elementRect.bottom || top + elementRect.height;
  if (scrollParent) {
    const scrollRect = scrollParent.getBoundingClientRect();
    const scrollTop = scrollRect.y || scrollRect.top;
    const scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;
    top = Math.max(top, scrollTop);
    bottom = Math.min(bottom, scrollBottom);
  }
  const height = Math.max(bottom - top, 0);
  return {
    y: top,
    height
  };
}
function instance($$self, $$props, $$invalidate) {
  let {
    element: element2,
    openingProperties
  } = $$props;
  uuid();
  let modalIsVisible = false;
  let rafId = void 0;
  let pathDefinition;
  closeModalOpening();
  const getElement = () => element2;
  function closeModalOpening() {
    $$invalidate(4, openingProperties = {
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      r: 0
    });
  }
  function hide() {
    $$invalidate(1, modalIsVisible = false);
    _cleanupStepEventListeners();
  }
  function positionModal(modalOverlayOpeningPadding = 0, modalOverlayOpeningRadius = 0, scrollParent, targetElement) {
    if (targetElement) {
      const {
        y: y2,
        height
      } = _getVisibleHeight(targetElement, scrollParent);
      const {
        x,
        width,
        left
      } = targetElement.getBoundingClientRect();
      $$invalidate(4, openingProperties = {
        width: width + modalOverlayOpeningPadding * 2,
        height: height + modalOverlayOpeningPadding * 2,
        x: (x || left) - modalOverlayOpeningPadding,
        y: y2 - modalOverlayOpeningPadding,
        r: modalOverlayOpeningRadius
      });
    } else {
      closeModalOpening();
    }
  }
  function setupForStep(step) {
    _cleanupStepEventListeners();
    if (step.tour.options.useModalOverlay) {
      _styleForStep(step);
      show();
    } else {
      hide();
    }
  }
  function show() {
    $$invalidate(1, modalIsVisible = true);
  }
  const _preventModalBodyTouch = (e) => {
    e.preventDefault();
  };
  const _preventModalOverlayTouch = (e) => {
    e.stopPropagation();
  };
  function _addStepEventListeners() {
    window.addEventListener("touchmove", _preventModalBodyTouch, {
      passive: false
    });
  }
  function _cleanupStepEventListeners() {
    if (rafId) {
      cancelAnimationFrame(rafId);
      rafId = void 0;
    }
    window.removeEventListener("touchmove", _preventModalBodyTouch, {
      passive: false
    });
  }
  function _styleForStep(step) {
    const {
      modalOverlayOpeningPadding,
      modalOverlayOpeningRadius
    } = step.options;
    const scrollParent = _getScrollParent(step.target);
    const rafLoop = () => {
      rafId = void 0;
      positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);
      rafId = requestAnimationFrame(rafLoop);
    };
    rafLoop();
    _addStepEventListeners();
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("openingProperties" in $$props2)
      $$invalidate(4, openingProperties = $$props2.openingProperties);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*openingProperties*/
    16) {
      $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));
    }
  };
  return [element2, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];
}
class Shepherd_modal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      element: 0,
      openingProperties: 4,
      getElement: 5,
      closeModalOpening: 6,
      hide: 7,
      positionModal: 8,
      setupForStep: 9,
      show: 10
    });
  }
  get getElement() {
    return this.$$.ctx[5];
  }
  get closeModalOpening() {
    return this.$$.ctx[6];
  }
  get hide() {
    return this.$$.ctx[7];
  }
  get positionModal() {
    return this.$$.ctx[8];
  }
  get setupForStep() {
    return this.$$.ctx[9];
  }
  get show() {
    return this.$$.ctx[10];
  }
}
const Shepherd = new Evented();
class Tour extends Evented {
  /**
   * @param {Object} options The options for the tour
   * @param {boolean | function(): boolean | Promise<boolean> | function(): Promise<boolean>} options.confirmCancel If true, will issue a `window.confirm` before cancelling.
   * If it is a function(support Async Function), it will be called and wait for the return value, and will only be cancelled if the value returned is true
   * @param {string} options.confirmCancelMessage The message to display in the `window.confirm` dialog
   * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.
   * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`
   * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly
   * set to false.
   * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled
   * unless this is explicitly set to false.
   * @param {HTMLElement} options.stepsContainer An optional container element for the steps.
   * If not set, the steps will be appended to `document.body`.
   * @param {HTMLElement} options.modalContainer An optional container element for the modal.
   * If not set, the modal will be appended to `document.body`.
   * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with
   * @param {string} options.tourName An optional "name" for the tour. This will be appended to the the tour's
   * dynamically generated `id` property.
   * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened
   * modal overlay. If true, the overlay will create an opening around the target element so that it
   * can remain interactive
   * @returns {Tour}
   */
  constructor(options = {}) {
    super(options);
    autoBind(this);
    const defaultTourOptions = {
      exitOnEsc: true,
      keyboardNavigation: true
    };
    this.options = Object.assign({}, defaultTourOptions, options);
    this.classPrefix = normalizePrefix(this.options.classPrefix);
    this.steps = [];
    this.addSteps(this.options.steps);
    const events = ["active", "cancel", "complete", "inactive", "show", "start"];
    events.map((event) => {
      ((e) => {
        this.on(e, (opts) => {
          opts = opts || {};
          opts.tour = this;
          Shepherd.trigger(e, opts);
        });
      })(event);
    });
    this._setTourID();
    return this;
  }
  /**
   * Adds a new step to the tour
   * @param {Object|Step} options An object containing step options or a Step instance
   * @param {number} index The optional index to insert the step at. If undefined, the step
   * is added to the end of the array.
   * @return {Step} The newly added step
   */
  addStep(options, index) {
    let step = options;
    if (!(step instanceof Step)) {
      step = new Step(this, step);
    } else {
      step.tour = this;
    }
    if (!isUndefined(index)) {
      this.steps.splice(index, 0, step);
    } else {
      this.steps.push(step);
    }
    return step;
  }
  /**
   * Add multiple steps to the tour
   * @param {Array<object> | Array<Step>} steps The steps to add to the tour
   */
  addSteps(steps) {
    if (Array.isArray(steps)) {
      steps.forEach((step) => {
        this.addStep(step);
      });
    }
    return this;
  }
  /**
   * Go to the previous step in the tour
   */
  back() {
    const index = this.steps.indexOf(this.currentStep);
    this.show(index - 1, false);
  }
  /**
   * Calls _done() triggering the 'cancel' event
   * If `confirmCancel` is true, will show a window.confirm before cancelling
   * If `confirmCancel` is a function, will call it and wait for the return value,
   * and only cancel when the value returned is true
   */
  async cancel() {
    if (this.options.confirmCancel) {
      const confirmCancelIsFunction = typeof this.options.confirmCancel === "function";
      const cancelMessage = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?";
      const stopTour = confirmCancelIsFunction ? await this.options.confirmCancel() : window.confirm(cancelMessage);
      if (stopTour) {
        this._done("cancel");
      }
    } else {
      this._done("cancel");
    }
  }
  /**
   * Calls _done() triggering the `complete` event
   */
  complete() {
    this._done("complete");
  }
  /**
   * Gets the step from a given id
   * @param {Number|String} id The id of the step to retrieve
   * @return {Step} The step corresponding to the `id`
   */
  getById(id) {
    return this.steps.find((step) => {
      return step.id === id;
    });
  }
  /**
   * Gets the current step
   * @returns {Step|null}
   */
  getCurrentStep() {
    return this.currentStep;
  }
  /**
   * Hide the current step
   */
  hide() {
    const currentStep = this.getCurrentStep();
    if (currentStep) {
      return currentStep.hide();
    }
  }
  /**
   * Check if the tour is active
   * @return {boolean}
   */
  isActive() {
    return Shepherd.activeTour === this;
  }
  /**
   * Go to the next step in the tour
   * If we are at the end, call `complete`
   */
  next() {
    const index = this.steps.indexOf(this.currentStep);
    if (index === this.steps.length - 1) {
      this.complete();
    } else {
      this.show(index + 1, true);
    }
  }
  /**
   * Removes the step from the tour
   * @param {String} name The id for the step to remove
   */
  removeStep(name) {
    const current = this.getCurrentStep();
    this.steps.some((step, i) => {
      if (step.id === name) {
        if (step.isOpen()) {
          step.hide();
        }
        step.destroy();
        this.steps.splice(i, 1);
        return true;
      }
    });
    if (current && current.id === name) {
      this.currentStep = void 0;
      this.steps.length ? this.show(0) : this.cancel();
    }
  }
  /**
   * Show a specific step in the tour
   * @param {Number|String} key The key to look up the step by
   * @param {Boolean} forward True if we are going forward, false if backward
   */
  show(key = 0, forward = true) {
    const step = isString(key) ? this.getById(key) : this.steps[key];
    if (step) {
      this._updateStateBeforeShow();
      const shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn();
      if (shouldSkipStep) {
        this._skipStep(step, forward);
      } else {
        this.trigger("show", {
          step,
          previous: this.currentStep
        });
        this.currentStep = step;
        step.show();
      }
    }
  }
  /**
   * Start the tour
   */
  start() {
    this.trigger("start");
    this.focusedElBeforeOpen = document.activeElement;
    this.currentStep = null;
    this._setupModal();
    this._setupActiveTour();
    this.next();
  }
  /**
   * Called whenever the tour is cancelled or completed, basically anytime we exit the tour
   * @param {String} event The event name to trigger
   * @private
   */
  _done(event) {
    const index = this.steps.indexOf(this.currentStep);
    if (Array.isArray(this.steps)) {
      this.steps.forEach((step) => step.destroy());
    }
    cleanupSteps(this);
    this.trigger(event, {
      index
    });
    Shepherd.activeTour = null;
    this.trigger("inactive", {
      tour: this
    });
    if (this.modal) {
      this.modal.hide();
    }
    if (event === "cancel" || event === "complete") {
      if (this.modal) {
        const modalContainer = document.querySelector(".shepherd-modal-overlay-container");
        if (modalContainer) {
          modalContainer.remove();
        }
      }
    }
    if (isHTMLElement$1(this.focusedElBeforeOpen)) {
      this.focusedElBeforeOpen.focus();
    }
  }
  /**
   * Make this tour "active"
   * @private
   */
  _setupActiveTour() {
    this.trigger("active", {
      tour: this
    });
    Shepherd.activeTour = this;
  }
  /**
   * _setupModal create the modal container and instance
   * @private
   */
  _setupModal() {
    this.modal = new Shepherd_modal({
      target: this.options.modalContainer || document.body,
      props: {
        classPrefix: this.classPrefix,
        styles: this.styles
      }
    });
  }
  /**
   * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step
   * @param {Step} step The step to skip
   * @param {Boolean} forward True if we are going forward, false if backward
   * @private
   */
  _skipStep(step, forward) {
    const index = this.steps.indexOf(step);
    if (index === this.steps.length - 1) {
      this.complete();
    } else {
      const nextIndex = forward ? index + 1 : index - 1;
      this.show(nextIndex, forward);
    }
  }
  /**
   * Before showing, hide the current step and if the tour is not
   * already active, call `this._setupActiveTour`.
   * @private
   */
  _updateStateBeforeShow() {
    if (this.currentStep) {
      this.currentStep.hide();
    }
    if (!this.isActive()) {
      this._setupActiveTour();
    }
  }
  /**
   * Sets this.id to `${tourName}--${uuid}`
   * @private
   */
  _setTourID() {
    const tourName = this.options.tourName || "tour";
    this.id = `${tourName}--${uuid()}`;
  }
}
const isServerSide = typeof window === "undefined";
class NoOp {
  constructor() {
  }
}
if (isServerSide) {
  Object.assign(Shepherd, {
    Tour: NoOp,
    Step: NoOp
  });
} else {
  Object.assign(Shepherd, {
    Tour,
    Step
  });
}
const shepherdKey = "$shepherd";
const useShepherd = (...args) => new Shepherd.Tour(...args);
const install = function installVueShepherd(app2) {
  if (install.installed)
    return;
  install.installed = true;
  app2.config.globalProperties[shepherdKey] = useShepherd;
};
const plugin = { install };
if ("false" === {}.ES_BUILD) {
  let GlobalVue2 = null;
  if (typeof window !== "undefined") {
    GlobalVue2 = window.Vue;
  } else if (typeof global !== "undefined") {
    GlobalVue2 = global.Vue;
  }
  if (GlobalVue2) {
    GlobalVue2.use(plugin);
  }
}
const _sfc_main$4 = {
  data() {
    const store = usePlayerStore();
    const vm = this;
    const tour = {};
    const tab_tuto_enabled = false;
    const added_steps = [];
    const steps = [
      { id: "step_help" },
      { id: "step_game_name", arrow: false },
      { id: "step_invite" },
      { id: "step_start" },
      { id: "tab_label_settings", goto: "settings" },
      { parent: "settings", id: "step_settings_gauges" },
      { parent: "settings", id: "step_settings_add_gauge" },
      { parent: "settings", id: "step_settings_gauge", position: "right" },
      { parent: "settings", id: "step_settings_gauge_make_deadly" },
      { parent: "settings", id: "step_settings_gauge_delete" },
      { parent: "settings", id: "step_settings_stats" },
      { parent: "settings", id: "step_settings_add_stat" },
      { parent: "settings", id: "step_settings_stat", position: "right" },
      { parent: "settings", id: "step_settings_stat_delete", group_finish: true },
      { id: "tab_label_tags", goto: "tags" },
      { parent: "tags", id: "step_tags" },
      {
        parent: "tags",
        id: "step_tags_group_add",
        beforeShow: function() {
          return new Promise(function(resolve2) {
            let groups = vm.store.getGroupTags();
            if (groups.length === 0) {
              vm.store.addGroupTag();
            }
            resolve2();
          });
        }
      },
      {
        parent: "tags",
        id: "step_tags_group",
        beforeShow: function() {
          return new Promise(function(resolve2) {
            let groups = vm.store.getGroupTags();
            let group;
            if (groups.length === 0) {
              group = vm.store.addGroupTag();
            } else {
              group = groups[0];
            }
            if (groups[0].tags.length === 0) {
              vm.store.addTag(vm.$t("example"), group);
            }
            resolve2();
          });
        }
      },
      { parent: "tags", id: "step_tags_tag" },
      { parent: "tags", id: "step_tags_group_rename" },
      { parent: "tags", id: "step_tags_group_distribution" },
      { parent: "tags", id: "step_tags_group_distribute" },
      { parent: "tags", id: "step_tags_group_shuffle" },
      { parent: "tags", id: "step_tags_group_delete", group_finish: true },
      { id: "tab_label_characters", goto: "characters", group_finish: true },
      { id: "tab_label_poll", goto: "poll", group_finish: true },
      { id: "tab_label_challenge", goto: "challenge", group_finish: true },
      { id: "tab_label_pick", goto: "pick", finish: true }
    ];
    return {
      store,
      vm,
      tour,
      steps,
      tab_tuto_enabled,
      added_steps
    };
  },
  mounted() {
  },
  methods: {
    startTour() {
      const vm = this;
      this.added_steps = [];
      this.tour = useShepherd({
        useModalOverlay: true,
        defaultStepOptions: {
          scrollTo: true,
          cancelIcon: {
            enabled: true
          }
        }
      });
      this.steps.forEach(function(step) {
        vm.addStep(step);
      });
      this.tour.start();
    },
    getStepButtons(step) {
      const vm = this;
      let buttons = [];
      if (step.id === "step_help") {
        buttons.push(
          {
            text: function() {
              return vm.$t("see_all_tutorial");
            },
            action: function() {
              vm.tab_tuto_enabled = false;
              return vm.tour.next();
            }
          }
        );
        buttons.push(
          {
            text: function() {
              return vm.$t("see_page_tutorial");
            },
            action: function() {
              let step2 = vm.steps.findIndex((step3) => step3.id === "tab_label_" + vm.$parent.current_tab);
              vm.tab_tuto_enabled = true;
              return vm.tour.show(step2);
            },
            disabled: function() {
              return vm.$parent.current_tab === "intro";
            }
          }
        );
      } else {
        buttons.push(
          {
            text: function() {
              if (vm.tab_tuto_enabled && step.group_finish !== void 0) {
                return vm.$t("end_tab_tour");
              }
              return step.finish ? vm.$t("end_tour") : vm.$t("next");
            },
            action: function() {
              if (vm.tab_tuto_enabled && step.group_finish !== void 0) {
                return vm.tour.complete();
              }
              return vm.tour.next();
            }
          }
        );
      }
      return buttons;
    },
    addStep(step, index = void 0) {
      const vm = this;
      let new_step = {
        arrow: step.arrow ?? true,
        text: vm.$t(step.id),
        buttons: vm.getStepButtons(step)
      };
      if (typeof step.beforeShow === "function") {
        new_step.beforeShowPromise = step.beforeShow;
      }
      new_step.attachTo = {
        element: function() {
          if (step.parent !== void 0) {
            vm.$parent.changeTab(step.parent);
          } else if (step.goto !== void 0) {
            vm.$parent.changeTab(step.goto);
          }
          let element2;
          if (step.parent !== void 0) {
            element2 = vm.$parent.$refs["admin_tab_" + step.parent].$refs[step.id];
          } else {
            element2 = vm.$parent.$refs[step.id];
          }
          return element2.classList ? element2 : element2[0];
        },
        on: step.placement ?? "top",
        showOn: function() {
          return element !== null;
        }
      };
      vm.tour.addStep(new_step, index);
    }
  }
};
const Admin_vue_vue_type_style_index_0_lang = "";
const _sfc_main$3 = {
  components: {
    AdminTabIntro,
    AdminTabCharacters,
    AdminTabTags,
    AdminTabSettings,
    AdminTabPoll,
    AdminTabChallenge,
    AdminTabPick,
    AdminTour: _sfc_main$4
  },
  beforeMount() {
    let temp_game = localStorage.getItem("temp_game");
    if (temp_game) {
      let temp_game_parsed = JSON.parse(temp_game);
      localStorage.removeItem("temp_game");
      if (temp_game_parsed.peer !== null) {
        let games = JSON.parse(localStorage.getItem("games"));
        let found = games.find((element2) => element2.id === temp_game_parsed.id);
        this.store.setCurrentGame(found);
        let peer = new $416260bce337df90$export$ecd1fc136c422448(temp_game_parsed.peer);
        peer.reconnect();
        this.store.setPeer(peer);
      }
    } else if (this.store.current_game === null) {
      router.push("/home");
    }
  },
  setup() {
    const store = usePlayerStore();
    const is_live = ref[false];
    const btn_live = ref("Dmarrer la vido");
    const current_tab = ref("");
    return {
      store,
      is_live,
      btn_live,
      current_tab
    };
  },
  data() {
    return {
      stream: null,
      calls: [],
      peer: null,
      video: null,
      is_live: false,
      game_name_focused: -1,
      temp_game_name: "",
      tabs: [
        { id: "intro", label: "Introduction" },
        { id: "characters", label: "characters", tutorial: "off" },
        { id: "poll", label: "polls", tutorial: "off" },
        { id: "challenge", label: "challenge", tutorial: "off" },
        { id: "pick", label: "draw", tutorial: "off" },
        { id: "tags", label: "tags", tutorial: "blink" },
        { id: "settings", label: "settings", tutorial: "blink" }
      ]
    };
  },
  computed: {
    activeTabs: function() {
      if (this.store.current_game.tuto_on) {
        return this.tabs;
      } else {
        return this.tabs.filter((tab) => tab.tutorial !== void 0);
      }
    },
    gameLabel: function() {
      return this.game_name_focused === 0 ? this.$t("game_rename") : this.store.current_game.name;
    }
  },
  created() {
    let vm = this;
    window.addEventListener("beforeunload", function() {
      console.log("Minotaure : admin onbefore unload");
      if (vm.store.current_game !== null) {
        let temp_game = {
          "id": vm.store.current_game.id,
          "peer": vm.store.peer.id
        };
        localStorage.setItem("temp_game", JSON.stringify(temp_game));
        vm.store.saveQuit();
      }
    });
  },
  mounted() {
    let vm = this;
    let attempting_reconnect = false;
    this.current_tab = this.store.current_game.tuto_on ? "intro" : "characters";
    this.changeTab(this.current_tab);
    if (this.store.current_game.characters === void 0) {
      this.store.current_game.characters = [];
    } else {
      this.store.current_game.characters.forEach(function(character) {
        character.connection = null;
        character.watched = true;
        watch(character, vm.store.characterWatch);
      });
    }
    if (vm.store.current_game.initialized === false) {
      vm.store.current_game.stats = {
        fo1: { name: vm.$t("strength") },
        me1: { name: vm.$t("mind") }
      };
      vm.store.current_game.gauges = {
        li1: { name: vm.$t("health"), value: 10, deadly: true },
        wi1: { name: vm.$t("will"), value: 10, deadly: false }
      };
      vm.store.current_game.tag_groups = [];
      vm.store.current_game.polls = {};
      vm.store.current_game.initialized = true;
    } else {
      let init_keys = ["stats", "tag_groups", "gauges"];
      init_keys.forEach(function(init_key) {
        if (vm.store.current_game[init_key] === void 0) {
          vm.store.current_game[init_key] = [];
        }
      });
    }
    this.peer = this.store.peer;
    this.peer.on("error", function(err) {
      console.log("Minotaure : peer admin error - " + err.type);
    });
    this.peer.on("disconnected", function() {
      let count = 0;
      console.log("Minotaure : peer admin disconnected");
      if (!attempting_reconnect) {
        attempting_reconnect = true;
        let interval = setInterval(function() {
          if (vm.peer.open === true || vm.peer.destroyed === true) {
            clearInterval(interval);
            attempting_reconnect = false;
            if (vm.peer.open === true) {
              console.log("Minotaure : reconnection successfull");
            } else if (vm.peer.destroyed === true) {
              console.log("Minotaure : peer destroyed");
            }
          } else if (count < 10) {
            count += 1;
            console.log("Minotaure : reconnection attempt number " + count);
            vm.peer.reconnect();
          }
        }, 4e3);
      }
    });
    this.peer.on("connection", function(conn) {
      vm.store.connections[conn.connectionId] = conn;
      conn.on("data", function(data2) {
        if (data2.handshake === "readyForCall") {
          if (data2.version === void 0 || data2.version !== "1.0.0") {
            conn.send({
              handshake: "versionError"
            });
          } else {
            if (vm.store.current_game.game_started) {
              conn.send({
                handshake: "gameStart",
                game_token: vm.store.current_game.id
              });
            } else {
              vm.store.temp_connections.push(conn);
              conn.send({
                handshake: "gameWait",
                game_token: vm.store.current_game.id
              });
            }
          }
        } else if (data2.handshake === "readyForCharacter") {
          let message = {
            game_token: vm.store.current_game.id
          };
          let new_character;
          if (data2.token !== void 0 && data2.token !== null) {
            new_character = vm.store.retrieveCharacter(data2.token);
            if (new_character !== void 0) {
              if (data2.reset === void 0) {
                new_character.connection = conn.connectionId;
                if (!new_character.watched) {
                  new_character.watched = true;
                  watch(new_character, vm.store.characterWatch);
                }
              } else {
                new_character.connection = null;
                new_character.token = null;
              }
            }
          }
          if (new_character === void 0 || data2.reset !== void 0) {
            message.handshake = "initCharacter";
            message.game_token = vm.store.current_game.id;
            message.creation_form = {
              options: vm.store.getStartGroupTags()
            };
            conn.send(message);
          } else {
            conn.send({
              handshake: "displayCharacter",
              game_token: vm.store.current_game.id,
              character: vm.store.prepareCharacter(new_character)
            });
          }
        } else if (data2.handshake === "characterChoices") {
          vm.sendNewCharacter(data2, conn);
        } else if (data2.handshake === "pollAnswer") {
          let character = vm.store.retrieveCharacter(data2.token);
          if (character && data2.code !== void 0 && character.polls[data2.code] !== void 0) {
            vm.store.pollAddAnswer(data2.code, data2.answer);
            character.polls[data2.code].answer = data2.answer;
          }
        }
      });
      conn.on("close", function() {
        console.log("Minotaure : PJ disconnected");
      });
      conn.on("error", function(err) {
        console.log("Minotaure : connection admin error : " + err.type);
      });
    });
  },
  methods: {
    changeTab(nameRef) {
      if (this.store.current_game.tuto_on) {
        let tab_found = this.tabs.find((tab) => tab.id === nameRef);
        if (tab_found !== void 0 && tab_found.tutorial === "blink") {
          tab_found.tutorial = "on";
        }
        tab_found = this.tabs.find((tab) => tab.tutorial === "blink");
        if (tab_found === void 0) {
          this.$refs["step_start"].classList.add("attention");
        }
      }
      if (this.current_tab != null) {
        this.$refs["admin_tab_" + this.current_tab].$refs["tab"].classList.remove("open");
      }
      this.current_tab = nameRef;
      this.$refs["admin_tab_" + nameRef].$refs["tab"].classList.add("open");
    },
    shareLink(event) {
      const vm = this;
      if (window.location.origin === "null") {
        navigator.clipboard.writeText(this.store.peer.id);
        event.target.innerText = this.$t("game_id_copied");
      } else {
        navigator.clipboard.writeText(window.location.href.slice(0, location.href.lastIndexOf("/")) + "join?id=" + this.store.peer.id);
        event.target.innerText = this.$t("invite_link_copied");
      }
      setTimeout(function() {
        event.target.innerText = vm.$t("invite_to_play");
      }, 2e3);
    },
    startTour() {
      this.$refs["admin_tour"].startTour();
    },
    startGame() {
      let vm = this;
      this.store.current_game.game_started = true;
      this.store.temp_connections.forEach(function(connection) {
        connection.send({
          handshake: "gameStart",
          game_token: vm.store.current_game.id
        });
      });
      this.store._temp_connections = [];
      this.store.current_game.tuto_on = false;
      this.changeTab("characters");
    },
    gameStartRename() {
      this.game_name_focused = 1;
      this.$nextTick(() => {
        this.$refs.input_game_name.focus();
      });
      this.temp_game_name = this.store.current_game.name;
    },
    gameConfirmRename() {
      this.store.current_game.name = this.temp_game_name;
      this.store.characters.forEach((character) => character.game_name = this.temp_game_name);
      this.game_name_focused = -1;
    },
    sendNewCharacter(data2, conn) {
      let vm = this;
      let character = this.store.generateCharacter(data2, conn);
      character.connection = conn.connectionId;
      let retrieved_character = this.store.retrieveCharacter(character.token);
      retrieved_character.connection = conn.connectionId;
      if (!retrieved_character.watched) {
        retrieved_character.watched = true;
        watch(retrieved_character, this.store.characterWatch);
      }
      conn.send({
        handshake: "displayCharacter",
        game_token: vm.store.current_game.id,
        character: vm.store.prepareCharacter(character)
      });
    }
  }
};
const _hoisted_1$3 = {
  key: 0,
  id: "admin-wrapper"
};
const _hoisted_2$3 = { class: "tabs" };
const _hoisted_3$3 = ["onKeyup", "onClick"];
const _hoisted_4$3 = { class: "tab-details" };
const _hoisted_5$2 = { class: "tabs-content" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_admin_tour = resolveComponent("admin-tour");
  const _component_admin_tab_intro = resolveComponent("admin-tab-intro");
  const _component_admin_tab_characters = resolveComponent("admin-tab-characters");
  const _component_admin_tab_settings = resolveComponent("admin-tab-settings");
  const _component_admin_tab_tags = resolveComponent("admin-tab-tags");
  const _component_admin_tab_challenge = resolveComponent("admin-tab-challenge");
  const _component_admin_tab_poll = resolveComponent("admin-tab-poll");
  const _component_admin_tab_pick = resolveComponent("admin-tab-pick");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_admin_tour, { ref: "admin_tour" }, null, 512),
    $setup.store.current_game != null ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
      createBaseVNode("div", _hoisted_2$3, [
        $data.game_name_focused < 1 ? (openBlock(), createElementBlock("button", {
          key: 0,
          ref: "step_game_name",
          class: "game-name",
          onKeyup: _cache[0] || (_cache[0] = withKeys((...args) => $options.gameStartRename && $options.gameStartRename(...args), ["enter"])),
          onClick: _cache[1] || (_cache[1] = (...args) => $options.gameStartRename && $options.gameStartRename(...args))
        }, toDisplayString$1($options.gameLabel), 545)) : createCommentVNode("", true),
        withDirectives(createBaseVNode("input", {
          maxlength: "25",
          ref: "input_game_name",
          id: "input-game-name",
          type: "text",
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.temp_game_name = $event),
          onBlur: _cache[3] || (_cache[3] = (...args) => $options.gameConfirmRename && $options.gameConfirmRename(...args)),
          onKeyup: _cache[4] || (_cache[4] = withKeys((...args) => $options.gameConfirmRename && $options.gameConfirmRename(...args), ["enter"]))
        }, null, 544), [
          [vShow, $data.game_name_focused === 1],
          [vModelText, $data.temp_game_name]
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.activeTabs, (tab) => {
          return openBlock(), createElementBlock("div", {
            tabindex: "0",
            ref_for: true,
            ref: "tab_label_" + tab.id,
            onKeyup: withKeys(($event) => $options.changeTab(tab.id), ["enter"]),
            onClick: ($event) => $options.changeTab(tab.id),
            class: normalizeClass(["tab-label", { open: $setup.current_tab === tab.id, attention: tab.tutorial === "blink" && this.store.current_game.tuto_on }])
          }, toDisplayString$1(_ctx.$t(tab.label)), 43, _hoisted_3$3);
        }), 256)),
        createBaseVNode("div", _hoisted_4$3, [
          createBaseVNode("button", {
            ref: "step_help",
            onClick: _cache[5] || (_cache[5] = (...args) => $options.startTour && $options.startTour(...args)),
            class: "icon-question"
          }, toDisplayString$1(_ctx.$t("help")), 513),
          $data.peer !== void 0 ? (openBlock(), createElementBlock("button", {
            key: 0,
            ref: "step_invite",
            class: "icon-email",
            onClick: _cache[6] || (_cache[6] = (...args) => $options.shareLink && $options.shareLink(...args))
          }, toDisplayString$1(_ctx.$t("invite_to_play")), 513)) : createCommentVNode("", true),
          !$setup.store.current_game.game_started ? (openBlock(), createElementBlock("button", {
            key: 1,
            ref: "step_start",
            class: normalizeClass(["icon-play", { "btn-important": !$setup.store.current_game.tuto_on, attention: !this.store.current_game.tuto_on }]),
            onClick: _cache[7] || (_cache[7] = (...args) => $options.startGame && $options.startGame(...args))
          }, toDisplayString$1(_ctx.$t("start")), 3)) : createCommentVNode("", true)
        ])
      ]),
      createBaseVNode("div", _hoisted_5$2, [
        createVNode(_component_admin_tab_intro, { ref: "admin_tab_intro" }, null, 512),
        createVNode(_component_admin_tab_characters, { ref: "admin_tab_characters" }, null, 512),
        createVNode(_component_admin_tab_settings, { ref: "admin_tab_settings" }, null, 512),
        createVNode(_component_admin_tab_tags, { ref: "admin_tab_tags" }, null, 512),
        createVNode(_component_admin_tab_challenge, { ref: "admin_tab_challenge" }, null, 512),
        createVNode(_component_admin_tab_poll, { ref: "admin_tab_poll" }, null, 512),
        createVNode(_component_admin_tab_pick, { ref: "admin_tab_pick" }, null, 512)
      ])
    ])) : createCommentVNode("", true)
  ], 64);
}
const Admin = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const Player_vue_vue_type_style_index_0_scoped_4d20dbba_lang = "";
const _sfc_main$2 = {
  setup() {
    const character = ref({});
    const freeze = ref(false);
    return {
      freeze,
      character
    };
  },
  data() {
    const store = usePlayerStore();
    return {
      store,
      option_picked: [],
      name_picked: "",
      pseudo_picked: "",
      creation_form: false,
      gameStart: false,
      answers: []
    };
  },
  beforeMount() {
    window.addEventListener("beforeunload", (event) => {
      if (this.store.connection !== null) {
        localStorage.setItem("temp_peer", true);
        this.store.connection.close();
        this.store._leaving = true;
      }
    });
  },
  computed: {
    characterIsInvalid: function() {
      return this.name_picked === "" || this.creation_form !== false && this.option_picked !== void 0 && this.option_picked.length !== this.creation_form.options.length;
    },
    activePolls: function() {
      if (this.character.polls !== void 0 && Object.entries(this.character.polls).length) {
        let active_polls = Object.values(this.character.polls).filter(function(poll) {
          return poll.active !== void 0 && poll.active && poll.answer === void 0;
        });
        return active_polls.length > 0;
      }
      return false;
    }
  },
  mounted() {
    this.store.stopReconnect();
    this.freeze = true;
    this.store._leaving = false;
    this.store.setTempPeer(localStorage.getItem("temp_peer"));
    let gm_id = localStorage.getItem("gm_id");
    if (this.store.peer == null || this.store.temp_peer !== null) {
      this.store.join(gm_id, true);
    } else {
      this.handshake();
    }
    this.store.$subscribe((mutation, state) => {
      if (this.store.connection !== null && this.store.temp_peer !== null) {
        this.store.setTempPeer(null);
        this.handshake();
      }
    });
  },
  methods: {
    handshake() {
      let vm = this;
      this.store._leaving = false;
      console.log("Minotaure : handshake received");
      console.log(this.store.peer.id);
      this.store.connection.send({
        handshake: "readyForCall",
        version: "1.0.0"
      });
      console.log("Minotaure : ready for transaction");
      this.store.connection.once("close", function() {
        console.log("Minotaure - connection closed");
        vm.freeze = true;
        if (!vm.store.leaving) {
          vm.store._leaving = false;
          if (vm.store.should_reconnect === -1) {
            router.push("/join");
            vm.store.setMessage("Partie termine");
          } else if (vm.store.should_reconnect === 0) {
            vm.store.startReconnect();
          }
        }
      });
      this.store.connection.on("data", function(data2) {
        console.log("data received");
        if (data2.handshake !== void 0) {
          console.log(data2.handshake);
          if (data2.handshake === "versionError") {
            vm.store.setShouldReconnect(-1);
            vm.store.connection.close();
            vm.store.setMessage("Version incompatible");
          }
          if (data2.handshake === "disconnectGracefully") {
            vm.store.setShouldReconnect(-1);
          } else if (data2.handshake === "gameWait") {
            vm.gameStart = false;
          } else if (data2.handshake === "gameStart") {
            vm.gameStart = true;
            let found = vm.findGame(data2.game_token);
            if (found !== void 0) {
              vm.store.connection.send({ handshake: "readyForCharacter", token: found.character_token });
            } else {
              vm.store.connection.send({ handshake: "readyForCharacter" });
            }
          } else if (data2.handshake === "initCharacter") {
            let games = vm.getLocalGames();
            let foundIndex = games.findIndex((element2) => element2.game_token === data2.game_token);
            if (foundIndex > -1) {
              games.splice(foundIndex, 1);
              localStorage.setItem("games_player", JSON.stringify(games));
            }
            vm.gameStart = true;
            vm.freeze = false;
            vm.creation_form = data2.creation_form;
          } else if (data2.handshake === "displayCharacter") {
            vm.gameStart = true;
            vm.freeze = false;
            let found = vm.findGame(data2.game_token);
            if (found === void 0) {
              let games = vm.getLocalGames();
              games.push({
                game_token: data2.game_token,
                character_token: data2.character.token
              });
              localStorage.setItem("games_player", JSON.stringify(games));
            }
            vm.creation_form = false;
            vm.character = data2.character;
          }
        }
      });
    },
    getLocalGames() {
      let games_str = localStorage.getItem("games_player");
      if (games_str !== null) {
        return JSON.parse(games_str);
      }
      localStorage.setItem("games_player", JSON.stringify([]));
      return [];
    },
    findGame(id) {
      let games = localStorage.getItem("games_player");
      if (games !== null) {
        games = JSON.parse(games);
        return games.find((element2) => element2.game_token === id);
      }
      return void 0;
    },
    sendCharacter() {
      let vm = this;
      if (this.creation_form.options.length && (this.option_picked === void 0 || this.option_picked.length !== this.creation_form.options.length)) {
        return true;
      }
      if (this.name_picked !== "") {
        this.store.connection.send({
          handshake: "characterChoices",
          choices: this.option_picked,
          name: this.name_picked,
          pseudo: this.pseudo_picked,
          token: vm.character.token
        });
      }
      this.name_picked = "";
      this.option_picked = [];
      this.creation_form = false;
    },
    sendAnswer(key) {
      let vm = this;
      this.store.connection.send({
        handshake: "pollAnswer",
        answer: this.answers[key],
        code: key,
        token: vm.character.token
      });
    },
    newCharacter() {
      let vm = this;
      let foundIndex;
      let games = this.getLocalGames();
      if (games.length) {
        foundIndex = games.findIndex((element2) => element2.game_token === vm.character.game_token);
      }
      if (foundIndex) {
        games.splice(foundIndex, 1);
        localStorage.setItem("games_player", JSON.stringify(games));
      }
      this.store.connection.send({
        handshake: "readyForCharacter",
        token: vm.character.token,
        reset: true
      });
    }
  }
};
const _withScopeId = (n) => (pushScopeId("data-v-4d20dbba"), n = n(), popScopeId(), n);
const _hoisted_1$2 = {
  key: 0,
  class: "game-name"
};
const _hoisted_2$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "lds-ripple" }, [
  /* @__PURE__ */ createBaseVNode("div"),
  /* @__PURE__ */ createBaseVNode("div")
], -1));
const _hoisted_3$2 = {
  key: 0,
  class: "game-wait"
};
const _hoisted_4$2 = {
  key: 1,
  id: "creation",
  class: "vertical-wrapper"
};
const _hoisted_5$1 = { for: "name" };
const _hoisted_6$1 = { for: "pseudo" };
const _hoisted_7$1 = { class: "group-choice" };
const _hoisted_8$1 = ["for"];
const _hoisted_9$1 = ["id", "onUpdate:modelValue"];
const _hoisted_10$1 = ["value"];
const _hoisted_11$1 = ["disabled"];
const _hoisted_12$1 = {
  key: 2,
  class: "vertical-wrapper polls"
};
const _hoisted_13$1 = { class: "poll-wrapper" };
const _hoisted_14 = {
  key: 0,
  class: "poll-content"
};
const _hoisted_15 = { class: "title" };
const _hoisted_16 = ["value", "name", "id", "onUpdate:modelValue"];
const _hoisted_17 = ["for"];
const _hoisted_18 = ["onClick"];
const _hoisted_19 = {
  key: 3,
  class: "vertical-wrapper",
  id: "sheet"
};
const _hoisted_20 = { class: "character-names" };
const _hoisted_21 = { class: "character-name" };
const _hoisted_22 = {
  key: 0,
  class: "pseudo"
};
const _hoisted_23 = { class: "indicator" };
const _hoisted_24 = { class: "indicator" };
const _hoisted_25 = { class: "tags" };
const _hoisted_26 = { key: 0 };
const _hoisted_27 = {
  key: 4,
  class: "vertical-wrapper"
};
const _hoisted_28 = { class: "character-name" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    $setup.character.game_name !== void 0 ? (openBlock(), createElementBlock("span", _hoisted_1$2, toDisplayString$1($setup.character.game_name), 1)) : createCommentVNode("", true),
    createBaseVNode("div", {
      id: "player-sheet",
      class: normalizeClass(["small-wrapper", { disabled: $setup.freeze }])
    }, [
      _hoisted_2$2,
      !$data.gameStart ? (openBlock(), createElementBlock("div", _hoisted_3$2, toDisplayString$1(_ctx.$t("waiting_for_game_start")), 1)) : createCommentVNode("", true),
      $data.creation_form ? (openBlock(), createElementBlock("div", _hoisted_4$2, [
        createBaseVNode("label", _hoisted_5$1, toDisplayString$1(_ctx.$t("char_name")), 1),
        withDirectives(createBaseVNode("input", {
          maxlength: "12",
          type: "text",
          id: "name",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.name_picked = $event),
          onKeyup: _cache[1] || (_cache[1] = withKeys(($event) => this.$refs["pseudo"].focus(), ["enter"]))
        }, null, 544), [
          [vModelText, $data.name_picked]
        ]),
        createBaseVNode("label", _hoisted_6$1, toDisplayString$1(_ctx.$t("user_name")), 1),
        withDirectives(createBaseVNode("input", {
          ref: "pseudo",
          maxlength: "12",
          type: "text",
          id: "pseudo",
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.pseudo_picked = $event),
          onKeyup: _cache[3] || (_cache[3] = withKeys(($event) => $options.sendCharacter(), ["enter"]))
        }, null, 544), [
          [vModelText, $data.pseudo_picked]
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.creation_form.options, (option, group_key) => {
          return openBlock(), createElementBlock("div", _hoisted_7$1, [
            createBaseVNode("label", {
              for: "tag-group-" + group_key
            }, toDisplayString$1(_ctx.$t("your_char")), 9, _hoisted_8$1),
            withDirectives(createBaseVNode("select", {
              id: "tag-group-" + group_key,
              "onUpdate:modelValue": ($event) => $data.option_picked[group_key] = $event
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(option.tags, (value, key, index) => {
                return openBlock(), createElementBlock("option", {
                  value: value.code
                }, toDisplayString$1(value.label), 9, _hoisted_10$1);
              }), 256))
            ], 8, _hoisted_9$1), [
              [vModelSelect, $data.option_picked[group_key]]
            ])
          ]);
        }), 256)),
        createBaseVNode("button", {
          disabled: $options.characterIsInvalid,
          onClick: _cache[4] || (_cache[4] = ($event) => $options.sendCharacter())
        }, toDisplayString$1(_ctx.$t("submit_your_char")), 9, _hoisted_11$1)
      ])) : $options.activePolls ? (openBlock(), createElementBlock("div", _hoisted_12$1, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.character.polls, (poll, key, index) => {
          return openBlock(), createElementBlock("div", _hoisted_13$1, [
            poll.active && poll.answer === void 0 ? (openBlock(), createElementBlock("div", _hoisted_14, [
              createBaseVNode("span", _hoisted_15, toDisplayString$1(poll.label), 1),
              (openBlock(true), createElementBlock(Fragment, null, renderList(poll.options, (option, poll_key) => {
                return openBlock(), createElementBlock("span", null, [
                  withDirectives(createBaseVNode("input", {
                    type: "radio",
                    value: poll_key,
                    name: "poll_" + key,
                    id: "poll_" + key + "_" + poll_key,
                    "onUpdate:modelValue": ($event) => $data.answers[key] = $event
                  }, null, 8, _hoisted_16), [
                    [vModelRadio, $data.answers[key]]
                  ]),
                  createBaseVNode("label", {
                    for: "poll_" + key + "_" + poll_key
                  }, toDisplayString$1(option), 9, _hoisted_17)
                ]);
              }), 256)),
              createBaseVNode("button", {
                onClick: ($event) => $options.sendAnswer(key)
              }, toDisplayString$1(_ctx.$t("send_answer")), 9, _hoisted_18)
            ])) : createCommentVNode("", true)
          ]);
        }), 256))
      ])) : $setup.character.alive ? (openBlock(), createElementBlock("div", _hoisted_19, [
        createBaseVNode("div", _hoisted_20, [
          createBaseVNode("span", _hoisted_21, toDisplayString$1($setup.character.name), 1),
          $setup.character.pseudo ? (openBlock(), createElementBlock("span", _hoisted_22, toDisplayString$1($setup.character.pseudo), 1)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.character.gauges, (gauge) => {
            return openBlock(), createElementBlock("span", null, [
              createBaseVNode("span", null, toDisplayString$1(gauge.label), 1),
              createBaseVNode("span", _hoisted_23, toDisplayString$1(gauge.value), 1)
            ]);
          }), 256))
        ]),
        createBaseVNode("div", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.character.stats, (stat) => {
            return openBlock(), createElementBlock("span", null, [
              createBaseVNode("span", null, toDisplayString$1(stat.label), 1),
              createBaseVNode("span", _hoisted_24, toDisplayString$1(stat.value), 1)
            ]);
          }), 256))
        ]),
        createBaseVNode("div", _hoisted_25, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.character.tags, (tag) => {
            return openBlock(), createElementBlock("span", null, toDisplayString$1(tag.label), 1);
          }), 256))
        ]),
        $setup.character.challenge !== void 0 && Object.entries($setup.character.challenge).length ? (openBlock(), createElementBlock("ul", _hoisted_26, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.character.challenge.message, (message) => {
            return openBlock(), createElementBlock("li", null, toDisplayString$1(message), 1);
          }), 256))
        ])) : createCommentVNode("", true)
      ])) : (openBlock(), createElementBlock("div", _hoisted_27, [
        createBaseVNode("span", _hoisted_28, toDisplayString$1(_ctx.$t("is_dead", { charname: $setup.character.name })), 1),
        createBaseVNode("button", {
          onKeyup: _cache[5] || (_cache[5] = withKeys((...args) => $options.newCharacter && $options.newCharacter(...args), ["enter"])),
          onClick: _cache[6] || (_cache[6] = (...args) => $options.newCharacter && $options.newCharacter(...args))
        }, toDisplayString$1(_ctx.$t("create_new_char")), 33)
      ]))
    ], 2)
  ], 64);
}
const Player = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-4d20dbba"]]);
const Continue_vue_vue_type_style_index_0_scoped_88819342_lang = "";
const _sfc_main$1 = {
  setup() {
    const version2 = "1.0.0";
    const versions = version2.split(".");
    let games_storage = localStorage.getItem("games");
    games_storage = games_storage == null ? [] : JSON.parse(games_storage);
    const games = ref(games_storage);
    return {
      games,
      versions,
      version: version2
    };
  },
  data() {
    const store = usePlayerStore();
    return {
      store,
      ask_id: false,
      id_admin: "",
      btn_text: "",
      activated: -1,
      confirmDelete: false
    };
  },
  mounted() {
    localStorage.removeItem("temp_game");
  },
  computed: {
    hasDeprecatedGames() {
      return this.games.findIndex((game) => this.versionIsDeprecated(game.version)) > -1;
    },
    titleContinue() {
      const vm = this;
      if (this.ask_id) {
        let found = this.games.find((game) => game.id === vm.ask_id);
        if (found) {
          return this.$t("continue_game", { name: found.name });
        }
      }
      return this.$t("game_manage");
    }
  },
  methods: {
    versionIsDeprecated(game_version) {
      if (game_version === void 0) {
        return false;
      } else {
        let numbers = game_version.split(".");
        return numbers[0] !== this.versions[0] || numbers[1] !== this.versions[1];
      }
    },
    formatDate(dateString) {
      const date = new Date(dateString);
      return new Intl.DateTimeFormat("en-GB").format(date);
    },
    deleteGame(id, event) {
      if (!this.confirmDelete) {
        event.target.innerText = this.$t("confirm_question");
        this.confirmDelete = true;
      } else {
        let found = this.games.findIndex((element2) => element2.id === id);
        if (found > -1) {
          this.games.splice(found, 1);
          localStorage.setItem("games", JSON.stringify(this.games));
        }
        this.confirmDelete = false;
        this.activated = -1;
      }
    },
    deleteAllGames(event) {
      if (!this.confirmDelete) {
        event.target.innerText = this.$t("confirm_question");
        this.confirmDelete = true;
      } else {
        this.games = [];
        localStorage.setItem("games", JSON.stringify(this.games));
        this.confirmDelete = false;
        this.activated = -1;
      }
    },
    askPublicId(id) {
      const vm = this;
      this.id_admin = "";
      if (this.store.peer) {
        this.store.peer.destroy();
      }
      this.ask_id = id;
      let peer = new $416260bce337df90$export$ecd1fc136c422448();
      peer.on("open", function(conn) {
        vm.store.setPeer(peer);
        console.log(peer.id);
        vm.id_admin = peer.id;
      });
    },
    cancelContinue() {
      this.ask_id = false;
    },
    continueGame() {
      const vm = this;
      let found = this.games.find((element2) => element2.id === this.ask_id);
      if (found) {
        this.store.setCurrentGame(found);
        this.store.current_game.game_started = false;
        if (this.id_admin !== "" && this.store.peer.id !== this.id_admin) {
          this.store.peer.destroy();
          let peer = new $416260bce337df90$export$ecd1fc136c422448(this.id_admin);
          peer.on("open", function() {
            vm.store.setPeer(peer);
          });
        }
        router.push("/admin");
      }
    }
  }
};
const _hoisted_1$1 = { class: "small-wrapper menu-wrapper" };
const _hoisted_2$1 = ["innerHTML"];
const _hoisted_3$1 = { class: "game" };
const _hoisted_4$1 = { class: "title" };
const _hoisted_5 = {
  key: 0,
  class: "danger"
};
const _hoisted_6 = {
  key: 0,
  class: "date"
};
const _hoisted_7 = { key: 0 };
const _hoisted_8 = ["onClick"];
const _hoisted_9 = ["onClick"];
const _hoisted_10 = ["onClick"];
const _hoisted_11 = {
  key: 2,
  class: "vertical-wrapper"
};
const _hoisted_12 = {
  key: 4,
  class: "continue-game"
};
const _hoisted_13 = { for: "id_admin" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_link = resolveComponent("router-link");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("h1", null, toDisplayString$1($options.titleContinue), 1),
    createBaseVNode("div", _hoisted_1$1, [
      $options.hasDeprecatedGames ? (openBlock(), createElementBlock("span", {
        key: 0,
        innerHTML: _ctx.$t("warning_version", { version: $setup.version })
      }, null, 8, _hoisted_2$1)) : createCommentVNode("", true),
      !$data.ask_id ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList($setup.games, (game, key) => {
        return openBlock(), createElementBlock("div", _hoisted_3$1, [
          createBaseVNode("div", _hoisted_4$1, [
            createBaseVNode("span", null, [
              createTextVNode(toDisplayString$1(game.name), 1),
              game.version !== void 0 && $options.versionIsDeprecated(game.version) ? (openBlock(), createElementBlock("span", _hoisted_5, "*")) : createCommentVNode("", true)
            ]),
            $data.activated !== key ? (openBlock(), createElementBlock("span", _hoisted_6, toDisplayString$1($options.formatDate(game.date)), 1)) : createCommentVNode("", true)
          ]),
          $data.activated !== key ? (openBlock(), createElementBlock("span", _hoisted_7, toDisplayString$1(_ctx.$t("count_personnage", game.characters.length, { count: game.characters.length })), 1)) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(["hidden-mobile", { active: $data.activated === key }])
          }, [
            createBaseVNode("button", {
              class: "btn-valid",
              onClick: ($event) => $options.askPublicId(game.id)
            }, toDisplayString$1(_ctx.$t("continue")), 9, _hoisted_8),
            createBaseVNode("button", {
              class: "btn-danger",
              onClick: ($event) => $options.deleteGame(game.id, $event)
            }, toDisplayString$1(_ctx.$t("delete")), 9, _hoisted_9)
          ], 2),
          $data.activated !== key ? (openBlock(), createElementBlock("button", {
            key: 1,
            class: "visible-mobile",
            onClick: ($event) => {
              $data.activated = key;
            }
          }, toDisplayString$1(_ctx.$t("see_more")), 9, _hoisted_10)) : createCommentVNode("", true)
        ]);
      }), 256)) : createCommentVNode("", true),
      !$setup.games.length ? (openBlock(), createElementBlock("div", _hoisted_11, [
        createBaseVNode("span", null, toDisplayString$1(_ctx.$t("any_game")), 1),
        createVNode(_component_router_link, { to: "/create" }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString$1(_ctx.$t("game_create")), 1)
          ]),
          _: 1
        })
      ])) : createCommentVNode("", true),
      $setup.games.length > 1 && !$data.ask_id ? (openBlock(), createElementBlock("button", {
        key: 3,
        class: "btn-danger delete-all",
        onClick: _cache[0] || (_cache[0] = ($event) => $options.deleteAllGames($event))
      }, toDisplayString$1(_ctx.$t("delete_all_games")), 1)) : createCommentVNode("", true),
      $data.ask_id ? (openBlock(), createElementBlock("div", _hoisted_12, [
        withDirectives(createBaseVNode("input", {
          name: "id_admin",
          type: "text",
          id: "id_admin",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.id_admin = $event)
        }, null, 512), [
          [vModelText, $data.id_admin]
        ]),
        createBaseVNode("label", _hoisted_13, toDisplayString$1(_ctx.$t("game_id_help")), 1),
        createBaseVNode("button", {
          class: "btn-valid",
          onClick: _cache[2] || (_cache[2] = ($event) => $options.continueGame())
        }, toDisplayString$1(_ctx.$t("start_game")), 1),
        createBaseVNode("button", {
          onClick: _cache[3] || (_cache[3] = ($event) => $options.cancelContinue())
        }, toDisplayString$1(_ctx.$t("cancel")), 1)
      ])) : createCommentVNode("", true)
    ])
  ], 64);
}
const Continue = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-88819342"]]);
/*!
 * qrcode.vue v3.4.1
 * A Vue.js component to generate QRCode.
 *  2017-2023 @scopewu(https://github.com/scopewu)
 * MIT License.
 */
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var qrcodegen;
(function(qrcodegen2) {
  var QrCode = (
    /** @class */
    function() {
      function QrCode2(version2, errorCorrectionLevel, dataCodewords, msk) {
        this.version = version2;
        this.errorCorrectionLevel = errorCorrectionLevel;
        this.modules = [];
        this.isFunction = [];
        if (version2 < QrCode2.MIN_VERSION || version2 > QrCode2.MAX_VERSION)
          throw new RangeError("Version value out of range");
        if (msk < -1 || msk > 7)
          throw new RangeError("Mask value out of range");
        this.size = version2 * 4 + 17;
        var row = [];
        for (var i = 0; i < this.size; i++)
          row.push(false);
        for (var i = 0; i < this.size; i++) {
          this.modules.push(row.slice());
          this.isFunction.push(row.slice());
        }
        this.drawFunctionPatterns();
        var allCodewords = this.addEccAndInterleave(dataCodewords);
        this.drawCodewords(allCodewords);
        if (msk == -1) {
          var minPenalty = 1e9;
          for (var i = 0; i < 8; i++) {
            this.applyMask(i);
            this.drawFormatBits(i);
            var penalty = this.getPenaltyScore();
            if (penalty < minPenalty) {
              msk = i;
              minPenalty = penalty;
            }
            this.applyMask(i);
          }
        }
        assert(0 <= msk && msk <= 7);
        this.mask = msk;
        this.applyMask(msk);
        this.drawFormatBits(msk);
        this.isFunction = [];
      }
      QrCode2.encodeText = function(text2, ecl) {
        var segs = qrcodegen2.QrSegment.makeSegments(text2);
        return QrCode2.encodeSegments(segs, ecl);
      };
      QrCode2.encodeBinary = function(data2, ecl) {
        var seg = qrcodegen2.QrSegment.makeBytes(data2);
        return QrCode2.encodeSegments([seg], ecl);
      };
      QrCode2.encodeSegments = function(segs, ecl, minVersion, maxVersion, mask, boostEcl) {
        if (minVersion === void 0) {
          minVersion = 1;
        }
        if (maxVersion === void 0) {
          maxVersion = 40;
        }
        if (mask === void 0) {
          mask = -1;
        }
        if (boostEcl === void 0) {
          boostEcl = true;
        }
        if (!(QrCode2.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode2.MAX_VERSION) || mask < -1 || mask > 7)
          throw new RangeError("Invalid value");
        var version2;
        var dataUsedBits;
        for (version2 = minVersion; ; version2++) {
          var dataCapacityBits_1 = QrCode2.getNumDataCodewords(version2, ecl) * 8;
          var usedBits = QrSegment.getTotalBits(segs, version2);
          if (usedBits <= dataCapacityBits_1) {
            dataUsedBits = usedBits;
            break;
          }
          if (version2 >= maxVersion)
            throw new RangeError("Data too long");
        }
        for (var _i2 = 0, _a2 = [QrCode2.Ecc.MEDIUM, QrCode2.Ecc.QUARTILE, QrCode2.Ecc.HIGH]; _i2 < _a2.length; _i2++) {
          var newEcl = _a2[_i2];
          if (boostEcl && dataUsedBits <= QrCode2.getNumDataCodewords(version2, newEcl) * 8)
            ecl = newEcl;
        }
        var bb = [];
        for (var _b = 0, segs_1 = segs; _b < segs_1.length; _b++) {
          var seg = segs_1[_b];
          appendBits(seg.mode.modeBits, 4, bb);
          appendBits(seg.numChars, seg.mode.numCharCountBits(version2), bb);
          for (var _c = 0, _d = seg.getData(); _c < _d.length; _c++) {
            var b = _d[_c];
            bb.push(b);
          }
        }
        assert(bb.length == dataUsedBits);
        var dataCapacityBits = QrCode2.getNumDataCodewords(version2, ecl) * 8;
        assert(bb.length <= dataCapacityBits);
        appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
        appendBits(0, (8 - bb.length % 8) % 8, bb);
        assert(bb.length % 8 == 0);
        for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
          appendBits(padByte, 8, bb);
        var dataCodewords = [];
        while (dataCodewords.length * 8 < bb.length)
          dataCodewords.push(0);
        bb.forEach(function(b2, i) {
          return dataCodewords[i >>> 3] |= b2 << 7 - (i & 7);
        });
        return new QrCode2(version2, ecl, dataCodewords, mask);
      };
      QrCode2.prototype.getModule = function(x, y2) {
        return 0 <= x && x < this.size && 0 <= y2 && y2 < this.size && this.modules[y2][x];
      };
      QrCode2.prototype.getModules = function() {
        return this.modules;
      };
      QrCode2.prototype.drawFunctionPatterns = function() {
        for (var i = 0; i < this.size; i++) {
          this.setFunctionModule(6, i, i % 2 == 0);
          this.setFunctionModule(i, 6, i % 2 == 0);
        }
        this.drawFinderPattern(3, 3);
        this.drawFinderPattern(this.size - 4, 3);
        this.drawFinderPattern(3, this.size - 4);
        var alignPatPos = this.getAlignmentPatternPositions();
        var numAlign = alignPatPos.length;
        for (var i = 0; i < numAlign; i++) {
          for (var j = 0; j < numAlign; j++) {
            if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
              this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
          }
        }
        this.drawFormatBits(0);
        this.drawVersion();
      };
      QrCode2.prototype.drawFormatBits = function(mask) {
        var data2 = this.errorCorrectionLevel.formatBits << 3 | mask;
        var rem = data2;
        for (var i = 0; i < 10; i++)
          rem = rem << 1 ^ (rem >>> 9) * 1335;
        var bits = (data2 << 10 | rem) ^ 21522;
        assert(bits >>> 15 == 0);
        for (var i = 0; i <= 5; i++)
          this.setFunctionModule(8, i, getBit(bits, i));
        this.setFunctionModule(8, 7, getBit(bits, 6));
        this.setFunctionModule(8, 8, getBit(bits, 7));
        this.setFunctionModule(7, 8, getBit(bits, 8));
        for (var i = 9; i < 15; i++)
          this.setFunctionModule(14 - i, 8, getBit(bits, i));
        for (var i = 0; i < 8; i++)
          this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
        for (var i = 8; i < 15; i++)
          this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
        this.setFunctionModule(8, this.size - 8, true);
      };
      QrCode2.prototype.drawVersion = function() {
        if (this.version < 7)
          return;
        var rem = this.version;
        for (var i = 0; i < 12; i++)
          rem = rem << 1 ^ (rem >>> 11) * 7973;
        var bits = this.version << 12 | rem;
        assert(bits >>> 18 == 0);
        for (var i = 0; i < 18; i++) {
          var color = getBit(bits, i);
          var a = this.size - 11 + i % 3;
          var b = Math.floor(i / 3);
          this.setFunctionModule(a, b, color);
          this.setFunctionModule(b, a, color);
        }
      };
      QrCode2.prototype.drawFinderPattern = function(x, y2) {
        for (var dy = -4; dy <= 4; dy++) {
          for (var dx = -4; dx <= 4; dx++) {
            var dist = Math.max(Math.abs(dx), Math.abs(dy));
            var xx = x + dx;
            var yy = y2 + dy;
            if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
              this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
          }
        }
      };
      QrCode2.prototype.drawAlignmentPattern = function(x, y2) {
        for (var dy = -2; dy <= 2; dy++) {
          for (var dx = -2; dx <= 2; dx++)
            this.setFunctionModule(x + dx, y2 + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
        }
      };
      QrCode2.prototype.setFunctionModule = function(x, y2, isDark) {
        this.modules[y2][x] = isDark;
        this.isFunction[y2][x] = true;
      };
      QrCode2.prototype.addEccAndInterleave = function(data2) {
        var ver = this.version;
        var ecl = this.errorCorrectionLevel;
        if (data2.length != QrCode2.getNumDataCodewords(ver, ecl))
          throw new RangeError("Invalid argument");
        var numBlocks = QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
        var blockEccLen = QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
        var rawCodewords = Math.floor(QrCode2.getNumRawDataModules(ver) / 8);
        var numShortBlocks = numBlocks - rawCodewords % numBlocks;
        var shortBlockLen = Math.floor(rawCodewords / numBlocks);
        var blocks = [];
        var rsDiv = QrCode2.reedSolomonComputeDivisor(blockEccLen);
        for (var i = 0, k = 0; i < numBlocks; i++) {
          var dat = data2.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
          k += dat.length;
          var ecc = QrCode2.reedSolomonComputeRemainder(dat, rsDiv);
          if (i < numShortBlocks)
            dat.push(0);
          blocks.push(dat.concat(ecc));
        }
        var result = [];
        var _loop_1 = function(i2) {
          blocks.forEach(function(block, j) {
            if (i2 != shortBlockLen - blockEccLen || j >= numShortBlocks)
              result.push(block[i2]);
          });
        };
        for (var i = 0; i < blocks[0].length; i++) {
          _loop_1(i);
        }
        assert(result.length == rawCodewords);
        return result;
      };
      QrCode2.prototype.drawCodewords = function(data2) {
        if (data2.length != Math.floor(QrCode2.getNumRawDataModules(this.version) / 8))
          throw new RangeError("Invalid argument");
        var i = 0;
        for (var right = this.size - 1; right >= 1; right -= 2) {
          if (right == 6)
            right = 5;
          for (var vert = 0; vert < this.size; vert++) {
            for (var j = 0; j < 2; j++) {
              var x = right - j;
              var upward = (right + 1 & 2) == 0;
              var y2 = upward ? this.size - 1 - vert : vert;
              if (!this.isFunction[y2][x] && i < data2.length * 8) {
                this.modules[y2][x] = getBit(data2[i >>> 3], 7 - (i & 7));
                i++;
              }
            }
          }
        }
        assert(i == data2.length * 8);
      };
      QrCode2.prototype.applyMask = function(mask) {
        if (mask < 0 || mask > 7)
          throw new RangeError("Mask value out of range");
        for (var y2 = 0; y2 < this.size; y2++) {
          for (var x = 0; x < this.size; x++) {
            var invert = void 0;
            switch (mask) {
              case 0:
                invert = (x + y2) % 2 == 0;
                break;
              case 1:
                invert = y2 % 2 == 0;
                break;
              case 2:
                invert = x % 3 == 0;
                break;
              case 3:
                invert = (x + y2) % 3 == 0;
                break;
              case 4:
                invert = (Math.floor(x / 3) + Math.floor(y2 / 2)) % 2 == 0;
                break;
              case 5:
                invert = x * y2 % 2 + x * y2 % 3 == 0;
                break;
              case 6:
                invert = (x * y2 % 2 + x * y2 % 3) % 2 == 0;
                break;
              case 7:
                invert = ((x + y2) % 2 + x * y2 % 3) % 2 == 0;
                break;
              default:
                throw new Error("Unreachable");
            }
            if (!this.isFunction[y2][x] && invert)
              this.modules[y2][x] = !this.modules[y2][x];
          }
        }
      };
      QrCode2.prototype.getPenaltyScore = function() {
        var result = 0;
        for (var y2 = 0; y2 < this.size; y2++) {
          var runColor = false;
          var runX = 0;
          var runHistory = [0, 0, 0, 0, 0, 0, 0];
          for (var x = 0; x < this.size; x++) {
            if (this.modules[y2][x] == runColor) {
              runX++;
              if (runX == 5)
                result += QrCode2.PENALTY_N1;
              else if (runX > 5)
                result++;
            } else {
              this.finderPenaltyAddHistory(runX, runHistory);
              if (!runColor)
                result += this.finderPenaltyCountPatterns(runHistory) * QrCode2.PENALTY_N3;
              runColor = this.modules[y2][x];
              runX = 1;
            }
          }
          result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode2.PENALTY_N3;
        }
        for (var x = 0; x < this.size; x++) {
          var runColor = false;
          var runY = 0;
          var runHistory = [0, 0, 0, 0, 0, 0, 0];
          for (var y2 = 0; y2 < this.size; y2++) {
            if (this.modules[y2][x] == runColor) {
              runY++;
              if (runY == 5)
                result += QrCode2.PENALTY_N1;
              else if (runY > 5)
                result++;
            } else {
              this.finderPenaltyAddHistory(runY, runHistory);
              if (!runColor)
                result += this.finderPenaltyCountPatterns(runHistory) * QrCode2.PENALTY_N3;
              runColor = this.modules[y2][x];
              runY = 1;
            }
          }
          result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * QrCode2.PENALTY_N3;
        }
        for (var y2 = 0; y2 < this.size - 1; y2++) {
          for (var x = 0; x < this.size - 1; x++) {
            var color = this.modules[y2][x];
            if (color == this.modules[y2][x + 1] && color == this.modules[y2 + 1][x] && color == this.modules[y2 + 1][x + 1])
              result += QrCode2.PENALTY_N2;
          }
        }
        var dark = 0;
        for (var _i2 = 0, _a2 = this.modules; _i2 < _a2.length; _i2++) {
          var row = _a2[_i2];
          dark = row.reduce(function(sum, color2) {
            return sum + (color2 ? 1 : 0);
          }, dark);
        }
        var total = this.size * this.size;
        var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
        assert(0 <= k && k <= 9);
        result += k * QrCode2.PENALTY_N4;
        assert(0 <= result && result <= 2568888);
        return result;
      };
      QrCode2.prototype.getAlignmentPatternPositions = function() {
        if (this.version == 1)
          return [];
        else {
          var numAlign = Math.floor(this.version / 7) + 2;
          var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
          var result = [6];
          for (var pos = this.size - 7; result.length < numAlign; pos -= step)
            result.splice(1, 0, pos);
          return result;
        }
      };
      QrCode2.getNumRawDataModules = function(ver) {
        if (ver < QrCode2.MIN_VERSION || ver > QrCode2.MAX_VERSION)
          throw new RangeError("Version number out of range");
        var result = (16 * ver + 128) * ver + 64;
        if (ver >= 2) {
          var numAlign = Math.floor(ver / 7) + 2;
          result -= (25 * numAlign - 10) * numAlign - 55;
          if (ver >= 7)
            result -= 36;
        }
        assert(208 <= result && result <= 29648);
        return result;
      };
      QrCode2.getNumDataCodewords = function(ver, ecl) {
        return Math.floor(QrCode2.getNumRawDataModules(ver) / 8) - QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      };
      QrCode2.reedSolomonComputeDivisor = function(degree) {
        if (degree < 1 || degree > 255)
          throw new RangeError("Degree out of range");
        var result = [];
        for (var i = 0; i < degree - 1; i++)
          result.push(0);
        result.push(1);
        var root = 1;
        for (var i = 0; i < degree; i++) {
          for (var j = 0; j < result.length; j++) {
            result[j] = QrCode2.reedSolomonMultiply(result[j], root);
            if (j + 1 < result.length)
              result[j] ^= result[j + 1];
          }
          root = QrCode2.reedSolomonMultiply(root, 2);
        }
        return result;
      };
      QrCode2.reedSolomonComputeRemainder = function(data2, divisor) {
        var result = divisor.map(function(_) {
          return 0;
        });
        var _loop_2 = function(b2) {
          var factor = b2 ^ result.shift();
          result.push(0);
          divisor.forEach(function(coef, i) {
            return result[i] ^= QrCode2.reedSolomonMultiply(coef, factor);
          });
        };
        for (var _i2 = 0, data_1 = data2; _i2 < data_1.length; _i2++) {
          var b = data_1[_i2];
          _loop_2(b);
        }
        return result;
      };
      QrCode2.reedSolomonMultiply = function(x, y2) {
        if (x >>> 8 != 0 || y2 >>> 8 != 0)
          throw new RangeError("Byte out of range");
        var z2 = 0;
        for (var i = 7; i >= 0; i--) {
          z2 = z2 << 1 ^ (z2 >>> 7) * 285;
          z2 ^= (y2 >>> i & 1) * x;
        }
        assert(z2 >>> 8 == 0);
        return z2;
      };
      QrCode2.prototype.finderPenaltyCountPatterns = function(runHistory) {
        var n = runHistory[1];
        assert(n <= this.size * 3);
        var core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
        return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
      };
      QrCode2.prototype.finderPenaltyTerminateAndCount = function(currentRunColor, currentRunLength, runHistory) {
        if (currentRunColor) {
          this.finderPenaltyAddHistory(currentRunLength, runHistory);
          currentRunLength = 0;
        }
        currentRunLength += this.size;
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        return this.finderPenaltyCountPatterns(runHistory);
      };
      QrCode2.prototype.finderPenaltyAddHistory = function(currentRunLength, runHistory) {
        if (runHistory[0] == 0)
          currentRunLength += this.size;
        runHistory.pop();
        runHistory.unshift(currentRunLength);
      };
      QrCode2.MIN_VERSION = 1;
      QrCode2.MAX_VERSION = 40;
      QrCode2.PENALTY_N1 = 3;
      QrCode2.PENALTY_N2 = 3;
      QrCode2.PENALTY_N3 = 40;
      QrCode2.PENALTY_N4 = 10;
      QrCode2.ECC_CODEWORDS_PER_BLOCK = [
        // Version: (note that index 0 is for padding, and is set to an illegal value)
        //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
        [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
        [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
        [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
        [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
        // High
      ];
      QrCode2.NUM_ERROR_CORRECTION_BLOCKS = [
        // Version: (note that index 0 is for padding, and is set to an illegal value)
        //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
        [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
        [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
        [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
        [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
        // High
      ];
      return QrCode2;
    }()
  );
  qrcodegen2.QrCode = QrCode;
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || val >>> len != 0)
      throw new RangeError("Value out of range");
    for (var i = len - 1; i >= 0; i--)
      bb.push(val >>> i & 1);
  }
  function getBit(x, i) {
    return (x >>> i & 1) != 0;
  }
  function assert(cond) {
    if (!cond)
      throw new Error("Assertion error");
  }
  var QrSegment = (
    /** @class */
    function() {
      function QrSegment2(mode, numChars, bitData) {
        this.mode = mode;
        this.numChars = numChars;
        this.bitData = bitData;
        if (numChars < 0)
          throw new RangeError("Invalid argument");
        this.bitData = bitData.slice();
      }
      QrSegment2.makeBytes = function(data2) {
        var bb = [];
        for (var _i2 = 0, data_2 = data2; _i2 < data_2.length; _i2++) {
          var b = data_2[_i2];
          appendBits(b, 8, bb);
        }
        return new QrSegment2(QrSegment2.Mode.BYTE, data2.length, bb);
      };
      QrSegment2.makeNumeric = function(digits) {
        if (!QrSegment2.isNumeric(digits))
          throw new RangeError("String contains non-numeric characters");
        var bb = [];
        for (var i = 0; i < digits.length; ) {
          var n = Math.min(digits.length - i, 3);
          appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
          i += n;
        }
        return new QrSegment2(QrSegment2.Mode.NUMERIC, digits.length, bb);
      };
      QrSegment2.makeAlphanumeric = function(text2) {
        if (!QrSegment2.isAlphanumeric(text2))
          throw new RangeError("String contains unencodable characters in alphanumeric mode");
        var bb = [];
        var i;
        for (i = 0; i + 2 <= text2.length; i += 2) {
          var temp = QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)) * 45;
          temp += QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i + 1));
          appendBits(temp, 11, bb);
        }
        if (i < text2.length)
          appendBits(QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text2.charAt(i)), 6, bb);
        return new QrSegment2(QrSegment2.Mode.ALPHANUMERIC, text2.length, bb);
      };
      QrSegment2.makeSegments = function(text2) {
        if (text2 == "")
          return [];
        else if (QrSegment2.isNumeric(text2))
          return [QrSegment2.makeNumeric(text2)];
        else if (QrSegment2.isAlphanumeric(text2))
          return [QrSegment2.makeAlphanumeric(text2)];
        else
          return [QrSegment2.makeBytes(QrSegment2.toUtf8ByteArray(text2))];
      };
      QrSegment2.makeEci = function(assignVal) {
        var bb = [];
        if (assignVal < 0)
          throw new RangeError("ECI assignment value out of range");
        else if (assignVal < 1 << 7)
          appendBits(assignVal, 8, bb);
        else if (assignVal < 1 << 14) {
          appendBits(2, 2, bb);
          appendBits(assignVal, 14, bb);
        } else if (assignVal < 1e6) {
          appendBits(6, 3, bb);
          appendBits(assignVal, 21, bb);
        } else
          throw new RangeError("ECI assignment value out of range");
        return new QrSegment2(QrSegment2.Mode.ECI, 0, bb);
      };
      QrSegment2.isNumeric = function(text2) {
        return QrSegment2.NUMERIC_REGEX.test(text2);
      };
      QrSegment2.isAlphanumeric = function(text2) {
        return QrSegment2.ALPHANUMERIC_REGEX.test(text2);
      };
      QrSegment2.prototype.getData = function() {
        return this.bitData.slice();
      };
      QrSegment2.getTotalBits = function(segs, version2) {
        var result = 0;
        for (var _i2 = 0, segs_2 = segs; _i2 < segs_2.length; _i2++) {
          var seg = segs_2[_i2];
          var ccbits = seg.mode.numCharCountBits(version2);
          if (seg.numChars >= 1 << ccbits)
            return Infinity;
          result += 4 + ccbits + seg.bitData.length;
        }
        return result;
      };
      QrSegment2.toUtf8ByteArray = function(str) {
        str = encodeURI(str);
        var result = [];
        for (var i = 0; i < str.length; i++) {
          if (str.charAt(i) != "%")
            result.push(str.charCodeAt(i));
          else {
            result.push(parseInt(str.substring(i + 1, i + 3), 16));
            i += 2;
          }
        }
        return result;
      };
      QrSegment2.NUMERIC_REGEX = /^[0-9]*$/;
      QrSegment2.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
      QrSegment2.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
      return QrSegment2;
    }()
  );
  qrcodegen2.QrSegment = QrSegment;
})(qrcodegen || (qrcodegen = {}));
(function(qrcodegen2) {
  (function(QrCode) {
    var Ecc = (
      /** @class */
      function() {
        function Ecc2(ordinal, formatBits) {
          this.ordinal = ordinal;
          this.formatBits = formatBits;
        }
        Ecc2.LOW = new Ecc2(0, 1);
        Ecc2.MEDIUM = new Ecc2(1, 0);
        Ecc2.QUARTILE = new Ecc2(2, 3);
        Ecc2.HIGH = new Ecc2(3, 2);
        return Ecc2;
      }()
    );
    QrCode.Ecc = Ecc;
  })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
(function(qrcodegen2) {
  (function(QrSegment) {
    var Mode = (
      /** @class */
      function() {
        function Mode2(modeBits, numBitsCharCount) {
          this.modeBits = modeBits;
          this.numBitsCharCount = numBitsCharCount;
        }
        Mode2.prototype.numCharCountBits = function(ver) {
          return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
        };
        Mode2.NUMERIC = new Mode2(1, [10, 12, 14]);
        Mode2.ALPHANUMERIC = new Mode2(2, [9, 11, 13]);
        Mode2.BYTE = new Mode2(4, [8, 16, 16]);
        Mode2.KANJI = new Mode2(8, [8, 10, 12]);
        Mode2.ECI = new Mode2(7, [0, 0, 0]);
        return Mode2;
      }()
    );
    QrSegment.Mode = Mode;
  })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var QR = qrcodegen;
var defaultErrorCorrectLevel = "H";
var ErrorCorrectLevelMap = {
  L: QR.QrCode.Ecc.LOW,
  M: QR.QrCode.Ecc.MEDIUM,
  Q: QR.QrCode.Ecc.QUARTILE,
  H: QR.QrCode.Ecc.HIGH
};
var SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return false;
  }
  return true;
}();
function validErrorCorrectLevel(level) {
  return level in ErrorCorrectLevelMap;
}
function generatePath(modules, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var ops = [];
  modules.forEach(function(row, y2) {
    var start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push("M".concat(start + margin, " ").concat(y2 + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push("M".concat(x + margin, ",").concat(y2 + margin, " h1v1H").concat(x + margin, "z"));
        } else {
          ops.push("M".concat(start + margin, ",").concat(y2 + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
}
var QRCodeProps = {
  value: {
    type: String,
    required: true,
    default: ""
  },
  size: {
    type: Number,
    default: 100
  },
  level: {
    type: String,
    default: defaultErrorCorrectLevel,
    validator: function(l) {
      return validErrorCorrectLevel(l);
    }
  },
  background: {
    type: String,
    default: "#fff"
  },
  foreground: {
    type: String,
    default: "#000"
  },
  margin: {
    type: Number,
    required: false,
    default: 0
  }
};
var QRCodeVueProps = __assign(__assign({}, QRCodeProps), { renderAs: {
  type: String,
  required: false,
  default: "canvas",
  validator: function(as) {
    return ["canvas", "svg"].indexOf(as) > -1;
  }
} });
var QRCodeSvg = defineComponent({
  name: "QRCodeSvg",
  props: QRCodeProps,
  setup: function(props) {
    var numCells = ref(0);
    var fgPath = ref("");
    var generate = function() {
      var value = props.value, level = props.level, margin = props.margin;
      var cells = QR.QrCode.encodeText(value, ErrorCorrectLevelMap[level]).getModules();
      numCells.value = cells.length + margin * 2;
      fgPath.value = generatePath(cells, margin);
    };
    generate();
    onUpdated(generate);
    return function() {
      return h$1("svg", {
        width: props.size,
        height: props.size,
        "shape-rendering": "crispEdges",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 ".concat(numCells.value, " ").concat(numCells.value)
      }, [
        h$1("path", {
          fill: props.background,
          d: "M0,0 h".concat(numCells.value, "v").concat(numCells.value, "H0z")
        }),
        h$1("path", { fill: props.foreground, d: fgPath.value })
      ]);
    };
  }
});
var QRCodeCanvas = defineComponent({
  name: "QRCodeCanvas",
  props: QRCodeProps,
  setup: function(props) {
    var canvasEl = ref(null);
    var generate = function() {
      var value = props.value, level = props.level, size2 = props.size, margin = props.margin, background = props.background, foreground = props.foreground;
      var canvas = canvasEl.value;
      if (!canvas) {
        return;
      }
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return;
      }
      var cells = QR.QrCode.encodeText(value, ErrorCorrectLevelMap[level]).getModules();
      var numCells = cells.length + margin * 2;
      var devicePixelRatio = window.devicePixelRatio || 1;
      var scale = size2 / numCells * devicePixelRatio;
      canvas.height = canvas.width = size2 * devicePixelRatio;
      ctx.scale(scale, scale);
      ctx.fillStyle = background;
      ctx.fillRect(0, 0, numCells, numCells);
      ctx.fillStyle = foreground;
      if (SUPPORTS_PATH2D) {
        ctx.fill(new Path2D(generatePath(cells, margin)));
      } else {
        cells.forEach(function(row, rdx) {
          row.forEach(function(cell, cdx) {
            if (cell) {
              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
            }
          });
        });
      }
    };
    onMounted(generate);
    onUpdated(generate);
    return function() {
      return h$1("canvas", {
        ref: canvasEl,
        style: { width: "".concat(props.size, "px"), height: "".concat(props.size, "px") }
      });
    };
  }
});
var QrcodeVue = defineComponent({
  name: "Qrcode",
  render: function() {
    var _a2 = this.$props, renderAs = _a2.renderAs, value = _a2.value, _size = _a2.size, _margin = _a2.margin, _level = _a2.level, background = _a2.background, foreground = _a2.foreground;
    var size2 = _size >>> 0;
    var margin = _margin >>> 0;
    var level = validErrorCorrectLevel(_level) ? _level : defaultErrorCorrectLevel;
    return h$1(renderAs === "svg" ? QRCodeSvg : QRCodeCanvas, { value, size: size2, margin, level, background, foreground });
  },
  props: QRCodeVueProps
});
var Sr = (n, i, a) => {
  if (!i.has(n))
    throw TypeError("Cannot " + a);
}, _a = (n, i, a) => (Sr(n, i, "read from private field"), a ? a.call(n) : i.get(n)), $a = (n, i, a) => {
  if (i.has(n))
    throw TypeError("Cannot add the same private member more than once");
  i instanceof WeakSet ? i.add(n) : i.set(n, a);
}, Sa = (n, i, a, c2) => (Sr(n, i, "write to private field"), c2 ? c2.call(n, a) : i.set(n, a), a);
const vr = [
  "aztec",
  "code_128",
  "code_39",
  "code_93",
  "codabar",
  "data_matrix",
  "ean_13",
  "ean_8",
  "itf",
  "pdf417",
  "qr_code",
  "upc_a",
  "upc_e",
  "unknown"
];
function Pa(n) {
  if (Pr(n))
    return {
      width: n.naturalWidth,
      height: n.naturalHeight
    };
  if (Tr(n))
    return {
      width: n.width.baseVal.value,
      height: n.height.baseVal.value
    };
  if (Er(n))
    return {
      width: n.videoWidth,
      height: n.videoHeight
    };
  if (Ta(n))
    return {
      width: n.width,
      height: n.height
    };
  if (Or(n))
    return {
      width: n.width,
      height: n.height
    };
  if (Ea(n))
    return {
      width: n.width,
      height: n.height
    };
  if (Mr(n))
    return {
      width: n.displayWidth,
      height: n.displayHeight
    };
  throw new TypeError(
    "The provided value is not of type '(Blob or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or ImageData or OffscreenCanvas or SVGImageElement or VideoFrame)'."
  );
}
function Pr(n) {
  try {
    return n instanceof HTMLImageElement;
  } catch (i) {
    return false;
  }
}
function Tr(n) {
  try {
    return n instanceof SVGImageElement;
  } catch (i) {
    return false;
  }
}
function Er(n) {
  try {
    return n instanceof HTMLVideoElement;
  } catch (i) {
    return false;
  }
}
function Ta(n) {
  try {
    return n instanceof HTMLCanvasElement;
  } catch (i) {
    return false;
  }
}
function Or(n) {
  try {
    return n instanceof ImageBitmap;
  } catch (i) {
    return false;
  }
}
function Ea(n) {
  try {
    return n instanceof OffscreenCanvas;
  } catch (i) {
    return false;
  }
}
function Mr(n) {
  try {
    return n instanceof VideoFrame;
  } catch (i) {
    return false;
  }
}
function Oa(n) {
  try {
    return n instanceof Blob;
  } catch (i) {
    return false;
  }
}
function Ma(n) {
  try {
    return n instanceof ImageData;
  } catch (i) {
    return false;
  }
}
function Aa(n, i) {
  try {
    const a = new OffscreenCanvas(n, i);
    if (a.getContext("2d") instanceof OffscreenCanvasRenderingContext2D)
      return a;
    throw void 0;
  } catch (a) {
    const c2 = document.createElement("canvas");
    return c2.width = n, c2.height = i, c2;
  }
}
async function Ar(n) {
  if (Pr(n) && !await Ra(n))
    throw new DOMException(
      "Failed to load or decode HTMLImageElement.",
      "InvalidStateError"
    );
  if (Tr(n) && !await ka(n))
    throw new DOMException(
      "Failed to load or decode SVGImageElement.",
      "InvalidStateError"
    );
  if (Mr(n) && Fa(n))
    throw new DOMException("VideoFrame is closed.", "InvalidStateError");
  if (Er(n) && (n.readyState === 0 || n.readyState === 1))
    throw new DOMException("Invalid element or state.", "InvalidStateError");
  if (Or(n) && Ua(n))
    throw new DOMException(
      "The image source is detached.",
      "InvalidStateError"
    );
  const { width: i, height: a } = Pa(n);
  if (i === 0 || a === 0)
    return null;
  const c2 = Aa(i, a).getContext("2d");
  c2.drawImage(n, 0, 0);
  try {
    return c2.getImageData(0, 0, i, a);
  } catch (d2) {
    throw new DOMException("Source would taint origin.", "SecurityError");
  }
}
async function Da(n) {
  let i;
  try {
    i = await createImageBitmap(n);
  } catch (a) {
    throw new DOMException(
      "Failed to load or decode Blob.",
      "InvalidStateError"
    );
  }
  return await Ar(i);
}
async function xa(n) {
  if (Oa(n))
    return await Da(n);
  if (Ma(n)) {
    if (Ia(n))
      throw new DOMException(
        "The image data has been detached.",
        "InvalidStateError"
      );
    return n;
  }
  return await Ar(n);
}
async function Ra(n) {
  try {
    return await n.decode(), true;
  } catch (i) {
    return false;
  }
}
async function ka(n) {
  var i;
  try {
    return await ((i = n.decode) == null ? void 0 : i.call(n)), true;
  } catch (a) {
    return false;
  }
}
function Fa(n) {
  return n.format === null;
}
function Ia(n) {
  return n.data.buffer.byteLength === 0;
}
function Ua(n) {
  return n.width === 0 && n.height === 0;
}
function mr(n, i) {
  return n instanceof DOMException ? new DOMException(`${i}: ${n.message}`, n.name) : n instanceof Error ? new n.constructor(`${i}: ${n.message}`) : new Error(`${i}: ${n}`);
}
const yr = (n) => {
  let i;
  const a = /* @__PURE__ */ new Set(), c2 = (v, w) => {
    const C = typeof v == "function" ? v(i) : v;
    if (!Object.is(C, i)) {
      const y2 = i;
      i = w ?? typeof C != "object" ? C : Object.assign({}, i, C), a.forEach((_) => _(i, y2));
    }
  }, d2 = () => i, h2 = { setState: c2, getState: d2, subscribe: (v) => (a.add(v), () => a.delete(v)), destroy: () => {
    a.clear();
  } };
  return i = n(c2, d2, h2), h2;
}, ja = (n) => n ? yr(n) : yr, Wa = {
  locateFile: (n, i) => {
    var a;
    const c2 = (a = n.match(/_(.+?)\.wasm$/)) == null ? void 0 : a[1];
    return c2 ? `https://cdn.jsdelivr.net/npm/@sec-ant/zxing-wasm@2.1.3/dist/${c2}/${n}` : i + n;
  }
}, Se = ja()(() => ({
  zxingModuleWeakMap: /* @__PURE__ */ new WeakMap(),
  zxingModuleOverrides: Wa
}));
function Dr(n, i = Se.getState().zxingModuleOverrides) {
  const { zxingModuleWeakMap: a } = Se.getState(), c2 = a.get(
    n
  );
  if (c2 && Object.is(i, Se.getState().zxingModuleOverrides))
    return c2;
  {
    Se.setState({
      zxingModuleOverrides: i
    });
    const d2 = n(i);
    return a.set(n, d2), d2;
  }
}
const gr = [
  "Aztec",
  "Codabar",
  "Code128",
  "Code39",
  "Code93",
  "DataBar",
  "DataBarExpanded",
  "DataMatrix",
  "EAN-13",
  "EAN-8",
  "ITF",
  "Linear-Codes",
  "Matrix-Codes",
  "MaxiCode",
  "MicroQRCode",
  "None",
  "PDF417",
  "QRCode",
  "UPC-A",
  "UPC-E"
], de = {
  tryHarder: true,
  formats: [],
  maxSymbols: 255
};
async function La(n, {
  tryHarder: i = de.tryHarder,
  formats: a = de.formats,
  maxSymbols: c2 = de.maxSymbols
} = de, d2) {
  const h2 = await Dr(
    d2,
    Se.getState().zxingModuleOverrides
  ), {
    data: v,
    width: w,
    height: C,
    data: { byteLength: y2 }
  } = n, _ = h2._malloc(y2);
  h2.HEAP8.set(v, _);
  const S = h2.readBarcodesFromPixmap(
    _,
    w,
    C,
    i,
    Ha(a),
    c2
  );
  h2._free(_);
  const $ = [];
  for (let j = 0; j < S.size(); ++j) {
    const U2 = S.get(j);
    $.push({
      ...U2,
      format: Va(U2.format)
    });
  }
  return $;
}
function Ha(n) {
  return n.join("|");
}
function Va(n) {
  const i = wr(n);
  let a = 0, c2 = gr.length - 1;
  for (; a <= c2; ) {
    const d2 = Math.floor((a + c2) / 2), h2 = gr[d2], v = wr(h2);
    if (v === i)
      return h2;
    v < i ? a = d2 + 1 : c2 = d2 - 1;
  }
  return "None";
}
function wr(n) {
  return n.toLowerCase().replace(/_-\[\]/g, "");
}
var xr = (() => {
  var n = import.meta.url;
  return function(i = {}) {
    var a = i, c2, d2;
    a.ready = new Promise((e, t) => {
      c2 = e, d2 = t;
    });
    var h2 = Object.assign({}, a), v = "./this.program", w = typeof window == "object", C = typeof importScripts == "function";
    typeof process == "object" && typeof process.versions == "object" && process.versions.node;
    var y2 = "";
    function _(e) {
      return a.locateFile ? a.locateFile(e, y2) : y2 + e;
    }
    var S;
    (w || C) && (C ? y2 = self.location.href : typeof document < "u" && document.currentScript && (y2 = document.currentScript.src), n && (y2 = n), y2.indexOf("blob:") !== 0 ? y2 = y2.substr(0, y2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : y2 = "", C && (S = (e) => {
      var t = new XMLHttpRequest();
      return t.open("GET", e, false), t.responseType = "arraybuffer", t.send(null), new Uint8Array(t.response);
    })), a.print || console.log.bind(console);
    var $ = a.printErr || console.error.bind(console);
    Object.assign(a, h2), h2 = null, a.arguments && a.arguments, a.thisProgram && (v = a.thisProgram), a.quit && a.quit;
    var j;
    a.wasmBinary && (j = a.wasmBinary), a.noExitRuntime, typeof WebAssembly != "object" && Ce("no native wasm support detected");
    var U2, O2, z2 = false, M, A, B, ee, W2, L, be2, Te;
    function Ee() {
      var e = U2.buffer;
      a.HEAP8 = M = new Int8Array(e), a.HEAP16 = B = new Int16Array(e), a.HEAP32 = W2 = new Int32Array(e), a.HEAPU8 = A = new Uint8Array(e), a.HEAPU16 = ee = new Uint16Array(e), a.HEAPU32 = L = new Uint32Array(e), a.HEAPF32 = be2 = new Float32Array(e), a.HEAPF64 = Te = new Float64Array(e);
    }
    var Oe, je = [], We = [], Le = [];
    function ut() {
      if (a.preRun)
        for (typeof a.preRun == "function" && (a.preRun = [a.preRun]); a.preRun.length; )
          ct(a.preRun.shift());
      ht(je);
    }
    function Me() {
      ht(We);
    }
    function He() {
      if (a.postRun)
        for (typeof a.postRun == "function" && (a.postRun = [a.postRun]); a.postRun.length; )
          ue2(a.postRun.shift());
      ht(Le);
    }
    function ct(e) {
      je.unshift(e);
    }
    function lt(e) {
      We.unshift(e);
    }
    function ue2(e) {
      Le.unshift(e);
    }
    var J2 = 0, ve2 = null;
    function ft(e) {
      J2++, a.monitorRunDependencies && a.monitorRunDependencies(J2);
    }
    function dt(e) {
      if (J2--, a.monitorRunDependencies && a.monitorRunDependencies(J2), J2 == 0 && ve2) {
        var t = ve2;
        ve2 = null, t();
      }
    }
    function Ce(e) {
      a.onAbort && a.onAbort(e), e = "Aborted(" + e + ")", $(e), z2 = true, e += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(e);
      throw d2(t), t;
    }
    var pt = "data:application/octet-stream;base64,";
    function Ve(e) {
      return e.startsWith(pt);
    }
    var me2;
    a.locateFile ? (me2 = "zxing_reader.wasm", Ve(me2) || (me2 = _(me2))) : me2 = new URL("/reader/zxing_reader.wasm", self.location).href;
    function kt(e) {
      if (e == me2 && j)
        return new Uint8Array(j);
      if (S)
        return S(e);
      throw "both async and sync fetching of the wasm failed";
    }
    function qr(e) {
      return !j && (w || C) && typeof fetch == "function" ? fetch(e, { credentials: "same-origin" }).then((t) => {
        if (!t.ok)
          throw "failed to load wasm binary file at '" + e + "'";
        return t.arrayBuffer();
      }).catch(() => kt(e)) : Promise.resolve().then(() => kt(e));
    }
    function Ft(e, t, r) {
      return qr(e).then((o) => WebAssembly.instantiate(o, t)).then((o) => o).then(r, (o) => {
        $("failed to asynchronously prepare wasm: " + o), Ce(o);
      });
    }
    function Yr(e, t, r, o) {
      return !e && typeof WebAssembly.instantiateStreaming == "function" && !Ve(t) && typeof fetch == "function" ? fetch(t, { credentials: "same-origin" }).then((s) => {
        var u2 = WebAssembly.instantiateStreaming(s, r);
        return u2.then(o, function(l) {
          return $("wasm streaming compile failed: " + l), $("falling back to ArrayBuffer instantiation"), Ft(t, r, o);
        });
      }) : Ft(t, r, o);
    }
    function Jr() {
      var e = { a: Uo };
      function t(o, s) {
        var u2 = o.exports;
        return O2 = u2, U2 = O2.qa, Ee(), Oe = O2.ua, lt(O2.ra), dt(), u2;
      }
      ft();
      function r(o) {
        t(o.instance);
      }
      if (a.instantiateWasm)
        try {
          return a.instantiateWasm(e, t);
        } catch (o) {
          $("Module.instantiateWasm callback failed with error: " + o), d2(o);
        }
      return Yr(j, me2, e, r).catch(d2), {};
    }
    var ht = (e) => {
      for (; e.length > 0; )
        e.shift()(a);
    }, ze = [], Be = 0;
    function Qr(e) {
      var t = new Ge(e);
      return t.get_caught() || (t.set_caught(true), Be--), t.set_rethrown(false), ze.push(t), cr(t.excPtr), t.get_exception_ptr();
    }
    var re = 0;
    function Xr() {
      D(0, 0);
      var e = ze.pop();
      ur(e.excPtr), re = 0;
    }
    function Ge(e) {
      this.excPtr = e, this.ptr = e - 24, this.set_type = function(t) {
        L[this.ptr + 4 >> 2] = t;
      }, this.get_type = function() {
        return L[this.ptr + 4 >> 2];
      }, this.set_destructor = function(t) {
        L[this.ptr + 8 >> 2] = t;
      }, this.get_destructor = function() {
        return L[this.ptr + 8 >> 2];
      }, this.set_caught = function(t) {
        t = t ? 1 : 0, M[this.ptr + 12 >> 0] = t;
      }, this.get_caught = function() {
        return M[this.ptr + 12 >> 0] != 0;
      }, this.set_rethrown = function(t) {
        t = t ? 1 : 0, M[this.ptr + 13 >> 0] = t;
      }, this.get_rethrown = function() {
        return M[this.ptr + 13 >> 0] != 0;
      }, this.init = function(t, r) {
        this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(r);
      }, this.set_adjusted_ptr = function(t) {
        L[this.ptr + 16 >> 2] = t;
      }, this.get_adjusted_ptr = function() {
        return L[this.ptr + 16 >> 2];
      }, this.get_exception_ptr = function() {
        var t = fr(this.get_type());
        if (t)
          return L[this.excPtr >> 2];
        var r = this.get_adjusted_ptr();
        return r !== 0 ? r : this.excPtr;
      };
    }
    function Zr(e) {
      throw re || (re = e), re;
    }
    var vt = (e) => {
      var t = re;
      if (!t)
        return Ie(0), 0;
      var r = new Ge(t);
      r.set_adjusted_ptr(t);
      var o = r.get_type();
      if (!o)
        return Ie(0), t;
      for (var s in e) {
        var u2 = e[s];
        if (u2 === 0 || u2 === o)
          break;
        var l = r.ptr + 16;
        if (lr(u2, o, l))
          return Ie(u2), t;
      }
      return Ie(o), t;
    }, Kr = () => vt([]), en = (e) => vt([e]), tn = (e, t) => vt([e, t]);
    function rn(e) {
      var t = new Ge(e).get_exception_ptr();
      return t;
    }
    function nn() {
      var e = ze.pop();
      e || Ce("no exception to throw");
      var t = e.excPtr;
      throw e.get_rethrown() || (ze.push(e), e.set_rethrown(true), e.set_caught(false), Be++), re = t, re;
    }
    function on2(e, t, r) {
      var o = new Ge(e);
      throw o.init(t, r), re = e, Be++, re;
    }
    function an() {
      return Be;
    }
    var Ne = {};
    function It(e) {
      for (; e.length; ) {
        var t = e.pop(), r = e.pop();
        r(t);
      }
    }
    function Ae(e) {
      return this.fromWireType(W2[e >> 2]);
    }
    var _e2 = {}, ye2 = {}, qe = {}, Ut = void 0;
    function Ye(e) {
      throw new Ut(e);
    }
    function ge2(e, t, r) {
      e.forEach(function(f2) {
        qe[f2] = t;
      });
      function o(f2) {
        var p2 = r(f2);
        p2.length !== e.length && Ye("Mismatched type converter count");
        for (var m2 = 0; m2 < e.length; ++m2)
          ne(e[m2], p2[m2]);
      }
      var s = new Array(t.length), u2 = [], l = 0;
      t.forEach((f2, p2) => {
        ye2.hasOwnProperty(f2) ? s[p2] = ye2[f2] : (u2.push(f2), _e2.hasOwnProperty(f2) || (_e2[f2] = []), _e2[f2].push(() => {
          s[p2] = ye2[f2], ++l, l === u2.length && o(s);
        }));
      }), u2.length === 0 && o(s);
    }
    var sn = function(e) {
      var t = Ne[e];
      delete Ne[e];
      var r = t.rawConstructor, o = t.rawDestructor, s = t.fields, u2 = s.map((l) => l.getterReturnType).concat(s.map((l) => l.setterArgumentType));
      ge2([e], u2, (l) => {
        var f2 = {};
        return s.forEach((p2, m2) => {
          var b = p2.fieldName, T = l[m2], E = p2.getter, k = p2.getterContext, H2 = l[m2 + s.length], q2 = p2.setter, V2 = p2.setterContext;
          f2[b] = { read: (Y2) => T.fromWireType(E(k, Y2)), write: (Y2, g) => {
            var P = [];
            q2(V2, Y2, H2.toWireType(P, g)), It(P);
          } };
        }), [{ name: t.name, fromWireType: function(p2) {
          var m2 = {};
          for (var b in f2)
            m2[b] = f2[b].read(p2);
          return o(p2), m2;
        }, toWireType: function(p2, m2) {
          for (var b in f2)
            if (!(b in m2))
              throw new TypeError(`Missing field: "${b}"`);
          var T = r();
          for (b in f2)
            f2[b].write(T, m2[b]);
          return p2 !== null && p2.push(o, T), T;
        }, argPackAdvance: 8, readValueFromPointer: Ae, destructorFunction: o }];
      });
    };
    function un(e, t, r, o, s) {
    }
    function mt(e) {
      switch (e) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError(`Unknown type size: ${e}`);
      }
    }
    function cn() {
      for (var e = new Array(256), t = 0; t < 256; ++t)
        e[t] = String.fromCharCode(t);
      jt = e;
    }
    var jt = void 0;
    function Q2(e) {
      for (var t = "", r = e; A[r]; )
        t += jt[A[r++]];
      return t;
    }
    var $e = void 0;
    function F(e) {
      throw new $e(e);
    }
    function ln(e, t, r = {}) {
      var o = t.name;
      if (e || F(`type "${o}" must have a positive integer typeid pointer`), ye2.hasOwnProperty(e)) {
        if (r.ignoreDuplicateRegistrations)
          return;
        F(`Cannot register type '${o}' twice`);
      }
      if (ye2[e] = t, delete qe[e], _e2.hasOwnProperty(e)) {
        var s = _e2[e];
        delete _e2[e], s.forEach((u2) => u2());
      }
    }
    function ne(e, t, r = {}) {
      if (!("argPackAdvance" in t))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return ln(e, t, r);
    }
    function fn(e, t, r, o, s) {
      var u2 = mt(r);
      t = Q2(t), ne(e, { name: t, fromWireType: function(l) {
        return !!l;
      }, toWireType: function(l, f2) {
        return f2 ? o : s;
      }, argPackAdvance: 8, readValueFromPointer: function(l) {
        var f2;
        if (r === 1)
          f2 = M;
        else if (r === 2)
          f2 = B;
        else if (r === 4)
          f2 = W2;
        else
          throw new TypeError("Unknown boolean type size: " + t);
        return this.fromWireType(f2[l >> u2]);
      }, destructorFunction: null });
    }
    function dn(e) {
      if (!(this instanceof ce2) || !(e instanceof ce2))
        return false;
      for (var t = this.$$.ptrType.registeredClass, r = this.$$.ptr, o = e.$$.ptrType.registeredClass, s = e.$$.ptr; t.baseClass; )
        r = t.upcast(r), t = t.baseClass;
      for (; o.baseClass; )
        s = o.upcast(s), o = o.baseClass;
      return t === o && r === s;
    }
    function pn(e) {
      return { count: e.count, deleteScheduled: e.deleteScheduled, preservePointerOnDelete: e.preservePointerOnDelete, ptr: e.ptr, ptrType: e.ptrType, smartPtr: e.smartPtr, smartPtrType: e.smartPtrType };
    }
    function yt(e) {
      function t(r) {
        return r.$$.ptrType.registeredClass.name;
      }
      F(t(e) + " instance already deleted");
    }
    var gt = false;
    function Wt(e) {
    }
    function hn(e) {
      e.smartPtr ? e.smartPtrType.rawDestructor(e.smartPtr) : e.ptrType.registeredClass.rawDestructor(e.ptr);
    }
    function Lt(e) {
      e.count.value -= 1;
      var t = e.count.value === 0;
      t && hn(e);
    }
    function Ht(e, t, r) {
      if (t === r)
        return e;
      if (r.baseClass === void 0)
        return null;
      var o = Ht(e, t, r.baseClass);
      return o === null ? null : r.downcast(o);
    }
    var Vt = {};
    function vn() {
      return Object.keys(Re).length;
    }
    function mn() {
      var e = [];
      for (var t in Re)
        Re.hasOwnProperty(t) && e.push(Re[t]);
      return e;
    }
    var De = [];
    function wt() {
      for (; De.length; ) {
        var e = De.pop();
        e.$$.deleteScheduled = false, e.delete();
      }
    }
    var xe = void 0;
    function yn(e) {
      xe = e, De.length && xe && xe(wt);
    }
    function gn() {
      a.getInheritedInstanceCount = vn, a.getLiveInheritedInstances = mn, a.flushPendingDeletes = wt, a.setDelayFunction = yn;
    }
    var Re = {};
    function wn(e, t) {
      for (t === void 0 && F("ptr should not be undefined"); e.baseClass; )
        t = e.upcast(t), e = e.baseClass;
      return t;
    }
    function bn(e, t) {
      return t = wn(e, t), Re[t];
    }
    function Je(e, t) {
      (!t.ptrType || !t.ptr) && Ye("makeClassHandle requires ptr and ptrType");
      var r = !!t.smartPtrType, o = !!t.smartPtr;
      return r !== o && Ye("Both smartPtrType and smartPtr must be specified"), t.count = { value: 1 }, ke(Object.create(e, { $$: { value: t } }));
    }
    function Cn(e) {
      var t = this.getPointee(e);
      if (!t)
        return this.destructor(e), null;
      var r = bn(this.registeredClass, t);
      if (r !== void 0) {
        if (r.$$.count.value === 0)
          return r.$$.ptr = t, r.$$.smartPtr = e, r.clone();
        var o = r.clone();
        return this.destructor(e), o;
      }
      function s() {
        return this.isSmartPointer ? Je(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: t, smartPtrType: this, smartPtr: e }) : Je(this.registeredClass.instancePrototype, { ptrType: this, ptr: e });
      }
      var u2 = this.registeredClass.getActualType(t), l = Vt[u2];
      if (!l)
        return s.call(this);
      var f2;
      this.isConst ? f2 = l.constPointerType : f2 = l.pointerType;
      var p2 = Ht(t, this.registeredClass, f2.registeredClass);
      return p2 === null ? s.call(this) : this.isSmartPointer ? Je(f2.registeredClass.instancePrototype, { ptrType: f2, ptr: p2, smartPtrType: this, smartPtr: e }) : Je(f2.registeredClass.instancePrototype, { ptrType: f2, ptr: p2 });
    }
    var ke = function(e) {
      return typeof FinalizationRegistry > "u" ? (ke = (t) => t, e) : (gt = new FinalizationRegistry((t) => {
        Lt(t.$$);
      }), ke = (t) => {
        var r = t.$$, o = !!r.smartPtr;
        if (o) {
          var s = { $$: r };
          gt.register(t, s, t);
        }
        return t;
      }, Wt = (t) => gt.unregister(t), ke(e));
    };
    function _n() {
      if (this.$$.ptr || yt(this), this.$$.preservePointerOnDelete)
        return this.$$.count.value += 1, this;
      var e = ke(Object.create(Object.getPrototypeOf(this), { $$: { value: pn(this.$$) } }));
      return e.$$.count.value += 1, e.$$.deleteScheduled = false, e;
    }
    function $n() {
      this.$$.ptr || yt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && F("Object already scheduled for deletion"), Wt(this), Lt(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
    }
    function Sn() {
      return !this.$$.ptr;
    }
    function Pn() {
      return this.$$.ptr || yt(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && F("Object already scheduled for deletion"), De.push(this), De.length === 1 && xe && xe(wt), this.$$.deleteScheduled = true, this;
    }
    function Tn() {
      ce2.prototype.isAliasOf = dn, ce2.prototype.clone = _n, ce2.prototype.delete = $n, ce2.prototype.isDeleted = Sn, ce2.prototype.deleteLater = Pn;
    }
    function ce2() {
    }
    var En = 48, On = 57;
    function zt(e) {
      if (e === void 0)
        return "_unknown";
      e = e.replace(/[^a-zA-Z0-9_]/g, "$");
      var t = e.charCodeAt(0);
      return t >= En && t <= On ? `_${e}` : e;
    }
    function Bt(e, t) {
      return e = zt(e), { [e]: function() {
        return t.apply(this, arguments);
      } }[e];
    }
    function Gt(e, t, r) {
      if (e[t].overloadTable === void 0) {
        var o = e[t];
        e[t] = function() {
          return e[t].overloadTable.hasOwnProperty(arguments.length) || F(`Function '${r}' called with an invalid number of arguments (${arguments.length}) - expects one of (${e[t].overloadTable})!`), e[t].overloadTable[arguments.length].apply(this, arguments);
        }, e[t].overloadTable = [], e[t].overloadTable[o.argCount] = o;
      }
    }
    function Nt(e, t, r) {
      a.hasOwnProperty(e) ? ((r === void 0 || a[e].overloadTable !== void 0 && a[e].overloadTable[r] !== void 0) && F(`Cannot register public name '${e}' twice`), Gt(a, e, e), a.hasOwnProperty(r) && F(`Cannot register multiple overloads of a function with the same number of arguments (${r})!`), a[e].overloadTable[r] = t) : (a[e] = t, r !== void 0 && (a[e].numArguments = r));
    }
    function Mn(e, t, r, o, s, u2, l, f2) {
      this.name = e, this.constructor = t, this.instancePrototype = r, this.rawDestructor = o, this.baseClass = s, this.getActualType = u2, this.upcast = l, this.downcast = f2, this.pureVirtualFunctions = [];
    }
    function bt(e, t, r) {
      for (; t !== r; )
        t.upcast || F(`Expected null or instance of ${r.name}, got an instance of ${t.name}`), e = t.upcast(e), t = t.baseClass;
      return e;
    }
    function An(e, t) {
      if (t === null)
        return this.isReference && F(`null is not a valid ${this.name}`), 0;
      t.$$ || F(`Cannot pass "${$t(t)}" as a ${this.name}`), t.$$.ptr || F(`Cannot pass deleted object as a pointer of type ${this.name}`);
      var r = t.$$.ptrType.registeredClass, o = bt(t.$$.ptr, r, this.registeredClass);
      return o;
    }
    function Dn(e, t) {
      var r;
      if (t === null)
        return this.isReference && F(`null is not a valid ${this.name}`), this.isSmartPointer ? (r = this.rawConstructor(), e !== null && e.push(this.rawDestructor, r), r) : 0;
      t.$$ || F(`Cannot pass "${$t(t)}" as a ${this.name}`), t.$$.ptr || F(`Cannot pass deleted object as a pointer of type ${this.name}`), !this.isConst && t.$$.ptrType.isConst && F(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
      var o = t.$$.ptrType.registeredClass;
      if (r = bt(t.$$.ptr, o, this.registeredClass), this.isSmartPointer)
        switch (t.$$.smartPtr === void 0 && F("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy) {
          case 0:
            t.$$.smartPtrType === this ? r = t.$$.smartPtr : F(`Cannot convert argument of type ${t.$$.smartPtrType ? t.$$.smartPtrType.name : t.$$.ptrType.name} to parameter type ${this.name}`);
            break;
          case 1:
            r = t.$$.smartPtr;
            break;
          case 2:
            if (t.$$.smartPtrType === this)
              r = t.$$.smartPtr;
            else {
              var s = t.clone();
              r = this.rawShare(r, le2.toHandle(function() {
                s.delete();
              })), e !== null && e.push(this.rawDestructor, r);
            }
            break;
          default:
            F("Unsupporting sharing policy");
        }
      return r;
    }
    function xn(e, t) {
      if (t === null)
        return this.isReference && F(`null is not a valid ${this.name}`), 0;
      t.$$ || F(`Cannot pass "${$t(t)}" as a ${this.name}`), t.$$.ptr || F(`Cannot pass deleted object as a pointer of type ${this.name}`), t.$$.ptrType.isConst && F(`Cannot convert argument of type ${t.$$.ptrType.name} to parameter type ${this.name}`);
      var r = t.$$.ptrType.registeredClass, o = bt(t.$$.ptr, r, this.registeredClass);
      return o;
    }
    function Rn(e) {
      return this.rawGetPointee && (e = this.rawGetPointee(e)), e;
    }
    function kn(e) {
      this.rawDestructor && this.rawDestructor(e);
    }
    function Fn(e) {
      e !== null && e.delete();
    }
    function In() {
      oe2.prototype.getPointee = Rn, oe2.prototype.destructor = kn, oe2.prototype.argPackAdvance = 8, oe2.prototype.readValueFromPointer = Ae, oe2.prototype.deleteObject = Fn, oe2.prototype.fromWireType = Cn;
    }
    function oe2(e, t, r, o, s, u2, l, f2, p2, m2, b) {
      this.name = e, this.registeredClass = t, this.isReference = r, this.isConst = o, this.isSmartPointer = s, this.pointeeType = u2, this.sharingPolicy = l, this.rawGetPointee = f2, this.rawConstructor = p2, this.rawShare = m2, this.rawDestructor = b, !s && t.baseClass === void 0 ? o ? (this.toWireType = An, this.destructorFunction = null) : (this.toWireType = xn, this.destructorFunction = null) : this.toWireType = Dn;
    }
    function qt(e, t, r) {
      a.hasOwnProperty(e) || Ye("Replacing nonexistant public symbol"), a[e].overloadTable !== void 0 && r !== void 0 ? a[e].overloadTable[r] = t : (a[e] = t, a[e].argCount = r);
    }
    var Un = (e, t, r) => {
      var o = a["dynCall_" + e];
      return r && r.length ? o.apply(null, [t].concat(r)) : o.call(null, t);
    }, Qe = [], I = (e) => {
      var t = Qe[e];
      return t || (e >= Qe.length && (Qe.length = e + 1), Qe[e] = t = Oe.get(e)), t;
    }, jn = (e, t, r) => {
      if (e.includes("j"))
        return Un(e, t, r);
      var o = I(t).apply(null, r);
      return o;
    }, Wn = (e, t) => {
      var r = [];
      return function() {
        return r.length = 0, Object.assign(r, arguments), jn(e, t, r);
      };
    };
    function K(e, t) {
      e = Q2(e);
      function r() {
        return e.includes("j") ? Wn(e, t) : I(t);
      }
      var o = r();
      return typeof o != "function" && F(`unknown function pointer with signature ${e}: ${t}`), o;
    }
    function Ln(e, t) {
      var r = Bt(t, function(o) {
        this.name = t, this.message = o;
        var s = new Error(o).stack;
        s !== void 0 && (this.stack = this.toString() + `
` + s.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.prototype.toString = function() {
        return this.message === void 0 ? this.name : `${this.name}: ${this.message}`;
      }, r;
    }
    var Yt = void 0;
    function Jt(e) {
      var t = sr(e), r = Q2(t);
      return ae(t), r;
    }
    function Xe(e, t) {
      var r = [], o = {};
      function s(u2) {
        if (!o[u2] && !ye2[u2]) {
          if (qe[u2]) {
            qe[u2].forEach(s);
            return;
          }
          r.push(u2), o[u2] = true;
        }
      }
      throw t.forEach(s), new Yt(`${e}: ` + r.map(Jt).join([", "]));
    }
    function Hn(e, t, r, o, s, u2, l, f2, p2, m2, b, T, E) {
      b = Q2(b), u2 = K(s, u2), f2 && (f2 = K(l, f2)), m2 && (m2 = K(p2, m2)), E = K(T, E);
      var k = zt(b);
      Nt(k, function() {
        Xe(`Cannot construct ${b} due to unbound types`, [o]);
      }), ge2([e, t, r], o ? [o] : [], function(H2) {
        H2 = H2[0];
        var q2, V2;
        o ? (q2 = H2.registeredClass, V2 = q2.instancePrototype) : V2 = ce2.prototype;
        var Y2 = Bt(k, function() {
          if (Object.getPrototypeOf(this) !== g)
            throw new $e("Use 'new' to construct " + b);
          if (P.constructor_body === void 0)
            throw new $e(b + " has no accessible constructor");
          var et = P.constructor_body[arguments.length];
          if (et === void 0)
            throw new $e(`Tried to invoke ctor of ${b} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(P.constructor_body).toString()}) parameters instead!`);
          return et.apply(this, arguments);
        }), g = Object.create(V2, { constructor: { value: Y2 } });
        Y2.prototype = g;
        var P = new Mn(b, Y2, g, E, q2, u2, f2, m2);
        P.baseClass && (P.baseClass.__derivedClasses === void 0 && (P.baseClass.__derivedClasses = []), P.baseClass.__derivedClasses.push(P));
        var G2 = new oe2(b, P, true, false, false), N = new oe2(b + "*", P, false, false, false), we = new oe2(b + " const*", P, false, true, false);
        return Vt[e] = { pointerType: N, constPointerType: we }, qt(k, Y2), [G2, N, we];
      });
    }
    function Ct(e, t) {
      for (var r = [], o = 0; o < e; o++)
        r.push(L[t + o * 4 >> 2]);
      return r;
    }
    function _t(e, t, r, o, s, u2) {
      var l = t.length;
      l < 2 && F("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var f2 = t[1] !== null && r !== null, p2 = false, m2 = 1; m2 < t.length; ++m2)
        if (t[m2] !== null && t[m2].destructorFunction === void 0) {
          p2 = true;
          break;
        }
      var b = t[0].name !== "void", T = l - 2, E = new Array(T), k = [], H2 = [];
      return function() {
        arguments.length !== T && F(`function ${e} called with ${arguments.length} arguments, expected ${T} args!`), H2.length = 0;
        var q2;
        k.length = f2 ? 2 : 1, k[0] = s, f2 && (q2 = t[1].toWireType(H2, this), k[1] = q2);
        for (var V2 = 0; V2 < T; ++V2)
          E[V2] = t[V2 + 2].toWireType(H2, arguments[V2]), k.push(E[V2]);
        var Y2 = o.apply(null, k);
        function g(P) {
          if (p2)
            It(H2);
          else
            for (var G2 = f2 ? 1 : 2; G2 < t.length; G2++) {
              var N = G2 === 1 ? q2 : E[G2 - 2];
              t[G2].destructorFunction !== null && t[G2].destructorFunction(N);
            }
          if (b)
            return t[0].fromWireType(P);
        }
        return g(Y2);
      };
    }
    function Vn(e, t, r, o, s, u2) {
      var l = Ct(t, r);
      s = K(o, s), ge2([], [e], function(f2) {
        f2 = f2[0];
        var p2 = `constructor ${f2.name}`;
        if (f2.registeredClass.constructor_body === void 0 && (f2.registeredClass.constructor_body = []), f2.registeredClass.constructor_body[t - 1] !== void 0)
          throw new $e(`Cannot register multiple constructors with identical number of parameters (${t - 1}) for class '${f2.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
        return f2.registeredClass.constructor_body[t - 1] = () => {
          Xe(`Cannot construct ${f2.name} due to unbound types`, l);
        }, ge2([], l, function(m2) {
          return m2.splice(1, 0, null), f2.registeredClass.constructor_body[t - 1] = _t(p2, m2, null, s, u2), [];
        }), [];
      });
    }
    function zn(e, t, r, o, s, u2, l, f2, p2) {
      var m2 = Ct(r, o);
      t = Q2(t), u2 = K(s, u2), ge2([], [e], function(b) {
        b = b[0];
        var T = `${b.name}.${t}`;
        t.startsWith("@@") && (t = Symbol[t.substring(2)]), f2 && b.registeredClass.pureVirtualFunctions.push(t);
        function E() {
          Xe(`Cannot call ${T} due to unbound types`, m2);
        }
        var k = b.registeredClass.instancePrototype, H2 = k[t];
        return H2 === void 0 || H2.overloadTable === void 0 && H2.className !== b.name && H2.argCount === r - 2 ? (E.argCount = r - 2, E.className = b.name, k[t] = E) : (Gt(k, t, T), k[t].overloadTable[r - 2] = E), ge2([], m2, function(q2) {
          var V2 = _t(T, q2, b, u2, l);
          return k[t].overloadTable === void 0 ? (V2.argCount = r - 2, k[t] = V2) : k[t].overloadTable[r - 2] = V2, [];
        }), [];
      });
    }
    function Bn() {
      Object.assign(Qt.prototype, { get(e) {
        return this.allocated[e];
      }, has(e) {
        return this.allocated[e] !== void 0;
      }, allocate(e) {
        var t = this.freelist.pop() || this.allocated.length;
        return this.allocated[t] = e, t;
      }, free(e) {
        this.allocated[e] = void 0, this.freelist.push(e);
      } });
    }
    function Qt() {
      this.allocated = [void 0], this.freelist = [];
    }
    var Z2 = new Qt();
    function Xt(e) {
      e >= Z2.reserved && --Z2.get(e).refcount === 0 && Z2.free(e);
    }
    function Gn() {
      for (var e = 0, t = Z2.reserved; t < Z2.allocated.length; ++t)
        Z2.allocated[t] !== void 0 && ++e;
      return e;
    }
    function Nn() {
      Z2.allocated.push({ value: void 0 }, { value: null }, { value: true }, { value: false }), Z2.reserved = Z2.allocated.length, a.count_emval_handles = Gn;
    }
    var le2 = { toValue: (e) => (e || F("Cannot use deleted val. handle = " + e), Z2.get(e).value), toHandle: (e) => {
      switch (e) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          return Z2.allocate({ refcount: 1, value: e });
      }
    } };
    function qn(e, t) {
      t = Q2(t), ne(e, { name: t, fromWireType: function(r) {
        var o = le2.toValue(r);
        return Xt(r), o;
      }, toWireType: function(r, o) {
        return le2.toHandle(o);
      }, argPackAdvance: 8, readValueFromPointer: Ae, destructorFunction: null });
    }
    function $t(e) {
      if (e === null)
        return "null";
      var t = typeof e;
      return t === "object" || t === "array" || t === "function" ? e.toString() : "" + e;
    }
    function Yn(e, t) {
      switch (t) {
        case 2:
          return function(r) {
            return this.fromWireType(be2[r >> 2]);
          };
        case 3:
          return function(r) {
            return this.fromWireType(Te[r >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + e);
      }
    }
    function Jn(e, t, r) {
      var o = mt(r);
      t = Q2(t), ne(e, { name: t, fromWireType: function(s) {
        return s;
      }, toWireType: function(s, u2) {
        return u2;
      }, argPackAdvance: 8, readValueFromPointer: Yn(t, o), destructorFunction: null });
    }
    function Qn(e, t, r, o, s, u2, l) {
      var f2 = Ct(t, r);
      e = Q2(e), s = K(o, s), Nt(e, function() {
        Xe(`Cannot call ${e} due to unbound types`, f2);
      }, t - 1), ge2([], f2, function(p2) {
        var m2 = [p2[0], null].concat(p2.slice(1));
        return qt(e, _t(e, m2, null, s, u2), t - 1), [];
      });
    }
    function Xn(e, t, r) {
      switch (t) {
        case 0:
          return r ? function(o) {
            return M[o];
          } : function(o) {
            return A[o];
          };
        case 1:
          return r ? function(o) {
            return B[o >> 1];
          } : function(o) {
            return ee[o >> 1];
          };
        case 2:
          return r ? function(o) {
            return W2[o >> 2];
          } : function(o) {
            return L[o >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + e);
      }
    }
    function Zn(e, t, r, o, s) {
      t = Q2(t);
      var u2 = mt(r), l = (T) => T;
      if (o === 0) {
        var f2 = 32 - 8 * r;
        l = (T) => T << f2 >>> f2;
      }
      var p2 = t.includes("unsigned"), m2 = (T, E) => {
      }, b;
      p2 ? b = function(T, E) {
        return m2(E, this.name), E >>> 0;
      } : b = function(T, E) {
        return m2(E, this.name), E;
      }, ne(e, { name: t, fromWireType: l, toWireType: b, argPackAdvance: 8, readValueFromPointer: Xn(t, u2, o !== 0), destructorFunction: null });
    }
    function Kn(e, t, r) {
      var o = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], s = o[t];
      function u2(l) {
        l = l >> 2;
        var f2 = L, p2 = f2[l], m2 = f2[l + 1];
        return new s(f2.buffer, m2, p2);
      }
      r = Q2(r), ne(e, { name: r, fromWireType: u2, argPackAdvance: 8, readValueFromPointer: u2 }, { ignoreDuplicateRegistrations: true });
    }
    var Zt = (e, t, r, o) => {
      if (!(o > 0))
        return 0;
      for (var s = r, u2 = r + o - 1, l = 0; l < e.length; ++l) {
        var f2 = e.charCodeAt(l);
        if (f2 >= 55296 && f2 <= 57343) {
          var p2 = e.charCodeAt(++l);
          f2 = 65536 + ((f2 & 1023) << 10) | p2 & 1023;
        }
        if (f2 <= 127) {
          if (r >= u2)
            break;
          t[r++] = f2;
        } else if (f2 <= 2047) {
          if (r + 1 >= u2)
            break;
          t[r++] = 192 | f2 >> 6, t[r++] = 128 | f2 & 63;
        } else if (f2 <= 65535) {
          if (r + 2 >= u2)
            break;
          t[r++] = 224 | f2 >> 12, t[r++] = 128 | f2 >> 6 & 63, t[r++] = 128 | f2 & 63;
        } else {
          if (r + 3 >= u2)
            break;
          t[r++] = 240 | f2 >> 18, t[r++] = 128 | f2 >> 12 & 63, t[r++] = 128 | f2 >> 6 & 63, t[r++] = 128 | f2 & 63;
        }
      }
      return t[r] = 0, r - s;
    }, eo = (e, t, r) => Zt(e, A, t, r), Kt = (e) => {
      for (var t = 0, r = 0; r < e.length; ++r) {
        var o = e.charCodeAt(r);
        o <= 127 ? t++ : o <= 2047 ? t += 2 : o >= 55296 && o <= 57343 ? (t += 4, ++r) : t += 3;
      }
      return t;
    }, er = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0, to = (e, t, r) => {
      for (var o = t + r, s = t; e[s] && !(s >= o); )
        ++s;
      if (s - t > 16 && e.buffer && er)
        return er.decode(e.subarray(t, s));
      for (var u2 = ""; t < s; ) {
        var l = e[t++];
        if (!(l & 128)) {
          u2 += String.fromCharCode(l);
          continue;
        }
        var f2 = e[t++] & 63;
        if ((l & 224) == 192) {
          u2 += String.fromCharCode((l & 31) << 6 | f2);
          continue;
        }
        var p2 = e[t++] & 63;
        if ((l & 240) == 224 ? l = (l & 15) << 12 | f2 << 6 | p2 : l = (l & 7) << 18 | f2 << 12 | p2 << 6 | e[t++] & 63, l < 65536)
          u2 += String.fromCharCode(l);
        else {
          var m2 = l - 65536;
          u2 += String.fromCharCode(55296 | m2 >> 10, 56320 | m2 & 1023);
        }
      }
      return u2;
    }, St = (e, t) => e ? to(A, e, t) : "";
    function ro(e, t) {
      t = Q2(t);
      var r = t === "std::string";
      ne(e, { name: t, fromWireType: function(o) {
        var s = L[o >> 2], u2 = o + 4, l;
        if (r)
          for (var f2 = u2, p2 = 0; p2 <= s; ++p2) {
            var m2 = u2 + p2;
            if (p2 == s || A[m2] == 0) {
              var b = m2 - f2, T = St(f2, b);
              l === void 0 ? l = T : (l += String.fromCharCode(0), l += T), f2 = m2 + 1;
            }
          }
        else {
          for (var E = new Array(s), p2 = 0; p2 < s; ++p2)
            E[p2] = String.fromCharCode(A[u2 + p2]);
          l = E.join("");
        }
        return ae(o), l;
      }, toWireType: function(o, s) {
        s instanceof ArrayBuffer && (s = new Uint8Array(s));
        var u2, l = typeof s == "string";
        l || s instanceof Uint8Array || s instanceof Uint8ClampedArray || s instanceof Int8Array || F("Cannot pass non-string to std::string"), r && l ? u2 = Kt(s) : u2 = s.length;
        var f2 = Tt(4 + u2 + 1), p2 = f2 + 4;
        if (L[f2 >> 2] = u2, r && l)
          eo(s, p2, u2 + 1);
        else if (l)
          for (var m2 = 0; m2 < u2; ++m2) {
            var b = s.charCodeAt(m2);
            b > 255 && (ae(p2), F("String has UTF-16 code units that do not fit in 8 bits")), A[p2 + m2] = b;
          }
        else
          for (var m2 = 0; m2 < u2; ++m2)
            A[p2 + m2] = s[m2];
        return o !== null && o.push(ae, f2), f2;
      }, argPackAdvance: 8, readValueFromPointer: Ae, destructorFunction: function(o) {
        ae(o);
      } });
    }
    var tr = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0, no = (e, t) => {
      for (var r = e, o = r >> 1, s = o + t / 2; !(o >= s) && ee[o]; )
        ++o;
      if (r = o << 1, r - e > 32 && tr)
        return tr.decode(A.subarray(e, r));
      for (var u2 = "", l = 0; !(l >= t / 2); ++l) {
        var f2 = B[e + l * 2 >> 1];
        if (f2 == 0)
          break;
        u2 += String.fromCharCode(f2);
      }
      return u2;
    }, oo = (e, t, r) => {
      if (r === void 0 && (r = 2147483647), r < 2)
        return 0;
      r -= 2;
      for (var o = t, s = r < e.length * 2 ? r / 2 : e.length, u2 = 0; u2 < s; ++u2) {
        var l = e.charCodeAt(u2);
        B[t >> 1] = l, t += 2;
      }
      return B[t >> 1] = 0, t - o;
    }, ao = (e) => e.length * 2, io = (e, t) => {
      for (var r = 0, o = ""; !(r >= t / 4); ) {
        var s = W2[e + r * 4 >> 2];
        if (s == 0)
          break;
        if (++r, s >= 65536) {
          var u2 = s - 65536;
          o += String.fromCharCode(55296 | u2 >> 10, 56320 | u2 & 1023);
        } else
          o += String.fromCharCode(s);
      }
      return o;
    }, so = (e, t, r) => {
      if (r === void 0 && (r = 2147483647), r < 4)
        return 0;
      for (var o = t, s = o + r - 4, u2 = 0; u2 < e.length; ++u2) {
        var l = e.charCodeAt(u2);
        if (l >= 55296 && l <= 57343) {
          var f2 = e.charCodeAt(++u2);
          l = 65536 + ((l & 1023) << 10) | f2 & 1023;
        }
        if (W2[t >> 2] = l, t += 4, t + 4 > s)
          break;
      }
      return W2[t >> 2] = 0, t - o;
    }, uo = (e) => {
      for (var t = 0, r = 0; r < e.length; ++r) {
        var o = e.charCodeAt(r);
        o >= 55296 && o <= 57343 && ++r, t += 4;
      }
      return t;
    }, co = function(e, t, r) {
      r = Q2(r);
      var o, s, u2, l, f2;
      t === 2 ? (o = no, s = oo, l = ao, u2 = () => ee, f2 = 1) : t === 4 && (o = io, s = so, l = uo, u2 = () => L, f2 = 2), ne(e, { name: r, fromWireType: function(p2) {
        for (var m2 = L[p2 >> 2], b = u2(), T, E = p2 + 4, k = 0; k <= m2; ++k) {
          var H2 = p2 + 4 + k * t;
          if (k == m2 || b[H2 >> f2] == 0) {
            var q2 = H2 - E, V2 = o(E, q2);
            T === void 0 ? T = V2 : (T += String.fromCharCode(0), T += V2), E = H2 + t;
          }
        }
        return ae(p2), T;
      }, toWireType: function(p2, m2) {
        typeof m2 != "string" && F(`Cannot pass non-string to C++ string type ${r}`);
        var b = l(m2), T = Tt(4 + b + t);
        return L[T >> 2] = b >> f2, s(m2, T + 4, b + t), p2 !== null && p2.push(ae, T), T;
      }, argPackAdvance: 8, readValueFromPointer: Ae, destructorFunction: function(p2) {
        ae(p2);
      } });
    };
    function lo(e, t, r, o, s, u2) {
      Ne[e] = { name: Q2(t), rawConstructor: K(r, o), rawDestructor: K(s, u2), fields: [] };
    }
    function fo(e, t, r, o, s, u2, l, f2, p2, m2) {
      Ne[e].fields.push({ fieldName: Q2(t), getterReturnType: r, getter: K(o, s), getterContext: u2, setterArgumentType: l, setter: K(f2, p2), setterContext: m2 });
    }
    function po(e, t) {
      t = Q2(t), ne(e, { isVoid: true, name: t, argPackAdvance: 0, fromWireType: function() {
      }, toWireType: function(r, o) {
      } });
    }
    var ho = {};
    function vo(e) {
      var t = ho[e];
      return t === void 0 ? Q2(e) : t;
    }
    function rr() {
      if (typeof globalThis == "object")
        return globalThis;
      function e(t) {
        t.$$$embind_global$$$ = t;
        var r = typeof $$$embind_global$$$ == "object" && t.$$$embind_global$$$ == t;
        return r || delete t.$$$embind_global$$$, r;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && e(global) ? $$$embind_global$$$ = global : typeof self == "object" && e(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object"))
        return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }
    function mo(e) {
      return e === 0 ? le2.toHandle(rr()) : (e = vo(e), le2.toHandle(rr()[e]));
    }
    function yo(e) {
      e > 4 && (Z2.get(e).refcount += 1);
    }
    function nr(e, t) {
      var r = ye2[e];
      return r === void 0 && F(t + " has unknown type " + Jt(e)), r;
    }
    function go(e) {
      var t = new Array(e + 1);
      return function(r, o, s) {
        t[0] = r;
        for (var u2 = 0; u2 < e; ++u2) {
          var l = nr(L[o + u2 * 4 >> 2], "parameter " + u2);
          t[u2 + 1] = l.readValueFromPointer(s), s += l.argPackAdvance;
        }
        var f2 = new (r.bind.apply(r, t))();
        return le2.toHandle(f2);
      };
    }
    var or = {};
    function wo(e, t, r, o) {
      e = le2.toValue(e);
      var s = or[t];
      return s || (s = go(t), or[t] = s), s(e, r, o);
    }
    function bo(e, t) {
      e = nr(e, "_emval_take_value");
      var r = e.readValueFromPointer(t);
      return le2.toHandle(r);
    }
    var Co = () => {
      Ce("");
    }, _o = (e, t, r) => A.copyWithin(e, t, t + r), $o = () => 2147483648, So = (e) => {
      var t = U2.buffer, r = e - t.byteLength + 65535 >>> 16;
      try {
        return U2.grow(r), Ee(), 1;
      } catch (o) {
      }
    }, Po = (e) => {
      var t = A.length;
      e >>>= 0;
      var r = $o();
      if (e > r)
        return false;
      for (var o = (p2, m2) => p2 + (m2 - p2 % m2) % m2, s = 1; s <= 4; s *= 2) {
        var u2 = t * (1 + 0.2 / s);
        u2 = Math.min(u2, e + 100663296);
        var l = Math.min(r, o(Math.max(e, u2), 65536)), f2 = So(l);
        if (f2)
          return true;
      }
      return false;
    }, Pt = {}, To = () => v || "./this.program", Fe = () => {
      if (!Fe.strings) {
        var e = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", t = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: e, _: To() };
        for (var r in Pt)
          Pt[r] === void 0 ? delete t[r] : t[r] = Pt[r];
        var o = [];
        for (var r in t)
          o.push(`${r}=${t[r]}`);
        Fe.strings = o;
      }
      return Fe.strings;
    }, Eo = (e, t) => {
      for (var r = 0; r < e.length; ++r)
        M[t++ >> 0] = e.charCodeAt(r);
      M[t >> 0] = 0;
    }, Oo = (e, t) => {
      var r = 0;
      return Fe().forEach(function(o, s) {
        var u2 = t + r;
        L[e + s * 4 >> 2] = u2, Eo(o, u2), r += o.length + 1;
      }), 0;
    }, Mo = (e, t) => {
      var r = Fe();
      L[e >> 2] = r.length;
      var o = 0;
      return r.forEach(function(s) {
        o += s.length + 1;
      }), L[t >> 2] = o, 0;
    };
    function Ao(e) {
      return e;
    }
    var Ze = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), Do = (e, t) => {
      for (var r = 0, o = 0; o <= t; r += e[o++])
        ;
      return r;
    }, ar = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ir = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], xo = (e, t) => {
      for (var r = new Date(e.getTime()); t > 0; ) {
        var o = Ze(r.getFullYear()), s = r.getMonth(), u2 = (o ? ar : ir)[s];
        if (t > u2 - r.getDate())
          t -= u2 - r.getDate() + 1, r.setDate(1), s < 11 ? r.setMonth(s + 1) : (r.setMonth(0), r.setFullYear(r.getFullYear() + 1));
        else
          return r.setDate(r.getDate() + t), r;
      }
      return r;
    };
    function Ro(e, t, r) {
      var o = r > 0 ? r : Kt(e) + 1, s = new Array(o), u2 = Zt(e, s, 0, s.length);
      return t && (s.length = u2), s;
    }
    var ko = (e, t) => {
      M.set(e, t);
    }, Fo = (e, t, r, o) => {
      var s = W2[o + 40 >> 2], u2 = { tm_sec: W2[o >> 2], tm_min: W2[o + 4 >> 2], tm_hour: W2[o + 8 >> 2], tm_mday: W2[o + 12 >> 2], tm_mon: W2[o + 16 >> 2], tm_year: W2[o + 20 >> 2], tm_wday: W2[o + 24 >> 2], tm_yday: W2[o + 28 >> 2], tm_isdst: W2[o + 32 >> 2], tm_gmtoff: W2[o + 36 >> 2], tm_zone: s ? St(s) : "" }, l = St(r), f2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var p2 in f2)
        l = l.replace(new RegExp(p2, "g"), f2[p2]);
      var m2 = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], b = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function T(g, P, G2) {
        for (var N = typeof g == "number" ? g.toString() : g || ""; N.length < P; )
          N = G2[0] + N;
        return N;
      }
      function E(g, P) {
        return T(g, P, "0");
      }
      function k(g, P) {
        function G2(we) {
          return we < 0 ? -1 : we > 0 ? 1 : 0;
        }
        var N;
        return (N = G2(g.getFullYear() - P.getFullYear())) === 0 && (N = G2(g.getMonth() - P.getMonth())) === 0 && (N = G2(g.getDate() - P.getDate())), N;
      }
      function H2(g) {
        switch (g.getDay()) {
          case 0:
            return new Date(g.getFullYear() - 1, 11, 29);
          case 1:
            return g;
          case 2:
            return new Date(g.getFullYear(), 0, 3);
          case 3:
            return new Date(g.getFullYear(), 0, 2);
          case 4:
            return new Date(g.getFullYear(), 0, 1);
          case 5:
            return new Date(g.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(g.getFullYear() - 1, 11, 30);
        }
      }
      function q2(g) {
        var P = xo(new Date(g.tm_year + 1900, 0, 1), g.tm_yday), G2 = new Date(P.getFullYear(), 0, 4), N = new Date(P.getFullYear() + 1, 0, 4), we = H2(G2), et = H2(N);
        return k(we, P) <= 0 ? k(et, P) <= 0 ? P.getFullYear() + 1 : P.getFullYear() : P.getFullYear() - 1;
      }
      var V2 = { "%a": (g) => m2[g.tm_wday].substring(0, 3), "%A": (g) => m2[g.tm_wday], "%b": (g) => b[g.tm_mon].substring(0, 3), "%B": (g) => b[g.tm_mon], "%C": (g) => {
        var P = g.tm_year + 1900;
        return E(P / 100 | 0, 2);
      }, "%d": (g) => E(g.tm_mday, 2), "%e": (g) => T(g.tm_mday, 2, " "), "%g": (g) => q2(g).toString().substring(2), "%G": (g) => q2(g), "%H": (g) => E(g.tm_hour, 2), "%I": (g) => {
        var P = g.tm_hour;
        return P == 0 ? P = 12 : P > 12 && (P -= 12), E(P, 2);
      }, "%j": (g) => E(g.tm_mday + Do(Ze(g.tm_year + 1900) ? ar : ir, g.tm_mon - 1), 3), "%m": (g) => E(g.tm_mon + 1, 2), "%M": (g) => E(g.tm_min, 2), "%n": () => `
`, "%p": (g) => g.tm_hour >= 0 && g.tm_hour < 12 ? "AM" : "PM", "%S": (g) => E(g.tm_sec, 2), "%t": () => "	", "%u": (g) => g.tm_wday || 7, "%U": (g) => {
        var P = g.tm_yday + 7 - g.tm_wday;
        return E(Math.floor(P / 7), 2);
      }, "%V": (g) => {
        var P = Math.floor((g.tm_yday + 7 - (g.tm_wday + 6) % 7) / 7);
        if ((g.tm_wday + 371 - g.tm_yday - 2) % 7 <= 2 && P++, P) {
          if (P == 53) {
            var G2 = (g.tm_wday + 371 - g.tm_yday) % 7;
            G2 != 4 && (G2 != 3 || !Ze(g.tm_year)) && (P = 1);
          }
        } else {
          P = 52;
          var N = (g.tm_wday + 7 - g.tm_yday - 1) % 7;
          (N == 4 || N == 5 && Ze(g.tm_year % 400 - 1)) && P++;
        }
        return E(P, 2);
      }, "%w": (g) => g.tm_wday, "%W": (g) => {
        var P = g.tm_yday + 7 - (g.tm_wday + 6) % 7;
        return E(Math.floor(P / 7), 2);
      }, "%y": (g) => (g.tm_year + 1900).toString().substring(2), "%Y": (g) => g.tm_year + 1900, "%z": (g) => {
        var P = g.tm_gmtoff, G2 = P >= 0;
        return P = Math.abs(P) / 60, P = P / 60 * 100 + P % 60, (G2 ? "+" : "-") + ("0000" + P).slice(-4);
      }, "%Z": (g) => g.tm_zone, "%%": () => "%" };
      l = l.replace(/%%/g, "\0\0");
      for (var p2 in V2)
        l.includes(p2) && (l = l.replace(new RegExp(p2, "g"), V2[p2](u2)));
      l = l.replace(/\0\0/g, "%");
      var Y2 = Ro(l, false);
      return Y2.length > t ? 0 : (ko(Y2, e), Y2.length - 1);
    }, Io = (e, t, r, o, s) => Fo(e, t, r, o);
    Ut = a.InternalError = class extends Error {
      constructor(e) {
        super(e), this.name = "InternalError";
      }
    }, cn(), $e = a.BindingError = class extends Error {
      constructor(e) {
        super(e), this.name = "BindingError";
      }
    }, Tn(), gn(), In(), Yt = a.UnboundTypeError = Ln(Error, "UnboundTypeError"), Bn(), Nn();
    var Uo = { q: Qr, u: Xr, a: Kr, h: en, l: tn, I: rn, P: nn, n: on2, ba: an, d: Zr, oa: sn, Y: un, fa: fn, na: Hn, ma: Vn, D: zn, ea: qn, W: Jn, J: Qn, w: Zn, s: Kn, V: ro, L: co, Q: lo, pa: fo, ga: po, U: Xt, la: mo, R: yo, ia: wo, ka: bo, K: Co, da: _o, ca: Po, $: Oo, aa: Mo, H: ra, T: fa, B: oa, p: Ko, b: jo, C: ta, ha: ia, c: zo, j: Go, i: Ho, x: na, O: ea, v: Xo, G: ua, N: ca, A: aa, F: da, Z: ha, X: va, k: Bo, f: Vo, e: Lo, g: Wo, M: la, m: Qo, o: No, S: qo, t: Jo, ja: Zo, y: sa, r: Yo, E: pa, z: Ao, _: Io };
    Jr();
    var ae = a._free = (e) => (ae = a._free = O2.sa)(e), Tt = a._malloc = (e) => (Tt = a._malloc = O2.ta)(e), sr = (e) => (sr = O2.va)(e);
    a.__embind_initialize_bindings = () => (a.__embind_initialize_bindings = O2.wa)();
    var D = (e, t) => (D = O2.xa)(e, t), Ie = (e) => (Ie = O2.ya)(e), x = () => (x = O2.za)(), R = (e) => (R = O2.Aa)(e), ur = (e) => (ur = O2.Ba)(e), cr = (e) => (cr = O2.Ca)(e), lr = (e, t, r) => (lr = O2.Da)(e, t, r), fr = (e) => (fr = O2.Ea)(e);
    a.dynCall_viijii = (e, t, r, o, s, u2, l) => (a.dynCall_viijii = O2.Fa)(e, t, r, o, s, u2, l);
    var dr = a.dynCall_jiii = (e, t, r, o) => (dr = a.dynCall_jiii = O2.Ga)(e, t, r, o), pr = a.dynCall_jiiii = (e, t, r, o, s) => (pr = a.dynCall_jiiii = O2.Ha)(e, t, r, o, s);
    a.dynCall_iiiiij = (e, t, r, o, s, u2, l) => (a.dynCall_iiiiij = O2.Ia)(e, t, r, o, s, u2, l), a.dynCall_iiiiijj = (e, t, r, o, s, u2, l, f2, p2) => (a.dynCall_iiiiijj = O2.Ja)(e, t, r, o, s, u2, l, f2, p2), a.dynCall_iiiiiijj = (e, t, r, o, s, u2, l, f2, p2, m2) => (a.dynCall_iiiiiijj = O2.Ka)(e, t, r, o, s, u2, l, f2, p2, m2);
    function jo(e, t) {
      var r = x();
      try {
        return I(e)(t);
      } catch (o) {
        if (R(r), o !== o + 0)
          throw o;
        D(1, 0);
      }
    }
    function Wo(e, t, r, o) {
      var s = x();
      try {
        I(e)(t, r, o);
      } catch (u2) {
        if (R(s), u2 !== u2 + 0)
          throw u2;
        D(1, 0);
      }
    }
    function Lo(e, t, r) {
      var o = x();
      try {
        I(e)(t, r);
      } catch (s) {
        if (R(o), s !== s + 0)
          throw s;
        D(1, 0);
      }
    }
    function Ho(e, t, r, o, s) {
      var u2 = x();
      try {
        return I(e)(t, r, o, s);
      } catch (l) {
        if (R(u2), l !== l + 0)
          throw l;
        D(1, 0);
      }
    }
    function Vo(e, t) {
      var r = x();
      try {
        I(e)(t);
      } catch (o) {
        if (R(r), o !== o + 0)
          throw o;
        D(1, 0);
      }
    }
    function zo(e, t, r) {
      var o = x();
      try {
        return I(e)(t, r);
      } catch (s) {
        if (R(o), s !== s + 0)
          throw s;
        D(1, 0);
      }
    }
    function Bo(e) {
      var t = x();
      try {
        I(e)();
      } catch (r) {
        if (R(t), r !== r + 0)
          throw r;
        D(1, 0);
      }
    }
    function Go(e, t, r, o) {
      var s = x();
      try {
        return I(e)(t, r, o);
      } catch (u2) {
        if (R(s), u2 !== u2 + 0)
          throw u2;
        D(1, 0);
      }
    }
    function No(e, t, r, o, s, u2) {
      var l = x();
      try {
        I(e)(t, r, o, s, u2);
      } catch (f2) {
        if (R(l), f2 !== f2 + 0)
          throw f2;
        D(1, 0);
      }
    }
    function qo(e, t, r, o, s, u2, l) {
      var f2 = x();
      try {
        I(e)(t, r, o, s, u2, l);
      } catch (p2) {
        if (R(f2), p2 !== p2 + 0)
          throw p2;
        D(1, 0);
      }
    }
    function Yo(e, t, r, o, s, u2, l, f2, p2, m2, b) {
      var T = x();
      try {
        I(e)(t, r, o, s, u2, l, f2, p2, m2, b);
      } catch (E) {
        if (R(T), E !== E + 0)
          throw E;
        D(1, 0);
      }
    }
    function Jo(e, t, r, o, s, u2, l, f2) {
      var p2 = x();
      try {
        I(e)(t, r, o, s, u2, l, f2);
      } catch (m2) {
        if (R(p2), m2 !== m2 + 0)
          throw m2;
        D(1, 0);
      }
    }
    function Qo(e, t, r, o, s) {
      var u2 = x();
      try {
        I(e)(t, r, o, s);
      } catch (l) {
        if (R(u2), l !== l + 0)
          throw l;
        D(1, 0);
      }
    }
    function Xo(e, t, r, o, s, u2, l) {
      var f2 = x();
      try {
        return I(e)(t, r, o, s, u2, l);
      } catch (p2) {
        if (R(f2), p2 !== p2 + 0)
          throw p2;
        D(1, 0);
      }
    }
    function Zo(e, t, r, o, s, u2, l, f2, p2) {
      var m2 = x();
      try {
        I(e)(t, r, o, s, u2, l, f2, p2);
      } catch (b) {
        if (R(m2), b !== b + 0)
          throw b;
        D(1, 0);
      }
    }
    function Ko(e) {
      var t = x();
      try {
        return I(e)();
      } catch (r) {
        if (R(t), r !== r + 0)
          throw r;
        D(1, 0);
      }
    }
    function ea(e, t, r, o, s, u2, l) {
      var f2 = x();
      try {
        return I(e)(t, r, o, s, u2, l);
      } catch (p2) {
        if (R(f2), p2 !== p2 + 0)
          throw p2;
        D(1, 0);
      }
    }
    function ta(e, t, r, o) {
      var s = x();
      try {
        return I(e)(t, r, o);
      } catch (u2) {
        if (R(s), u2 !== u2 + 0)
          throw u2;
        D(1, 0);
      }
    }
    function ra(e, t, r, o) {
      var s = x();
      try {
        return I(e)(t, r, o);
      } catch (u2) {
        if (R(s), u2 !== u2 + 0)
          throw u2;
        D(1, 0);
      }
    }
    function na(e, t, r, o, s, u2) {
      var l = x();
      try {
        return I(e)(t, r, o, s, u2);
      } catch (f2) {
        if (R(l), f2 !== f2 + 0)
          throw f2;
        D(1, 0);
      }
    }
    function oa(e, t, r, o, s, u2) {
      var l = x();
      try {
        return I(e)(t, r, o, s, u2);
      } catch (f2) {
        if (R(l), f2 !== f2 + 0)
          throw f2;
        D(1, 0);
      }
    }
    function aa(e, t, r, o, s, u2, l, f2, p2, m2) {
      var b = x();
      try {
        return I(e)(t, r, o, s, u2, l, f2, p2, m2);
      } catch (T) {
        if (R(b), T !== T + 0)
          throw T;
        D(1, 0);
      }
    }
    function ia(e, t, r) {
      var o = x();
      try {
        return I(e)(t, r);
      } catch (s) {
        if (R(o), s !== s + 0)
          throw s;
        D(1, 0);
      }
    }
    function sa(e, t, r, o, s, u2, l, f2, p2, m2) {
      var b = x();
      try {
        I(e)(t, r, o, s, u2, l, f2, p2, m2);
      } catch (T) {
        if (R(b), T !== T + 0)
          throw T;
        D(1, 0);
      }
    }
    function ua(e, t, r, o, s, u2, l, f2) {
      var p2 = x();
      try {
        return I(e)(t, r, o, s, u2, l, f2);
      } catch (m2) {
        if (R(p2), m2 !== m2 + 0)
          throw m2;
        D(1, 0);
      }
    }
    function ca(e, t, r, o, s, u2, l, f2, p2) {
      var m2 = x();
      try {
        return I(e)(t, r, o, s, u2, l, f2, p2);
      } catch (b) {
        if (R(m2), b !== b + 0)
          throw b;
        D(1, 0);
      }
    }
    function la(e, t, r, o, s, u2, l) {
      var f2 = x();
      try {
        I(e)(t, r, o, s, u2, l);
      } catch (p2) {
        if (R(f2), p2 !== p2 + 0)
          throw p2;
        D(1, 0);
      }
    }
    function fa(e, t, r, o) {
      var s = x();
      try {
        return I(e)(t, r, o);
      } catch (u2) {
        if (R(s), u2 !== u2 + 0)
          throw u2;
        D(1, 0);
      }
    }
    function da(e, t, r, o, s, u2, l, f2, p2, m2, b, T) {
      var E = x();
      try {
        return I(e)(t, r, o, s, u2, l, f2, p2, m2, b, T);
      } catch (k) {
        if (R(E), k !== k + 0)
          throw k;
        D(1, 0);
      }
    }
    function pa(e, t, r, o, s, u2, l, f2, p2, m2, b, T, E, k, H2, q2) {
      var V2 = x();
      try {
        I(e)(t, r, o, s, u2, l, f2, p2, m2, b, T, E, k, H2, q2);
      } catch (Y2) {
        if (R(V2), Y2 !== Y2 + 0)
          throw Y2;
        D(1, 0);
      }
    }
    function ha(e, t, r, o) {
      var s = x();
      try {
        return dr(e, t, r, o);
      } catch (u2) {
        if (R(s), u2 !== u2 + 0)
          throw u2;
        D(1, 0);
      }
    }
    function va(e, t, r, o, s) {
      var u2 = x();
      try {
        return pr(e, t, r, o, s);
      } catch (l) {
        if (R(u2), l !== l + 0)
          throw l;
        D(1, 0);
      }
    }
    var Ke;
    ve2 = function e() {
      Ke || hr(), Ke || (ve2 = e);
    };
    function hr() {
      if (J2 > 0 || (ut(), J2 > 0))
        return;
      function e() {
        Ke || (Ke = true, a.calledRun = true, !z2 && (Me(), c2(a), a.onRuntimeInitialized && a.onRuntimeInitialized(), He()));
      }
      a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          a.setStatus("");
        }, 1), e();
      }, 1)) : e();
    }
    if (a.preInit)
      for (typeof a.preInit == "function" && (a.preInit = [a.preInit]); a.preInit.length > 0; )
        a.preInit.pop()();
    return hr(), i.ready;
  };
})();
function za(n) {
  return Dr(xr, n);
}
async function Ba(n, {
  tryHarder: i = de.tryHarder,
  formats: a = de.formats,
  maxSymbols: c2 = de.maxSymbols
} = de) {
  return La(
    n,
    {
      tryHarder: i,
      formats: a,
      maxSymbols: c2
    },
    xr
  );
}
const Rr = /* @__PURE__ */ new Map([
  ["aztec", "Aztec"],
  ["code_128", "Code128"],
  ["code_39", "Code39"],
  ["code_93", "Code93"],
  ["codabar", "Codabar"],
  ["data_matrix", "DataMatrix"],
  ["ean_13", "EAN-13"],
  ["ean_8", "EAN-8"],
  ["itf", "ITF"],
  ["pdf417", "PDF417"],
  ["qr_code", "QRCode"],
  ["upc_a", "UPC-A"],
  ["upc_e", "UPC-E"]
]);
function Ga(n) {
  for (const [i, a] of Rr)
    if (n === a)
      return i;
  return "unknown";
}
var nt;
class st {
  constructor(i = {}) {
    $a(this, nt, void 0);
    var a;
    try {
      const c2 = (a = i == null ? void 0 : i.formats) == null ? void 0 : a.filter(
        (d2) => d2 !== "unknown"
      );
      if ((c2 == null ? void 0 : c2.length) === 0)
        throw new TypeError("Hint option provided, but is empty.");
      c2 == null || c2.forEach((d2) => {
        if (!vr.includes(d2))
          throw new TypeError(
            `Failed to read the 'formats' property from 'BarcodeDetectorOptions': The provided value '${d2}' is not a valid enum value of type BarcodeFormat.`
          );
      }), za().catch(() => {
      }), Sa(this, nt, c2 ?? []);
    } catch (c2) {
      throw mr(
        c2,
        "Failed to construct 'BarcodeDetector'"
      );
    }
  }
  static async getSupportedFormats() {
    return vr.filter((i) => i !== "unknown");
  }
  async detect(i) {
    try {
      const a = await xa(i);
      if (a === null)
        return [];
      let c2;
      try {
        c2 = await Ba(a, {
          tryHarder: true,
          formats: _a(this, nt).map(
            (d2) => Rr.get(d2)
          )
        });
      } catch (d2) {
        throw new DOMException(
          "Barcode detection service unavailable. Use 'setZXingModuleOverrides' in offline or strict CSP environments.",
          "NotSupportedError"
        );
      }
      return c2.map((d2) => {
        const {
          topLeft: { x: h2, y: v },
          topRight: { x: w, y: C },
          bottomLeft: { x: y2, y: _ },
          bottomRight: { x: S, y: $ }
        } = d2.position, j = Math.min(h2, w, y2, S), U2 = Math.min(v, C, _, $), O2 = Math.max(h2, w, y2, S), z2 = Math.max(v, C, _, $);
        return {
          boundingBox: new DOMRectReadOnly(
            j,
            U2,
            O2 - j,
            z2 - U2
          ),
          rawValue: new TextDecoder().decode(d2.bytes),
          format: Ga(d2.format),
          cornerPoints: [
            {
              x: h2,
              y: v
            },
            {
              x: w,
              y: C
            },
            {
              x: S,
              y: $
            },
            {
              x: y2,
              y: _
            }
          ]
        };
      });
    } catch (a) {
      throw mr(
        a,
        "Failed to execute 'detect' on 'BarcodeDetector'"
      );
    }
  }
}
nt = /* @__PURE__ */ new WeakMap();
const kr = (n, i, a = "error") => {
  let c2, d2;
  const h2 = new Promise(
    (v, w) => {
      c2 = v, d2 = w, n.addEventListener(i, c2), n.addEventListener(a, d2);
    }
  );
  return h2.finally(() => {
    n.removeEventListener(i, c2), n.removeEventListener(a, d2);
  }), h2;
}, br = (n) => new Promise((i) => setTimeout(i, n));
class Na extends Error {
  constructor() {
    super("can't process cross-origin image"), this.name = "DropImageFetchError";
  }
}
class Fr extends Error {
  constructor() {
    super("this browser has no Stream API support"), this.name = "StreamApiNotSupportedError";
  }
}
class qa extends Error {
  constructor() {
    super(
      "camera access is only permitted in secure context. Use HTTPS or localhost rather than HTTP."
    ), this.name = "InsecureContextError";
  }
}
class Ya extends Error {
  constructor() {
    super("Loading camera stream timed out after 3 seconds. If you are on iOS in PWA mode, this is a known issue (see https://github.com/gruhn/vue-qrcode-reader/issues/298)"), this.name = "StreamLoadTimeoutError";
  }
}
let At;
const Ja = (n) => {
  At = new st({ formats: n });
}, Qa = async (n, {
  detectHandler: i,
  locateHandler: a,
  minDelay: c2,
  formats: d2
}) => {
  At = new st({ formats: d2 });
  const h2 = (v) => async (w) => {
    if (n.readyState > 1) {
      const { lastScanned: C, contentBefore: y2, lastScanHadContent: _ } = v;
      if (w - C < c2)
        window.requestAnimationFrame(h2(v));
      else {
        const S = await At.detect(n), $ = S.some((O2) => !y2.includes(O2.rawValue));
        $ && i(S);
        const j = S.length > 0;
        j && a(S), !j && _ && a(S);
        const U2 = {
          lastScanned: w,
          lastScanHadContent: j,
          // It can happen that a QR code is constantly in view of the camera but
          // maybe a scanned frame is a bit blurry and we detect nothing but in the
          // next frame we detect the code again. We also want to avoid emitting
          // a `detect` event in such a case. So we don't reset `contentBefore`,
          // if we detect nothing, only if we detect something new.
          contentBefore: $ ? S.map((O2) => O2.rawValue) : y2
        };
        window.requestAnimationFrame(h2(U2));
      }
    }
  };
  h2({
    lastScanned: performance.now(),
    contentBefore: [],
    lastScanHadContent: false
  })(performance.now());
}, Xa = async (n) => {
  if (n.startsWith("http") && n.includes(location.host) === false)
    throw new Na();
  const i = document.createElement("img");
  return i.src = n, await kr(i, "load"), i;
}, Ir = async (n, i = ["qr_code"]) => await new st({
  formats: i
}).detect(n), Za = async (n, i = ["qr_code"]) => {
  const a = new st({
    formats: i
  }), c2 = await Xa(n);
  return await a.detect(c2);
};
var Ur = {}, X = {};
Object.defineProperty(X, "__esModule", {
  value: true
});
X.compactObject = Lr;
X.deprecated = si;
var Ka = X.detectBrowser = ui;
X.disableLog = oi;
X.disableWarnings = ai;
X.extractVersion = ot;
X.filterStats = ci;
X.log = ii;
X.walkStats = at;
X.wrapPeerConnectionEvent = ni;
function ei(n, i, a) {
  return i = ti(i), i in n ? Object.defineProperty(n, i, { value: a, enumerable: true, configurable: true, writable: true }) : n[i] = a, n;
}
function ti(n) {
  var i = ri(n, "string");
  return pe(i) === "symbol" ? i : String(i);
}
function ri(n, i) {
  if (pe(n) !== "object" || n === null)
    return n;
  var a = n[Symbol.toPrimitive];
  if (a !== void 0) {
    var c2 = a.call(n, i || "default");
    if (pe(c2) !== "object")
      return c2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (i === "string" ? String : Number)(n);
}
function pe(n) {
  "@babel/helpers - typeof";
  return pe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
    return typeof i;
  } : function(i) {
    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
  }, pe(n);
}
var jr = true, Wr = true;
function ot(n, i, a) {
  var c2 = n.match(i);
  return c2 && c2.length >= a && parseInt(c2[a], 10);
}
function ni(n, i, a) {
  if (n.RTCPeerConnection) {
    var c2 = n.RTCPeerConnection.prototype, d2 = c2.addEventListener;
    c2.addEventListener = function(v, w) {
      if (v !== i)
        return d2.apply(this, arguments);
      var C = function(_) {
        var S = a(_);
        S && (w.handleEvent ? w.handleEvent(S) : w(S));
      };
      return this._eventMap = this._eventMap || {}, this._eventMap[i] || (this._eventMap[i] = /* @__PURE__ */ new Map()), this._eventMap[i].set(w, C), d2.apply(this, [v, C]);
    };
    var h2 = c2.removeEventListener;
    c2.removeEventListener = function(v, w) {
      if (v !== i || !this._eventMap || !this._eventMap[i])
        return h2.apply(this, arguments);
      if (!this._eventMap[i].has(w))
        return h2.apply(this, arguments);
      var C = this._eventMap[i].get(w);
      return this._eventMap[i].delete(w), this._eventMap[i].size === 0 && delete this._eventMap[i], Object.keys(this._eventMap).length === 0 && delete this._eventMap, h2.apply(this, [v, C]);
    }, Object.defineProperty(c2, "on" + i, {
      get: function() {
        return this["_on" + i];
      },
      set: function(w) {
        this["_on" + i] && (this.removeEventListener(i, this["_on" + i]), delete this["_on" + i]), w && this.addEventListener(i, this["_on" + i] = w);
      },
      enumerable: true,
      configurable: true
    });
  }
}
function oi(n) {
  return typeof n != "boolean" ? new Error("Argument type: " + pe(n) + ". Please use a boolean.") : (jr = n, n ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function ai(n) {
  return typeof n != "boolean" ? new Error("Argument type: " + pe(n) + ". Please use a boolean.") : (Wr = !n, "adapter.js deprecation warnings " + (n ? "disabled" : "enabled"));
}
function ii() {
  if ((typeof window > "u" ? "undefined" : pe(window)) === "object") {
    if (jr)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function si(n, i) {
  Wr && console.warn(n + " is deprecated, please use " + i + " instead.");
}
function ui(n) {
  var i = {
    browser: null,
    version: null
  };
  if (typeof n > "u" || !n.navigator || !n.navigator.userAgent)
    return i.browser = "Not a browser.", i;
  var a = n.navigator;
  if (a.mozGetUserMedia)
    i.browser = "firefox", i.version = ot(a.userAgent, /Firefox\/(\d+)\./, 1);
  else if (a.webkitGetUserMedia || n.isSecureContext === false && n.webkitRTCPeerConnection)
    i.browser = "chrome", i.version = ot(a.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (n.RTCPeerConnection && a.userAgent.match(/AppleWebKit\/(\d+)\./))
    i.browser = "safari", i.version = ot(a.userAgent, /AppleWebKit\/(\d+)\./, 1), i.supportsUnifiedPlan = n.RTCRtpTransceiver && "currentDirection" in n.RTCRtpTransceiver.prototype;
  else
    return i.browser = "Not a supported browser.", i;
  return i;
}
function Cr(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function Lr(n) {
  return Cr(n) ? Object.keys(n).reduce(function(i, a) {
    var c2 = Cr(n[a]), d2 = c2 ? Lr(n[a]) : n[a], h2 = c2 && !Object.keys(d2).length;
    return d2 === void 0 || h2 ? i : Object.assign(i, ei({}, a, d2));
  }, {}) : n;
}
function at(n, i, a) {
  !i || a.has(i.id) || (a.set(i.id, i), Object.keys(i).forEach(function(c2) {
    c2.endsWith("Id") ? at(n, n.get(i[c2]), a) : c2.endsWith("Ids") && i[c2].forEach(function(d2) {
      at(n, n.get(d2), a);
    });
  }));
}
function ci(n, i, a) {
  var c2 = a ? "outbound-rtp" : "inbound-rtp", d2 = /* @__PURE__ */ new Map();
  if (i === null)
    return d2;
  var h2 = [];
  return n.forEach(function(v) {
    v.type === "track" && v.trackIdentifier === i.id && h2.push(v);
  }), h2.forEach(function(v) {
    n.forEach(function(w) {
      w.type === c2 && w.trackId === v.id && at(n, w, d2);
    });
  }), d2;
}
Object.defineProperty(Ur, "__esModule", {
  value: true
});
var li = Ur.shimGetUserMedia = pi, fi = di(X);
function Hr(n) {
  if (typeof WeakMap != "function")
    return null;
  var i = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap();
  return (Hr = function(d2) {
    return d2 ? a : i;
  })(n);
}
function di(n, i) {
  if (!i && n && n.__esModule)
    return n;
  if (n === null || fe(n) !== "object" && typeof n != "function")
    return { default: n };
  var a = Hr(i);
  if (a && a.has(n))
    return a.get(n);
  var c2 = {}, d2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var h2 in n)
    if (h2 !== "default" && Object.prototype.hasOwnProperty.call(n, h2)) {
      var v = d2 ? Object.getOwnPropertyDescriptor(n, h2) : null;
      v && (v.get || v.set) ? Object.defineProperty(c2, h2, v) : c2[h2] = n[h2];
    }
  return c2.default = n, a && a.set(n, c2), c2;
}
function fe(n) {
  "@babel/helpers - typeof";
  return fe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
    return typeof i;
  } : function(i) {
    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
  }, fe(n);
}
var _r = fi.log;
function pi(n, i) {
  var a = n && n.navigator;
  if (a.mediaDevices) {
    var c2 = function(y2) {
      if (fe(y2) !== "object" || y2.mandatory || y2.optional)
        return y2;
      var _ = {};
      return Object.keys(y2).forEach(function(S) {
        if (!(S === "require" || S === "advanced" || S === "mediaSource")) {
          var $ = fe(y2[S]) === "object" ? y2[S] : {
            ideal: y2[S]
          };
          $.exact !== void 0 && typeof $.exact == "number" && ($.min = $.max = $.exact);
          var j = function(z2, M) {
            return z2 ? z2 + M.charAt(0).toUpperCase() + M.slice(1) : M === "deviceId" ? "sourceId" : M;
          };
          if ($.ideal !== void 0) {
            _.optional = _.optional || [];
            var U2 = {};
            typeof $.ideal == "number" ? (U2[j("min", S)] = $.ideal, _.optional.push(U2), U2 = {}, U2[j("max", S)] = $.ideal, _.optional.push(U2)) : (U2[j("", S)] = $.ideal, _.optional.push(U2));
          }
          $.exact !== void 0 && typeof $.exact != "number" ? (_.mandatory = _.mandatory || {}, _.mandatory[j("", S)] = $.exact) : ["min", "max"].forEach(function(O2) {
            $[O2] !== void 0 && (_.mandatory = _.mandatory || {}, _.mandatory[j(O2, S)] = $[O2]);
          });
        }
      }), y2.advanced && (_.optional = (_.optional || []).concat(y2.advanced)), _;
    }, d2 = function(y2, _) {
      if (i.version >= 61)
        return _(y2);
      if (y2 = JSON.parse(JSON.stringify(y2)), y2 && fe(y2.audio) === "object") {
        var S = function(z2, M, A) {
          M in z2 && !(A in z2) && (z2[A] = z2[M], delete z2[M]);
        };
        y2 = JSON.parse(JSON.stringify(y2)), S(y2.audio, "autoGainControl", "googAutoGainControl"), S(y2.audio, "noiseSuppression", "googNoiseSuppression"), y2.audio = c2(y2.audio);
      }
      if (y2 && fe(y2.video) === "object") {
        var $ = y2.video.facingMode;
        $ = $ && (fe($) === "object" ? $ : {
          ideal: $
        });
        var j = i.version < 66;
        if ($ && ($.exact === "user" || $.exact === "environment" || $.ideal === "user" || $.ideal === "environment") && !(a.mediaDevices.getSupportedConstraints && a.mediaDevices.getSupportedConstraints().facingMode && !j)) {
          delete y2.video.facingMode;
          var U2;
          if ($.exact === "environment" || $.ideal === "environment" ? U2 = ["back", "rear"] : ($.exact === "user" || $.ideal === "user") && (U2 = ["front"]), U2)
            return a.mediaDevices.enumerateDevices().then(function(O2) {
              O2 = O2.filter(function(M) {
                return M.kind === "videoinput";
              });
              var z2 = O2.find(function(M) {
                return U2.some(function(A) {
                  return M.label.toLowerCase().includes(A);
                });
              });
              return !z2 && O2.length && U2.includes("back") && (z2 = O2[O2.length - 1]), z2 && (y2.video.deviceId = $.exact ? {
                exact: z2.deviceId
              } : {
                ideal: z2.deviceId
              }), y2.video = c2(y2.video), _r("chrome: " + JSON.stringify(y2)), _(y2);
            });
        }
        y2.video = c2(y2.video);
      }
      return _r("chrome: " + JSON.stringify(y2)), _(y2);
    }, h2 = function(y2) {
      return i.version >= 64 ? y2 : {
        name: {
          PermissionDeniedError: "NotAllowedError",
          PermissionDismissedError: "NotAllowedError",
          InvalidStateError: "NotAllowedError",
          DevicesNotFoundError: "NotFoundError",
          ConstraintNotSatisfiedError: "OverconstrainedError",
          TrackStartError: "NotReadableError",
          MediaDeviceFailedDueToShutdown: "NotAllowedError",
          MediaDeviceKillSwitchOn: "NotAllowedError",
          TabCaptureError: "AbortError",
          ScreenCaptureError: "AbortError",
          DeviceCaptureError: "AbortError"
        }[y2.name] || y2.name,
        message: y2.message,
        constraint: y2.constraint || y2.constraintName,
        toString: function() {
          return this.name + (this.message && ": ") + this.message;
        }
      };
    }, v = function(y2, _, S) {
      d2(y2, function($) {
        a.webkitGetUserMedia($, _, function(j) {
          S && S(h2(j));
        });
      });
    };
    if (a.getUserMedia = v.bind(a), a.mediaDevices.getUserMedia) {
      var w = a.mediaDevices.getUserMedia.bind(a.mediaDevices);
      a.mediaDevices.getUserMedia = function(C) {
        return d2(C, function(y2) {
          return w(y2).then(function(_) {
            if (y2.audio && !_.getAudioTracks().length || y2.video && !_.getVideoTracks().length)
              throw _.getTracks().forEach(function(S) {
                S.stop();
              }), new DOMException("", "NotFoundError");
            return _;
          }, function(_) {
            return Promise.reject(h2(_));
          });
        });
      };
    }
  }
}
var Vr = {};
Object.defineProperty(Vr, "__esModule", {
  value: true
});
var hi = Vr.shimGetUserMedia = yi, vi = mi(X);
function zr(n) {
  if (typeof WeakMap != "function")
    return null;
  var i = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap();
  return (zr = function(d2) {
    return d2 ? a : i;
  })(n);
}
function mi(n, i) {
  if (!i && n && n.__esModule)
    return n;
  if (n === null || Pe(n) !== "object" && typeof n != "function")
    return { default: n };
  var a = zr(i);
  if (a && a.has(n))
    return a.get(n);
  var c2 = {}, d2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var h2 in n)
    if (h2 !== "default" && Object.prototype.hasOwnProperty.call(n, h2)) {
      var v = d2 ? Object.getOwnPropertyDescriptor(n, h2) : null;
      v && (v.get || v.set) ? Object.defineProperty(c2, h2, v) : c2[h2] = n[h2];
    }
  return c2.default = n, a && a.set(n, c2), c2;
}
function Pe(n) {
  "@babel/helpers - typeof";
  return Pe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
    return typeof i;
  } : function(i) {
    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
  }, Pe(n);
}
function yi(n, i) {
  var a = n && n.navigator, c2 = n && n.MediaStreamTrack;
  if (a.getUserMedia = function(C, y2, _) {
    vi.deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), a.mediaDevices.getUserMedia(C).then(y2, _);
  }, !(i.version > 55 && "autoGainControl" in a.mediaDevices.getSupportedConstraints())) {
    var d2 = function(y2, _, S) {
      _ in y2 && !(S in y2) && (y2[S] = y2[_], delete y2[_]);
    }, h2 = a.mediaDevices.getUserMedia.bind(a.mediaDevices);
    if (a.mediaDevices.getUserMedia = function(C) {
      return Pe(C) === "object" && Pe(C.audio) === "object" && (C = JSON.parse(JSON.stringify(C)), d2(C.audio, "autoGainControl", "mozAutoGainControl"), d2(C.audio, "noiseSuppression", "mozNoiseSuppression")), h2(C);
    }, c2 && c2.prototype.getSettings) {
      var v = c2.prototype.getSettings;
      c2.prototype.getSettings = function() {
        var C = v.apply(this, arguments);
        return d2(C, "mozAutoGainControl", "autoGainControl"), d2(C, "mozNoiseSuppression", "noiseSuppression"), C;
      };
    }
    if (c2 && c2.prototype.applyConstraints) {
      var w = c2.prototype.applyConstraints;
      c2.prototype.applyConstraints = function(C) {
        return this.kind === "audio" && Pe(C) === "object" && (C = JSON.parse(JSON.stringify(C)), d2(C, "autoGainControl", "mozAutoGainControl"), d2(C, "noiseSuppression", "mozNoiseSuppression")), w.apply(this, [C]);
      };
    }
  }
}
var te = {};
Object.defineProperty(te, "__esModule", {
  value: true
});
te.shimAudioContext = Ei;
te.shimCallbacksAPI = _i;
te.shimConstraints = Nr;
te.shimCreateOfferLegacy = Ti;
var gi = te.shimGetUserMedia = $i;
te.shimLocalStreamsAPI = bi;
te.shimRTCIceServerUrls = Si;
te.shimRemoteStreamsAPI = Ci;
te.shimTrackEventTransceiver = Pi;
var Br = wi(X);
function Gr(n) {
  if (typeof WeakMap != "function")
    return null;
  var i = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap();
  return (Gr = function(d2) {
    return d2 ? a : i;
  })(n);
}
function wi(n, i) {
  if (!i && n && n.__esModule)
    return n;
  if (n === null || he(n) !== "object" && typeof n != "function")
    return { default: n };
  var a = Gr(i);
  if (a && a.has(n))
    return a.get(n);
  var c2 = {}, d2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var h2 in n)
    if (h2 !== "default" && Object.prototype.hasOwnProperty.call(n, h2)) {
      var v = d2 ? Object.getOwnPropertyDescriptor(n, h2) : null;
      v && (v.get || v.set) ? Object.defineProperty(c2, h2, v) : c2[h2] = n[h2];
    }
  return c2.default = n, a && a.set(n, c2), c2;
}
function he(n) {
  "@babel/helpers - typeof";
  return he = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
    return typeof i;
  } : function(i) {
    return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
  }, he(n);
}
function bi(n) {
  if (!(he(n) !== "object" || !n.RTCPeerConnection)) {
    if ("getLocalStreams" in n.RTCPeerConnection.prototype || (n.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in n.RTCPeerConnection.prototype)) {
      var i = n.RTCPeerConnection.prototype.addTrack;
      n.RTCPeerConnection.prototype.addStream = function(c2) {
        var d2 = this;
        this._localStreams || (this._localStreams = []), this._localStreams.includes(c2) || this._localStreams.push(c2), c2.getAudioTracks().forEach(function(h2) {
          return i.call(d2, h2, c2);
        }), c2.getVideoTracks().forEach(function(h2) {
          return i.call(d2, h2, c2);
        });
      }, n.RTCPeerConnection.prototype.addTrack = function(c2) {
        for (var d2 = this, h2 = arguments.length, v = new Array(h2 > 1 ? h2 - 1 : 0), w = 1; w < h2; w++)
          v[w - 1] = arguments[w];
        return v && v.forEach(function(C) {
          d2._localStreams ? d2._localStreams.includes(C) || d2._localStreams.push(C) : d2._localStreams = [C];
        }), i.apply(this, arguments);
      };
    }
    "removeStream" in n.RTCPeerConnection.prototype || (n.RTCPeerConnection.prototype.removeStream = function(c2) {
      var d2 = this;
      this._localStreams || (this._localStreams = []);
      var h2 = this._localStreams.indexOf(c2);
      if (h2 !== -1) {
        this._localStreams.splice(h2, 1);
        var v = c2.getTracks();
        this.getSenders().forEach(function(w) {
          v.includes(w.track) && d2.removeTrack(w);
        });
      }
    });
  }
}
function Ci(n) {
  if (!(he(n) !== "object" || !n.RTCPeerConnection) && ("getRemoteStreams" in n.RTCPeerConnection.prototype || (n.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in n.RTCPeerConnection.prototype))) {
    Object.defineProperty(n.RTCPeerConnection.prototype, "onaddstream", {
      get: function() {
        return this._onaddstream;
      },
      set: function(c2) {
        var d2 = this;
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = c2), this.addEventListener("track", this._onaddstreampoly = function(h2) {
          h2.streams.forEach(function(v) {
            if (d2._remoteStreams || (d2._remoteStreams = []), !d2._remoteStreams.includes(v)) {
              d2._remoteStreams.push(v);
              var w = new Event("addstream");
              w.stream = v, d2.dispatchEvent(w);
            }
          });
        });
      }
    });
    var i = n.RTCPeerConnection.prototype.setRemoteDescription;
    n.RTCPeerConnection.prototype.setRemoteDescription = function() {
      var c2 = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(d2) {
        d2.streams.forEach(function(h2) {
          if (c2._remoteStreams || (c2._remoteStreams = []), !(c2._remoteStreams.indexOf(h2) >= 0)) {
            c2._remoteStreams.push(h2);
            var v = new Event("addstream");
            v.stream = h2, c2.dispatchEvent(v);
          }
        });
      }), i.apply(c2, arguments);
    };
  }
}
function _i(n) {
  if (!(he(n) !== "object" || !n.RTCPeerConnection)) {
    var i = n.RTCPeerConnection.prototype, a = i.createOffer, c2 = i.createAnswer, d2 = i.setLocalDescription, h2 = i.setRemoteDescription, v = i.addIceCandidate;
    i.createOffer = function(y2, _) {
      var S = arguments.length >= 2 ? arguments[2] : arguments[0], $ = a.apply(this, [S]);
      return _ ? ($.then(y2, _), Promise.resolve()) : $;
    }, i.createAnswer = function(y2, _) {
      var S = arguments.length >= 2 ? arguments[2] : arguments[0], $ = c2.apply(this, [S]);
      return _ ? ($.then(y2, _), Promise.resolve()) : $;
    };
    var w = function(y2, _, S) {
      var $ = d2.apply(this, [y2]);
      return S ? ($.then(_, S), Promise.resolve()) : $;
    };
    i.setLocalDescription = w, w = function(y2, _, S) {
      var $ = h2.apply(this, [y2]);
      return S ? ($.then(_, S), Promise.resolve()) : $;
    }, i.setRemoteDescription = w, w = function(y2, _, S) {
      var $ = v.apply(this, [y2]);
      return S ? ($.then(_, S), Promise.resolve()) : $;
    }, i.addIceCandidate = w;
  }
}
function $i(n) {
  var i = n && n.navigator;
  if (i.mediaDevices && i.mediaDevices.getUserMedia) {
    var a = i.mediaDevices, c2 = a.getUserMedia.bind(a);
    i.mediaDevices.getUserMedia = function(d2) {
      return c2(Nr(d2));
    };
  }
  !i.getUserMedia && i.mediaDevices && i.mediaDevices.getUserMedia && (i.getUserMedia = (function(h2, v, w) {
    i.mediaDevices.getUserMedia(h2).then(v, w);
  }).bind(i));
}
function Nr(n) {
  return n && n.video !== void 0 ? Object.assign({}, n, {
    video: Br.compactObject(n.video)
  }) : n;
}
function Si(n) {
  if (n.RTCPeerConnection) {
    var i = n.RTCPeerConnection;
    n.RTCPeerConnection = function(c2, d2) {
      if (c2 && c2.iceServers) {
        for (var h2 = [], v = 0; v < c2.iceServers.length; v++) {
          var w = c2.iceServers[v];
          w.urls === void 0 && w.url ? (Br.deprecated("RTCIceServer.url", "RTCIceServer.urls"), w = JSON.parse(JSON.stringify(w)), w.urls = w.url, delete w.url, h2.push(w)) : h2.push(c2.iceServers[v]);
        }
        c2.iceServers = h2;
      }
      return new i(c2, d2);
    }, n.RTCPeerConnection.prototype = i.prototype, "generateCertificate" in i && Object.defineProperty(n.RTCPeerConnection, "generateCertificate", {
      get: function() {
        return i.generateCertificate;
      }
    });
  }
}
function Pi(n) {
  he(n) === "object" && n.RTCTrackEvent && "receiver" in n.RTCTrackEvent.prototype && !("transceiver" in n.RTCTrackEvent.prototype) && Object.defineProperty(n.RTCTrackEvent.prototype, "transceiver", {
    get: function() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function Ti(n) {
  var i = n.RTCPeerConnection.prototype.createOffer;
  n.RTCPeerConnection.prototype.createOffer = function(c2) {
    if (c2) {
      typeof c2.offerToReceiveAudio < "u" && (c2.offerToReceiveAudio = !!c2.offerToReceiveAudio);
      var d2 = this.getTransceivers().find(function(v) {
        return v.receiver.track.kind === "audio";
      });
      c2.offerToReceiveAudio === false && d2 ? d2.direction === "sendrecv" ? d2.setDirection ? d2.setDirection("sendonly") : d2.direction = "sendonly" : d2.direction === "recvonly" && (d2.setDirection ? d2.setDirection("inactive") : d2.direction = "inactive") : c2.offerToReceiveAudio === true && !d2 && this.addTransceiver("audio", {
        direction: "recvonly"
      }), typeof c2.offerToReceiveVideo < "u" && (c2.offerToReceiveVideo = !!c2.offerToReceiveVideo);
      var h2 = this.getTransceivers().find(function(v) {
        return v.receiver.track.kind === "video";
      });
      c2.offerToReceiveVideo === false && h2 ? h2.direction === "sendrecv" ? h2.setDirection ? h2.setDirection("sendonly") : h2.direction = "sendonly" : h2.direction === "recvonly" && (h2.setDirection ? h2.setDirection("inactive") : h2.direction = "inactive") : c2.offerToReceiveVideo === true && !h2 && this.addTransceiver("video", {
        direction: "recvonly"
      });
    }
    return i.apply(this, arguments);
  };
}
function Ei(n) {
  he(n) !== "object" || n.AudioContext || (n.AudioContext = n.webkitAudioContext);
}
const Oi = (n) => {
  let i = false, a;
  return (...c2) => (i || (a = n(c2), i = true), a);
};
function ie(n, i) {
  if (n === false)
    throw new Error(i ?? "assertion failure");
}
const Mi = Oi(() => {
  const n = Ka(window);
  switch (n.browser) {
    case "chrome":
      li(window, n);
      break;
    case "firefox":
      hi(window, n);
      break;
    case "safari":
      gi(window, n);
      break;
    default:
      throw new Fr();
  }
});
let se = { isActive: false };
function Mt() {
  if (se.isActive) {
    se.videoEl.src = "", se.videoEl.srcObject = null, se.videoEl.load();
    for (const n of se.stream.getTracks())
      se.stream.removeTrack(n), n.stop();
    se = { isActive: false };
  }
}
async function Ai(n, { constraints: i, torch: a }) {
  var h2, v;
  if (window.isSecureContext !== true)
    throw new qa();
  if (((h2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : h2.getUserMedia) === void 0)
    throw new Fr();
  Mi();
  const c2 = await navigator.mediaDevices.getUserMedia({
    audio: false,
    video: i
  });
  if (n.srcObject !== void 0 ? n.srcObject = c2 : n.mozSrcObject !== void 0 ? n.mozSrcObject = c2 : window.URL.createObjectURL ? n.src = window.URL.createObjectURL(c2) : window.webkitURL ? n.src = window.webkitURL.createObjectURL(c2) : n.src = c2.id, await Promise.race([
    kr(n, "loadeddata"),
    // On iOS devices in PWA mode, QrcodeStream works initially, but after
    // killing and restarting the PWA, all video elements fail to load camera 
    // streams and never emit the `loadeddata` event. Looks like this is 
    // related to a WebKit issue (see #298). No workarounds at the moment. 
    // To at least detect this situation, we throw an error if the event
    // has not been emitted after a 3 second timeout.
    br(3e3).then(() => {
      throw new Ya();
    })
  ]), await br(500), a) {
    const [w] = c2.getVideoTracks();
    w.getCapabilities().torch ? w.applyConstraints({ advanced: [{ torch: true }] }) : console.warn("device does not support torch capability");
  }
  se = { videoEl: n, stream: c2, isActive: true };
  const [d2] = se.stream.getVideoTracks();
  return ((v = d2 == null ? void 0 : d2.getCapabilities) == null ? void 0 : v.call(d2)) ?? {};
}
const Di = /* @__PURE__ */ defineComponent({
  __name: "QrcodeStream",
  props: {
    constraints: {
      type: Object,
      default() {
        return { facingMode: "environment" };
      }
    },
    formats: {
      type: Array,
      default: () => ["qr_code"]
    },
    paused: {
      type: Boolean,
      default: false
    },
    torch: {
      type: Boolean,
      default: false
    },
    track: {
      type: Function
    }
  },
  emits: ["detect", "camera-on", "camera-off", "error"],
  setup(n, { emit: i }) {
    const a = n, c2 = ref(), d2 = ref(), h2 = ref(), v = ref(false), w = ref(false);
    onMounted(() => {
      w.value = true;
    }), onUnmounted(() => {
      Mt();
    });
    const C = computed(() => ({
      torch: a.torch,
      constraints: a.constraints,
      shouldStream: w.value && !a.paused
    }));
    watch(C, async (M) => {
      const A = h2.value;
      ie(A !== void 0, "cameraSettings watcher should never be triggered when component is not mounted. Thus video element should always be defined.");
      const B = c2.value;
      ie(B !== void 0, "cameraSettings watcher should never be triggered when component is not mounted. Thus canvas should always be defined.");
      const ee = B.getContext("2d");
      if (ie(ee !== null, "if cavnas is defined, canvas 2d context should also be non-null"), M.shouldStream)
        try {
          const W2 = await Ai(A, M);
          w.value ? (v.value = true, i("camera-on", W2)) : Mt();
        } catch (W2) {
          i("error", W2);
        }
      else
        B.width = A.videoWidth, B.height = A.videoHeight, ee.drawImage(A, 0, 0, A.videoWidth, A.videoHeight), Mt(), v.value = false, i("camera-off");
    }, { deep: true });
    const { formats: y2 } = toRefs(a);
    watch(y2, (M) => {
      w.value && Ja(M);
    });
    const _ = computed(() => C.value.shouldStream && v.value);
    watch(_, (M) => {
      if (M) {
        ie(c2.value !== void 0, "shouldScan watcher should only be triggered when component is mounted. Thus pause frame canvas is defined"), S(c2.value), ie(d2.value !== void 0, "shouldScan watcher should only be triggered when component is mounted. Thus tracking canvas is defined"), S(d2.value);
        const A = () => a.track === void 0 ? 500 : 40;
        ie(h2.value !== void 0, "shouldScan watcher should only be triggered when component is mounted. Thus video element is defined"), Qa(h2.value, {
          detectHandler: (B) => i("detect", B),
          formats: a.formats,
          locateHandler: $,
          minDelay: A()
        });
      }
    });
    const S = (M) => {
      const A = M.getContext("2d");
      ie(A !== null, "canvas 2d context should always be non-null"), A.clearRect(0, 0, M.width, M.height);
    }, $ = (M) => {
      const A = d2.value;
      ie(A !== void 0, "onLocate handler should only be called when component is mounted. Thus tracking canvas is always defined.");
      const B = h2.value;
      if (ie(B !== void 0, "onLocate handler should only be called when component is mounted. Thus video element is always defined."), M.length === 0 || a.track === void 0)
        S(A);
      else {
        const ee = B.offsetWidth, W2 = B.offsetHeight, L = B.videoWidth, be2 = B.videoHeight, Te = Math.max(ee / L, W2 / be2), Ee = L * Te, Oe = be2 * Te, je = Ee / L, We = Oe / be2, Le = (ee - Ee) / 2, ut = (W2 - Oe) / 2, Me = ({ x: ue2, y: J2 }) => ({
          x: Math.floor(ue2 * je),
          y: Math.floor(J2 * We)
        }), He = ({ x: ue2, y: J2 }) => ({
          x: Math.floor(ue2 + Le),
          y: Math.floor(J2 + ut)
        }), ct = M.map((ue2) => {
          const { boundingBox: J2, cornerPoints: ve2 } = ue2, { x: ft, y: dt } = He(
            Me({
              x: J2.x,
              y: J2.y
            })
          ), { x: Ce, y: pt } = Me({
            x: J2.width,
            y: J2.height
          });
          return {
            ...ue2,
            cornerPoints: ve2.map((Ve) => He(Me(Ve))),
            boundingBox: DOMRectReadOnly.fromRect({ x: ft, y: dt, width: Ce, height: pt })
          };
        });
        A.width = B.offsetWidth, A.height = B.offsetHeight;
        const lt = A.getContext("2d");
        a.track(ct, lt);
      }
    }, j = {
      width: "100%",
      height: "100%",
      position: "relative",
      // notice that we use z-index only once for the wrapper div.
      // If z-index is not defined, elements are stacked in the order they appear in the DOM.
      // The first element is at the very bottom and subsequent elements are added on top.
      "z-index": "0"
    }, U2 = {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: "0",
      left: "0"
    }, O2 = {
      width: "100%",
      height: "100%",
      "object-fit": "cover"
    }, z2 = computed(() => _.value ? O2 : {
      ...O2,
      visibility: "hidden",
      position: "absolute"
    });
    return (M, A) => (openBlock(), createElementBlock("div", { style: j }, [
      createBaseVNode("video", {
        ref_key: "videoRef",
        ref: h2,
        style: normalizeStyle(z2.value),
        autoplay: "",
        muted: "",
        playsinline: ""
      }, null, 4),
      withDirectives(createBaseVNode("canvas", {
        id: "qrcode-stream-pause-frame",
        ref_key: "pauseFrameRef",
        ref: c2,
        style: O2
      }, null, 512), [
        [vShow, !_.value]
      ]),
      createBaseVNode("canvas", {
        id: "qrcode-stream-tracking-layer",
        ref_key: "trackingLayerRef",
        ref: d2,
        style: U2
      }, null, 512),
      createBaseVNode("div", { style: U2 }, [
        renderSlot(M.$slots, "default")
      ])
    ]));
  }
}), xi = /* @__PURE__ */ defineComponent({
  __name: "QrcodeCapture",
  props: {
    formats: {
      type: Array,
      default: () => ["qr_code"]
    }
  },
  emits: ["detect"],
  setup(n, { emit: i }) {
    const a = n, c2 = (d2) => {
      if (!(!(d2.target instanceof HTMLInputElement) || !d2.target.files))
        for (const h2 of Array.from(d2.target.files))
          Ir(h2, a.formats).then((v) => {
            i("detect", v);
          });
    };
    return (d2, h2) => (openBlock(), createElementBlock("input", {
      onChange: c2,
      type: "file",
      name: "image",
      accept: "image/*",
      capture: "environment",
      multiple: ""
    }, null, 32));
  }
}), Ri = ["onDrop"], ki = /* @__PURE__ */ defineComponent({
  __name: "QrcodeDropZone",
  props: {
    formats: {
      type: Array,
      default: () => ["qr_code"]
    }
  },
  emits: ["detect", "dragover", "error"],
  setup(n, { emit: i }) {
    const a = n, c2 = async (v) => {
      try {
        const w = await v;
        i("detect", w);
      } catch (w) {
        i("error", w);
      }
    }, d2 = (v) => {
      i("dragover", v);
    }, h2 = ({ dataTransfer: v }) => {
      if (!v)
        return;
      d2(false);
      const w = [...Array.from(v.files)], C = v.getData("text/uri-list");
      w.forEach((y2) => {
        c2(Ir(y2));
      }), C !== "" && c2(Za(C, a.formats));
    };
    return (v, w) => (openBlock(), createElementBlock("div", {
      onDrop: withModifiers(h2, ["prevent", "stop"]),
      onDragenter: w[0] || (w[0] = withModifiers((C) => d2(true), ["prevent", "stop"])),
      onDragleave: w[1] || (w[1] = withModifiers((C) => d2(false), ["prevent", "stop"])),
      onDragover: w[2] || (w[2] = withModifiers(() => {
      }, ["prevent", "stop"]))
    }, [
      renderSlot(v.$slots, "default")
    ], 40, Ri));
  }
});
function Fi(n) {
  n.component("qrcode-stream", Di), n.component("qrcode-capture", xi), n.component("qrcode-drop-zone", ki);
}
const Ii = { install: Fi };
let it = null;
typeof window < "u" ? it = window.Vue : typeof global < "u" && (it = global.Vue);
it && it.use(Ii);
const Characters_vue_vue_type_style_index_0_lang = "";
const _sfc_main = {
  components: {
    QrcodeVue,
    QrcodeStream: Di,
    QrcodeDropZone: ki,
    QrcodeCapture: xi
  },
  setup() {
    const store = usePlayerStore();
    return { store };
  },
  data() {
    return {
      paused: false,
      type_action: null,
      characters: JSON.parse(localStorage.getItem("games_player")) ?? null,
      characters_string: localStorage.getItem("games_player") ?? null
    };
  },
  mounted() {
  },
  methods: {
    async onDetect(firstDetectedCode) {
      if (firstDetectedCode[0].rawValue !== void 0) {
        let parsed = JSON.parse(firstDetectedCode[0].rawValue);
        let result = [];
        if (parsed !== null && parsed.length) {
          parsed.forEach(function(character) {
            if (character.game_token !== void 0 && character.character_token !== void 0) {
              result.push({ "game_token": character.game_token, "character_token": character.character_token });
            }
          });
          alert(this.$t("count_char_import", { count: result.length }));
          localStorage.setItem("games_player", JSON.stringify(result));
          this.characters = JSON.parse(localStorage.getItem("games_player"));
          this.characters_string = localStorage.getItem("games_player");
          return;
        }
      }
      alert(this.$t("invalid_qr_code"));
      this.paused = true;
      await this.timeout(500);
      this.paused = false;
    },
    timeout(ms) {
      return new Promise((resolve2) => {
        window.setTimeout(resolve2, ms);
      });
    },
    deleteAllCharacters() {
      this.characters = null;
      localStorage.removeItem("games_player");
    }
  }
};
const _hoisted_1 = { class: "small-wrapper" };
const _hoisted_2 = {
  key: 2,
  id: "export"
};
const _hoisted_3 = { class: "qr-code" };
const _hoisted_4 = {
  key: 3,
  id: "import"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_qrcode_vue = resolveComponent("qrcode-vue");
  const _component_qrcode_stream = resolveComponent("qrcode-stream");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("h1", null, toDisplayString$1(_ctx.$t("character_manage")), 1),
    createBaseVNode("div", _hoisted_1, [
      createBaseVNode("div", null, toDisplayString$1(_ctx.$t("character_help")), 1),
      createBaseVNode("div", null, toDisplayString$1(_ctx.$t("character_nb", $data.characters !== null ? $data.characters.length : 0)), 1),
      $data.characters !== null ? (openBlock(), createElementBlock("button", {
        key: 0,
        onClick: _cache[0] || (_cache[0] = ($event) => $data.type_action = "export")
      }, toDisplayString$1(_ctx.$t("export_char")), 1)) : createCommentVNode("", true),
      createBaseVNode("button", {
        onClick: _cache[1] || (_cache[1] = ($event) => $data.type_action = "import")
      }, toDisplayString$1(_ctx.$t("import_char")), 1),
      $data.characters !== null ? (openBlock(), createElementBlock("button", {
        key: 1,
        class: "btn-danger",
        onClick: _cache[2] || (_cache[2] = (...args) => $options.deleteAllCharacters && $options.deleteAllCharacters(...args))
      }, toDisplayString$1(_ctx.$t("delete_all_chars")), 1)) : createCommentVNode("", true),
      $data.type_action === "export" ? (openBlock(), createElementBlock("div", _hoisted_2, [
        createBaseVNode("div", _hoisted_3, [
          createVNode(_component_qrcode_vue, {
            value: $data.characters_string,
            size: 200,
            level: "H"
          }, null, 8, ["value"])
        ])
      ])) : createCommentVNode("", true),
      $data.type_action === "import" ? (openBlock(), createElementBlock("div", _hoisted_4, [
        createVNode(_component_qrcode_stream, {
          paused: $data.paused,
          onDetect: $options.onDetect
        }, null, 8, ["paused", "onDetect"])
      ])) : createCommentVNode("", true)
    ])
  ], 64);
}
const Characters = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const router = createRouter({
  history: createWebHashHistory(),
  routes: [
    { path: "/", redirect: "/home" },
    { path: "/home", component: Home },
    { path: "/create", component: Create },
    { path: "/join", component: Join },
    { path: "/admin", component: Admin },
    { path: "/player", component: Player },
    { path: "/continue", component: Continue },
    { path: "/characters", component: Characters }
  ]
});
const i18n = createI18n({
  legacy: false,
  locale: Intl.DateTimeFormat().resolvedOptions().locale !== void 0 ? Intl.DateTimeFormat().resolvedOptions().locale.slice(0, 2) : "fr",
  fallbackLocale: "en",
  // fallback locale
  messages,
  warnHtmlMessage: false,
  warnHtmlInMessage: "off",
  globalInjection: true
});
const app = createApp(Main);
app.use(i18n);
app.use(createPinia());
app.use(router);
window.vm = app.mount("#app");
const usePlayerStore = defineStore("playerStore", {
  state: () => ({
    _user_peer: null,
    _player_connection: null,
    _current_game: null,
    _leaving: false,
    _temp_peer: null,
    _connections: {},
    _should_reconnect: -1,
    _reconnect_interval: null,
    _reconnect_timeout: null,
    _message: "",
    _temp_connections: [],
    _last_challenge: {
      date: 0,
      nb_bonus: 0,
      nb_malus: 0,
      nb_target: 0
    }
  }),
  getters: {
    peer: (state) => state._user_peer,
    connection: (state) => state._player_connection,
    connections: (state) => state._connections,
    should_reconnect: (state) => state._should_reconnect,
    current_game: (state) => state._current_game,
    characters: (state) => state._current_game.characters,
    alive_characters: (state) => state._current_game.characters.filter((character) => character.alive),
    picked_characters: (state) => state._current_game.characters.filter((character) => character.picked),
    tag_groups: (state) => state._current_game.tag_groups,
    tag_groups_plus_targets: function(state) {
      if (this.picked_characters.length) {
        let altered_group = [...state._current_game.tag_groups];
        altered_group.unshift({ code: "targets", label: i18n.global.t("selected"), tags: [{ code: "targets", label: i18n.global.t("selected") }] });
        return altered_group;
      } else {
        return state._current_game.tag_groups;
      }
    },
    stats: (state) => state._current_game.stats,
    gauges: (state) => state._current_game.gauges,
    leaving: (state) => state._leaving,
    temp_peer: (state) => state._temp_peer,
    temp_connections: (state) => state._temp_connections,
    message: (state) => state._message,
    last_challenge: (state) => state._last_challenge,
    tags(state) {
      let flatten_tags = [];
      if (state._current_game.tag_groups !== void 0) {
        state._current_game.tag_groups.forEach(function(tag_group) {
          flatten_tags = [...flatten_tags, ...tag_group.tags];
        });
      }
      return flatten_tags;
    },
    polls: (state) => state._current_game.polls,
    active_polls: (state) => state._current_game.polls !== void 0 ? Object.fromEntries(Object.entries(state._current_game.polls).filter((poll) => poll[1].active).sort(function(a, b) {
      return b[0] - a[0];
    })) : [],
    past_polls: (state) => state._current_game.polls !== void 0 ? Object.fromEntries(Object.entries(state._current_game.polls).filter((poll) => !poll[1].active).sort(function(a, b) {
      return b[0] - a[0];
    })) : []
  },
  actions: {
    connected_characters(alive = false) {
      const temp = this;
      return this.current_game.characters.filter(function(character) {
        return (alive ? character.alive : true) && character.connection !== null && temp.connections[character.connection] !== void 0 && temp.connections[character.connection].open;
      });
    },
    setMessage(value) {
      this._message = value;
      setTimeout(() => {
        this._message = "";
      }, 2e3);
    },
    setTempPeer(value) {
      this._temp_peer = value;
    },
    addTag: function(tag_label, group) {
      if (this.current_game.current_basic_color === void 0) {
        this.current_game.current_basic_color = 0;
        this.current_game.basic_color = 0;
      }
      this.current_game.current_basic_color += 40;
      if (this.current_game.current_basic_color > 360) {
        this.current_game.basic_color += 15;
        this.current_game.current_basic_color = this.current_game.basic_color;
      }
      let code2;
      do {
        code2 = tag_label.substring(0, 2) + Math.floor(Math.random() * 1e7);
      } while (this.tags.findIndex((tag2) => tag2.code === code2) !== -1);
      const tag = {
        label: tag_label,
        code: code2,
        color: [this.current_game.current_basic_color, 100, 40 + Math.floor(Math.random() * 40)],
        group: group.code
      };
      group.tags.push(tag);
      group.picking_array.push(tag.code);
      this.generateCss();
      return tag;
    },
    addGroupTag(freetag = false) {
      let group = {
        tags: [],
        picking_array: [],
        label: freetag ? i18n.global.t("other_tags") : i18n.global.t("group_nb", { nb: this.tag_groups.length + 1 })
      };
      group.code = freetag ? "freetag" : Math.floor(Math.random() * 1e7);
      group.start = freetag ? "none" : "random";
      this.tag_groups.push(group);
      return group;
    },
    generateCss() {
      let game_css = document.getElementById("game_css");
      let css_str = "";
      this.tags.forEach((tag) => css_str += ".tag-" + tag.code + " .label-name:before { background-color:hsl(" + tag.color[0] + "," + tag.color[1] + "%," + tag.color[2] + "%) !important} ");
      game_css.innerHTML = css_str;
    },
    getGroupTags() {
      return this.tag_groups;
    },
    getStartGroupTags() {
      return this.tag_groups.filter((group) => group.start === "start" && group.tags.length > 0);
    },
    getRandomGroupTags() {
      return this.tag_groups.filter((group) => (group.start === "random" || group.start === "equitable") && group.tags.length > 0);
    },
    getTagFromCode(code2) {
      return this.tags.find((tag) => tag.code === code2);
    },
    setShouldReconnect(value) {
      this._should_reconnect = value;
    },
    disconnectAll() {
      console.log("Minotaure : send gracefully disconnect to all connections");
      Object.values(this.connections).forEach(function(connection) {
        if (connection !== null) {
          connection.send({ handshake: "disconnectGracefully" });
          connection.close();
        }
      });
      this.peer.disconnect();
      this.peer.destroy();
    },
    setPeer(peer) {
      this._user_peer = peer;
    },
    setConnection(conn) {
      this._player_connection = conn;
    },
    setCurrentGame(game) {
      this._current_game = game;
    },
    addCharacter(new_character) {
      this.characters.push(new_character);
    },
    characterWatch(new_character) {
      let vm = this;
      for (const [key, gauge] of Object.entries(new_character.gauges)) {
        if (vm.gauges[key] !== void 0 && vm.gauges[key].deadly && gauge.value <= 0) {
          new_character.gauges[key].value = 0;
          new_character.alive = false;
        }
      }
      if (new_character.connection !== void 0 && new_character.connection != null) {
        if (vm.connections[new_character.connection] !== void 0 && vm.connections[new_character.connection].open) {
          vm.connections[new_character.connection].send({
            handshake: "displayCharacter",
            game_token: vm.current_game.id,
            character: vm.prepareCharacter(new_character)
          });
        }
      }
    },
    retrieveCharacter(token) {
      if (this.current_game.characters.length === void 0) {
        return null;
      } else {
        return this.current_game.characters.find((element2) => element2.token === token);
      }
    },
    generateCharacter(data2 = null, conn = null) {
      const vm = this;
      let token = Math.random() + Math.random();
      let tags = [];
      let ranking_stat = [];
      if (data2 != null) {
        data2.choices.forEach(function(code2) {
          let found_tag = vm.getTagFromCode(code2);
          if (found_tag) {
            tags.push(found_tag);
          }
        });
      }
      if (data2 === null) {
        this.getStartGroupTags().forEach(function(group) {
          tags.push(vm.getRandomTagFromGroup(group));
        });
      }
      this.getRandomGroupTags().forEach(function(group) {
        tags.push(vm.getRandomTagFromGroup(group));
      });
      let character = {
        game_name: this.current_game.name,
        token,
        name: data2 != null ? data2.name : "Perso " + Math.floor(Math.random() * Math.random() * 1e5),
        pseudo: data2 != null ? data2.pseudo : null,
        stats: {},
        gauges: {},
        alive: true,
        challenge: {},
        polls: {},
        picked: false,
        connection: conn != null ? conn : false,
        watched: false
      };
      let dice_rolls = [];
      let pool_max = 9;
      for (let i = 0; i < Object.keys(this.stats).length; ++i) {
        if (i === 0) {
          let roll = Math.floor(Math.random() * pool_max);
          pool_max = -roll;
          dice_rolls.push(10 + roll);
        } else if (i < Object.keys(this.stats).length - 1) {
          let roll = Math.floor(Math.random() * pool_max);
          pool_max = pool_max - roll;
          dice_rolls.push(10 + roll);
        } else {
          dice_rolls.push(10 + pool_max);
        }
      }
      tags.forEach(function(tag) {
        if (tag.stat1 && ranking_stat[0] === void 0) {
          ranking_stat[0] = tag.stat1;
        }
        if (tag.stat2 && ranking_stat[1] === void 0) {
          ranking_stat[1] = tag.stat2;
        }
      });
      dice_rolls.sort(function(a, b) {
        return a - b;
      });
      let max_rolls = [];
      if (ranking_stat[0] !== void 0) {
        max_rolls.push(dice_rolls.pop());
      }
      if (ranking_stat[1] !== void 0) {
        max_rolls.push(dice_rolls.pop());
      }
      for (const [key, stat] of Object.entries(this.stats)) {
        let die_choice;
        if (max_rolls[0] !== void 0 && ranking_stat[0] === key) {
          die_choice = max_rolls[0];
        } else if (max_rolls[1] !== void 0 && ranking_stat[1] === key) {
          die_choice = max_rolls[1];
        } else {
          let choice = Math.floor(dice_rolls.length * Math.random());
          die_choice = dice_rolls.splice(choice, 1)[0];
        }
        character.stats[key] = { label: stat.name, value: die_choice };
      }
      for (const [key, gauge] of Object.entries(this.gauges)) {
        character.gauges[key] = { label: gauge.name, value: gauge.value };
      }
      tags.forEach(function(tag) {
        if (tag.stat_modifiers !== void 0) {
          for (const [key, stat] of Object.entries(tag.stat_modifiers)) {
            if (character.stats[key] !== void 0) {
              character.stats[key].value += stat.value;
              if (character.stats[key].value <= 0) {
                character.stats[key].value = 1;
              }
            }
          }
        }
        if (tag.gauge_modifiers !== void 0) {
          for (const [key, gauge] of Object.entries(tag.gauge_modifiers)) {
            if (character.gauges[key] !== void 0) {
              character.gauges[key].value += gauge.value;
              if (character.gauges[key].value <= 0) {
                character.gauges[key].value = 1;
              }
            }
          }
        }
      });
      character.tags = tags;
      this.addCharacter(character);
      return character;
    },
    generateCharacters(nb) {
      for (let i = 0; i < nb; i++) {
        let character = this.generateCharacter();
        let retrieved_character = this.retrieveCharacter(character.token);
        if (!retrieved_character.watched) {
          retrieved_character.watched = true;
          watch(retrieved_character, this.characterWatch);
        }
      }
    },
    prepareCharacter(character) {
      return character;
    },
    filterCharacterByTags(character, chosen_tags) {
      return character.tags.find(
        (tag) => chosen_tags.find((chosen_tag) => chosen_tag.code === tag.code)
      );
    },
    filterCharacterByTagsAndPicked(character, chosen_tags) {
      let is_picked = false;
      if (chosen_tags.findIndex((tag) => tag.code === "targets") > -1) {
        is_picked = character.picked !== void 0 && character.picked;
      }
      if (!is_picked) {
        return character.tags.find(
          (tag) => chosen_tags.find((chosen_tag) => chosen_tag.code === tag.code)
        );
      } else {
        return true;
      }
    },
    getRandomTagFromGroup(group) {
      let random_number = Math.floor(Math.random() * group.picking_array.length);
      let choice_index;
      if (group.start === "equitable") {
        if (group.picking_array.length === 0) {
          group.tags.forEach(function(tag) {
            for (let i = 0; i < (tag.probability ?? 1); i++) {
              group.picking_array.push(tag.code);
            }
          });
        }
        choice_index = group.picking_array.splice(random_number, 1)[0];
      } else {
        if (group.picking_array.length < group.tags.length) {
          group.picking_array = [];
          group.tags.forEach(function(tag) {
            for (let i = 0; i < (tag.probability ?? 1); i++) {
              group.picking_array.push(tag.code);
            }
          });
        }
        choice_index = group.picking_array[random_number];
      }
      return group.tags.find((tag) => tag.code === choice_index);
    },
    removeTagFromAll(deleted_tag) {
      this.characters.forEach(function(character) {
        let foundIndex = character.tags.findIndex(function(tag) {
          if (tag.code === deleted_tag.code) {
            return true;
          }
        });
        if (foundIndex > -1) {
          character.tags.splice(foundIndex, 1);
        }
      });
    },
    pollAddAnswer(code2, answer) {
      if (this.polls[code2] !== void 0 && this.polls[code2].options[answer] !== void 0 && this.polls[code2].active) {
        this.polls[code2].options[answer].count += 1;
      }
    },
    saveQuit() {
      let games = localStorage.getItem("games");
      if (games !== void 0) {
        games = JSON.parse(games);
        let found = games.findIndex((element2) => element2.id === this._current_game.id);
        if (found > -1) {
          games[found] = this._current_game;
        }
      } else {
        games = {};
        games.push(this._current_game);
      }
      localStorage.setItem("games", JSON.stringify(games));
    },
    join(id, set_temp_peer = false) {
      this.setShouldReconnect(0);
      let vm = this;
      let peer_client;
      let attempting_reconnect = false;
      let join_id = Math.floor(Math.random() * 1e7 + 1);
      peer_client = new $416260bce337df90$export$ecd1fc136c422448(join_id);
      localStorage.setItem("gm_id", id);
      peer_client.on("open", function() {
        let conn = peer_client.connect(id);
        vm.stopReconnect();
        conn.on("open", function() {
          console.log("Minotaure : connection opened");
          vm.setShouldReconnect(0);
          vm.setPeer(peer_client);
          vm.setConnection(conn);
          if (set_temp_peer) {
            vm.setTempPeer(true);
          }
          router.push("/player");
        });
        conn.on("error", function(err) {
          console.log("Minotaure : error - " + err.type + " " + err.message);
        });
      });
      peer_client.once("disconnected", function() {
        vm.stopReconnect();
        console.log("Minotaure : peer client disconnected");
        if (vm.should_reconnect === -1) {
          console.log("Minotaure : Disconnected but should not reconnect");
          peer_client.destroy();
        } else if (vm.should_reconnect === 0) {
          vm.setMessage("Minotaure - starting attempts to reconnect after disconnect");
          attempting_reconnect = true;
          let interval = setInterval(
            function() {
              if (vm.should_reconnect === -1) {
                console.log("Minotaure : Disconnected but should not reconnect");
                peer_client.destroy();
                attempting_reconnect = false;
              } else {
                if (peer_client.open === true) {
                  console.log("Minotaure : reconnection attempt successful :) !");
                  router.push("/player");
                  attempting_reconnect = false;
                } else if (peer_client.destroyed === true) {
                  console.log("Minotaure : reconnection attempt unsuccessful :( !");
                  attempting_reconnect = false;
                } else if (vm.should_reconnect < 10) {
                  vm.setShouldReconnect(vm.should_reconnect + 1);
                  console.log("Minotaure : reconnection attempt number " + vm.should_reconnect);
                  peer_client.reconnect();
                } else if (router.currentRoute.value.path === "/player") {
                  router.push("/join");
                  vm.setMessage("Dconnexion imprvue");
                  attempting_reconnect = false;
                }
                if (!attempting_reconnect) {
                  clearInterval(interval);
                  vm.setShouldReconnect(0);
                }
              }
            },
            3e3
          );
        }
      });
      peer_client.on("error", function(err) {
        console.log("Minotaure : peer received error - " + err.type);
        if (err.type === "peer-unavailable") {
          if (this.should_reconnect > 0) {
            if (router.currentRoute.value.path === "/player") {
              router.push("/join");
              vm.setMessage("MJ dconnect");
            } else {
              vm.setMessage("MJ indisponible");
            }
          } else {
            vm.setMessage("MJ indisponible");
          }
        }
      });
    },
    setPickedCharacters(picked_characters) {
      picked_characters.forEach((character) => character.picked = true);
    },
    resetPickedCharacters() {
      this.characters.map(function(character) {
        if (character.picked) {
          character.picked = false;
        }
      });
    },
    getRandom(arr, n) {
      let result = new Array(n);
      let len = arr.length;
      let taken = new Array(len);
      if (n > len) {
        n = len;
      }
      while (n--) {
        var x = Math.floor(Math.random() * len);
        result[n] = arr[x in taken ? taken[x] : x];
        taken[x] = --len in taken ? taken[len] : len;
      }
      return result;
    },
    // Reconnects the player after the connection closed, in 1s if possible, or repeat until 10s.
    startReconnect() {
      const vm = this;
      vm.setMessage("Minotaure - starting attempts to reconnect after connection closed.");
      this._reconnect_timeout = setTimeout(function() {
        console.log("Minotaure : reconnection attempts unsuccessful");
        vm.stopReconnect();
      }, 1e4);
      this._reconnect_interval = setInterval(function() {
        console.log("Minotaure : trying to reconnect after connection closed");
        vm.join(vm.connection.peer, true);
      }, 2e3);
    },
    // Interrupts reconnection attempts after connection closed (it's not related to peer disconnection).
    stopReconnect() {
      clearInterval(this._reconnect_interval);
      clearInterval(this._reconnect_timeout);
    }
  }
});
router.beforeEach((to, from, next) => {
  const store = usePlayerStore();
  if (to.path === "/admin") {
    document.getElementsByClassName("main-wrapper")[0].classList.add("wide");
  }
  if (from.path === "/player" && to !== from && to.path !== "/join") {
    if (window.confirm("Si vous quittez cet onglet, votre connexion au MJ sera interrompue mais vous pourrez revenir dans la partie.")) {
      store._leaving = true;
      if (store.connection !== null) {
        store.connection.close();
      }
      next();
    }
    next(false);
    return "";
  } else if (from.path === "/admin" && to !== from) {
    if (store.current_game !== null) {
      if (window.confirm("Si vous quittez cet onglet, la partie sera interrompue aprs avoir t sauvegarde. Souhaitez-vous vraiment quitter ?")) {
        localStorage.removeItem("temp_game");
        store.disconnectAll();
        store.saveQuit();
        document.getElementsByClassName("main-wrapper")[0].classList.remove("wide");
        next();
      }
    } else {
      localStorage.removeItem("temp_game");
      next();
    }
    next(false);
    return "";
  }
  next();
});

</script>
      <style>
@charset "UTF-8";@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");@import url("https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap");.slider-target,.slider-target *{-webkit-touch-callout:none;-webkit-tap-highlight-color:rgba(0,0,0,0);box-sizing:border-box;touch-action:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.slider-target{position:relative}.slider-base,.slider-connects{height:100%;position:relative;width:100%;z-index:1}.slider-connects{overflow:hidden;z-index:0}.slider-connect,.slider-origin{height:100%;position:absolute;right:0;top:0;-ms-transform-origin:0 0;-webkit-transform-origin:0 0;transform-origin:0 0;-webkit-transform-style:preserve-3d;transform-style:flat;width:100%;will-change:transform;z-index:1}.slider-txt-dir-rtl.slider-horizontal .slider-origin{left:0;right:auto}.slider-vertical .slider-origin{top:-100%;width:0}.slider-horizontal .slider-origin{height:0}.slider-handle{-webkit-backface-visibility:hidden;backface-visibility:hidden;position:absolute}.slider-touch-area{height:100%;width:100%}.slider-state-tap .slider-connect,.slider-state-tap .slider-origin{transition:transform .3s}.slider-state-drag *{cursor:inherit!important}.slider-tooltip-drag .slider-tooltip,.slider-tooltip-focus .slider-tooltip{display:none!important}.slider-tooltip-drag .slider-active .slider-tooltip,.slider-tooltip-drag.slider-state-drag .slider-tooltip:not(.slider-tooltip-hidden),.slider-tooltip-focus.slider-focused .slider-tooltip:not(.slider-tooltip-hidden){display:block!important}.slider-horizontal{height:var(--slider-height,6px)}.slider-horizontal .slider-handle{height:var(--slider-handle-height,16px);right:calc(var(--slider-handle-width, 16px)/2*-1);top:calc((var(--slider-handle-height, 16px) - var(--slider-height, 6px))/2*-1 + -1px);width:var(--slider-handle-width,16px)}.slider-vertical{height:var(--slider-vertical-height,300px);width:var(--slider-height,6px)}.slider-vertical .slider-handle{bottom:calc(var(--slider-handle-width, 16px)/2*-1);height:var(--slider-handle-width,16px);right:calc((var(--slider-handle-height, 16px) - var(--slider-height, 6px))/2*-1 + -1px);width:var(--slider-handle-height,16px)}.slider-txt-dir-rtl.slider-horizontal .slider-handle{left:calc(var(--slider-handle-width, 16px)/2*-1);right:auto}.slider-base{background-color:var(--slider-bg,#d1d5db)}.slider-base,.slider-connects{border-radius:var(--slider-radius,9999px)}.slider-connect{background:var(--slider-connect-bg,#10b981);cursor:pointer}.slider-draggable{cursor:ew-resize}.slider-vertical .slider-draggable{cursor:ns-resize}.slider-handle{background:var(--slider-handle-bg,#fff);border:var(--slider-handle-border,0);border-radius:var(--slider-handle-radius,9999px);box-shadow:var(--slider-handle-shadow,.5px .5px 2px 1px rgba(0,0,0,.32));cursor:-webkit-grab;cursor:grab;height:var(--slider-handle-height,16px);width:var(--slider-handle-width,16px)}.slider-handle:focus{box-shadow:0 0 0 var(--slider-handle-ring-width,3px) var(--slider-handle-ring-color,rgba(16,185,129,.188)),var(--slider-handle-shadow,.5px .5px 2px 1px rgba(0,0,0,.32));outline:none}.slider-active{box-shadow:var(--slider-handle-shadow-active,.5px .5px 2px 1px rgba(0,0,0,.42));cursor:-webkit-grabbing;cursor:grabbing}[disabled] .slider-connect{background:var(--slider-connect-bg-disabled,#9ca3af)}[disabled] .slider-handle,[disabled].slider-handle,[disabled].slider-target{cursor:not-allowed}[disabled] .slider-tooltip{background:var(--slider-tooltip-bg-disabled,#9ca3af);border-color:var(--slider-tooltip-bg-disabled,#9ca3af)}.slider-tooltip{background:var(--slider-tooltip-bg,#10b981);border:1px solid var(--slider-tooltip-bg,#10b981);border-radius:var(--slider-tooltip-radius,5px);color:var(--slider-tooltip-color,#fff);display:block;font-size:var(--slider-tooltip-font-size,.875rem);font-weight:var(--slider-tooltip-font-weight,600);line-height:var(--slider-tooltip-line-height,1.25rem);min-width:var(--slider-tooltip-min-width,20px);padding:var(--slider-tooltip-py,2px) var(--slider-tooltip-px,6px);position:absolute;text-align:center;white-space:nowrap}.slider-horizontal .slider-tooltip-top{bottom:calc(var(--slider-handle-height, 16px) + var(--slider-tooltip-arrow-size, 5px) + var(--slider-tooltip-distance, 3px));left:50%;transform:translate(-50%)}.slider-horizontal .slider-tooltip-top:before{border:var(--slider-tooltip-arrow-size,5px) solid transparent;border-top-color:inherit;bottom:calc(var(--slider-tooltip-arrow-size, 5px)*-2);content:"";height:0;left:50%;position:absolute;transform:translate(-50%);width:0}.slider-horizontal .slider-tooltip-bottom{left:50%;top:calc(var(--slider-handle-height, 16px) + var(--slider-tooltip-arrow-size, 5px) + var(--slider-tooltip-distance, 3px));transform:translate(-50%)}.slider-horizontal .slider-tooltip-bottom:before{border:var(--slider-tooltip-arrow-size,5px) solid transparent;border-bottom-color:inherit;content:"";height:0;left:50%;position:absolute;top:calc(var(--slider-tooltip-arrow-size, 5px)*-2);transform:translate(-50%);width:0}.slider-vertical .slider-tooltip-left{right:calc(var(--slider-handle-height, 16px) + var(--slider-tooltip-arrow-size, 5px) + var(--slider-tooltip-distance, 3px));top:50%;transform:translateY(-50%)}.slider-vertical .slider-tooltip-left:before{border:var(--slider-tooltip-arrow-size,5px) solid transparent;border-left-color:inherit;content:"";height:0;position:absolute;right:calc(var(--slider-tooltip-arrow-size, 5px)*-2);top:50%;transform:translateY(-50%);width:0}.slider-vertical .slider-tooltip-right{left:calc(var(--slider-handle-height, 16px) + var(--slider-tooltip-arrow-size, 5px) + var(--slider-tooltip-distance, 3px));top:50%;transform:translateY(-50%)}.slider-vertical .slider-tooltip-right:before{border:var(--slider-tooltip-arrow-size,5px) solid transparent;border-right-color:inherit;content:"";height:0;left:calc(var(--slider-tooltip-arrow-size, 5px)*-2);position:absolute;top:50%;transform:translateY(-50%);width:0}.slider-horizontal .slider-origin>.slider-tooltip{left:auto;transform:translate(50%)}.slider-horizontal .slider-origin>.slider-tooltip-top{bottom:calc(var(--slider-tooltip-arrow-size, 5px) + (var(--slider-handle-height, 16px) - var(--slider-height, 6px))/2 + var(--slider-tooltip-distance, 3px) + 1px)}.slider-horizontal .slider-origin>.slider-tooltip-bottom{top:calc(var(--slider-tooltip-arrow-size, 5px) + (var(--slider-handle-height, 16px) - var(--slider-height, 6px))/2 + var(--slider-tooltip-distance, 3px) + var(--slider-height, 6px) - 1px)}.slider-vertical .slider-origin>.slider-tooltip{top:auto;transform:translateY(calc((var(--slider-tooltip-line-height, 1.25rem) - var(--slider-tooltip-py, 2px))*-1 + 1px))}.slider-vertical .slider-origin>.slider-tooltip-left{right:calc(var(--slider-tooltip-arrow-size, 5px) + var(--slider-height, 6px) + (var(--slider-handle-height, 16px) - var(--slider-height, 6px))/2 + var(--slider-tooltip-distance, 3px) - 1px)}.slider-vertical .slider-origin>.slider-tooltip-right{left:calc(var(--slider-tooltip-arrow-size, 5px) + var(--slider-height, 6px) + (var(--slider-handle-height, 16px) - var(--slider-height, 6px))/2 + var(--slider-tooltip-distance, 3px) - var(--slider-height, 6px) + 1px)}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}

[data-theme=dark].picker {
  background: black;
}

[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}

[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}

@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,d09GRgABAAAAAAtUAAsAAAAACwgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIF9GNtYXAAAAFoAAAAVAAAAFQXVtKNZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAABygAAAcoghgYQmhlYWQAAAjsAAAANgAAADYmCLzRaGhlYQAACSQAAAAkAAAAJAfTA+FobXR4AAAJSAAAACwAAAAsIh0AAGxvY2EAAAl0AAAAGAAAABgGLAfgbWF4cAAACYwAAAAgAAAAIAAQAIFuYW1lAAAJrAAAAYYAAAGGmUoJ+3Bvc3QAAAs0AAAAIAAAACAAAwAAAAMDxAGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QYDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkG//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAA/8AAAAPAAAIAADc5AQAAAAABAAD/wAAAA8AAAgAANzkBAAAAAAEAAP/AAAADwAACAAA3OQEAAAAAAwAA/8AEAAPAABsANwA6AAABIgcOAQcGFRQXHgEXFjMyNz4BNzY1NCcuAScmAyInLgEnJjU0Nz4BNzYzMhceARcWFRQHDgEHBgMRJQIAal1eiygoKCiLXl1qal1eiygoKCiLXl1qY1hXgiYmJiaCV1hjY1hXgiYmJiaCV1jnAY0DwCgoi15dampdXosoKCgoi15dampdXosoKPwgJiaCV1hjY1hXgiYmJiaCV1hjY1hXgiYmAsX+NeYAAAAEAAD/wAQAA8AAHQA8AF0AYgAABSInLgEnJjU0Nz4BNzYzMhceARcWFTEUBw4BBwYjESIHDgEHBhUUFx4BFxYzMjc+ATc2NTE0Jy4BJyYjMRMjNTMyNjU0JiMiBhUxIzQ3PgE3NjMyFx4BFxYVFAYHIwczFSM1AgBqXV6LKCgoKIteXWpqXV6LKCgoKYtdXWpYTk50ISIiIXROTlhYTk50ISIiInNOTlgrVis1S0s1NUtVEBE6JycsLCcnOhEQYEkBVlZWQCgoi15dampdXosoKCgoi15dampdXYspKAOrIiF0Tk5YWE5OdCEiIiF0Tk5YWE5OcyIi/aqrSzU1S0s1LCcnOhEQEBE6JycsTXUPr1VVAAACAAD/wAPbA8AAHAA9AAABMSYnJiIHBgcGBwYUFxYXFhcWMjc2NzY3NjQnJgMyFhUUBisBFRQGIyImPQEjIiY1NDY7ATU0NjMyFh0BMwNqS15fxF9eS0smJSUmS0teX8RfXktLJiUlJqkMEREM7xEMDBHvDBERDO8RDAwR7wMqSyYlJSZLS15fxF9eS0smJSUmS0teX8RfXv7+EQwMEe8MEREM7xEMDBHvDBERDO8AAAEAAP/ABBEDwABkAAABIgcOAQcGFRQXHgEXFhcWNjU0JjUGJjEuATEmNjEeATEWNjc+ATcmJy4BJyY1NDY3LgE3MBYXPgEzMTIWFz4BMRYGBx4BFRQHDgEHBgceARUUBhUUFjc2Nz4BNzY1NicuAScmIwIJbF9fjSkpGxpfQUJNFBABbUISKCQnKCkjXhYEEgsrKypDFRUdGAMNFkRLHUIjIUIfS0UVDAQZHBUURCsqLA4WARATTkFBXxsaASkpjV9fbAPAKSmPX2BtV09PgjAxGgQTCgk4IRhWLh8YCAMzPAYKGiMKBA0NOTAwTCtGHAlMNgMzCAkJCDMDNkwJHEYrTDAwOQ0MBQ0vJjRPDQoTBBoxMIJPT1dtYF+PKSkAAAMAAP/ABAADwAAbAB8AVAAAASIHDgEHBhUUFx4BFxYzMjc+ATc2NTQnLgEnJgcFISUBMRQGIyEiJjURNDY1BTgBMxQyMR4BFzAyMTIWMzE4ATEyNjMwMjE+ATcwMjUyMDElFBYVEQIAal1eiygoKCiLXl1qal1eiygoKCiLXl1qAS/9ogEvATMgF/4IFyABASIBAQEEAQECAwICAwIBAQQBAQEBIgEDwCgoi15dampdXosoKCgoi15dampdXosoKLS9vf4WFyAgFwEhAwQDtQEBAQEBAQEBAQG1AwQD/t8AAgAA/8AEAAPAAGEAfgAAATEmIg8BLgEnNTQmKwEiBh0BDgEHJyYiDwEGFB8BDgEHIyIGHQEUFjsBHgEXBwYUHwEWMj8BHgEXFRQWOwEyNj0BPgE3FxYyPwE2NC8BPgE3MzI2PQE0JisBLgEnNzY0LwEFMhceARcWFRQHDgEHBiMiJy4BJyY1NDc+ATc2MwNPDykPNhYwGR0VaBQeGjEXOw4pD0kPDzYOFghTFR0dFUwGEww7Dw9JDykPNhYwGR0VaBQeGjEXOw4qDkoODjcOFghTFR0dFUwGEww7Dw9J/rEqJiU3EBAQEDclJioqJiU3EBAQEDclJioDRQ8PNg4WCFMVHR0VTAYTDDsPD0kPKQ82FjAZHRVoFB4aMRY8DikPSQ8PNg4WCFMVHR0VTAYTDDsPD0kPKQ82FjAZHRVoFB4aMRc7DikPSbkQEDclJioqJiU3EBAQEDclJioqJiU3EBAAAAAEAAD/wAQIA8AADwA/AE8AVAAAAS4BIyIGDwEXNz4BNTQmJyUhFSEiBgcOARURFBYXHgEzITI2Nz4BNREzERQGBw4BIyEiJicuATURNDY3PgEzMQEOAQcOAQcOAQcGNj8CFycBFwEnA4kHDQgIDgU9qz0GBQYG/EoBpv6OAgUCAQMDAQIFAgLhAgUCAgJtCwkKGQ/8tw8ZCQoLCwoJGg4CAxEjEBEiESgtBQQFCisDqWoBCKv+9agDtQYFBgY/pkEFDwcIDgZObQICAgUC/R8CBQICAgICAgUCAWP+aQ4aCQoLCwoJGg4DSQ8ZCgkL/bUGCwUGCwYNDgECJiajBKjpARKl/uuoAAABAAAAAQAADjBhvV8PPPUACwQAAAAAAOFsPCoAAAAA4Ww8KgAA/8AEEQPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQVAAAAAAQRAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAAAEAAAABAAAAAQVAAAEAAAABAAAAAQIAAAAAAAAAAoAFAAeAHwBBgFeAe4CXgMQA5QAAQAAAAsAfwAEAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGljb21vb24AaQBjAG8AbQBvAG8AblZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGljb21vb24AaQBjAG8AbQBvAG8Abmljb21vb24AaQBjAG8AbQBvAG8AblJlZ3VsYXIAUgBlAGcAdQBsAGEAcmljb21vb24AaQBjAG8AbQBvAG8AbkZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
[class^=icon-]:before, [class*=" icon-"]:before {
  /* use !important to prevent issues with browser extensions that change fonts */
  font-family: "icomoon" !important;
  speak: never;
  font-style: normal;
  font-weight: normal;
  font-variant: normal;
  text-transform: none;
  line-height: 1;
  font-size: 1.5em;
  /* Better Font Rendering =========== */
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

button[class^=icon-] {
  display: flex;
  align-content: center;
  gap: 10px;
}

.icon-add:before {
  content: "\e902";
}

.icon-play:before {
  content: "\e900";
}

.icon-email:before {
  content: "\e904";
}

.icon-settings:before {
  content: "\e905";
}

.icon-edit:before {
  content: "\e906";
}

.icon-question:before {
  content: "\e901";
}

body {
  margin: 0;
  display: flex;
  min-width: 320px;
  min-height: 100vh;
  font-family: var(--main-font);
  color: var(--font-color);
  background: var(--background-color);
}

#app {
  display: flex;
  width: 100%;
  margin: 0 auto;
  text-align: center;
  justify-content: stretch;
  align-items: stretch;
  position: relative;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}
@media (max-width: 767px) {
  h1 {
    font-size: 2.2em;
  }
}

a {
  color: var(--link-color);
  text-decoration: inherit;
}

button {
  background-color: #2b2a33;
  color: var(--button-color);
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:disabled {
  color: darkgrey;
}

button:hover {
  border-color: #646cff;
}

button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

.menu-wrapper input[type=text] {
  min-height: 40px;
}

input[type=text]:not(.multiselect__input), select {
  background: white;
  color: black;
  border-radius: 8px;
  border: var(--border-input);
  font-size: 1em;
}

.picker {
  cursor: pointer;
}

.vertical-wrapper {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.small-wrapper {
  min-width: 300px;
  max-width: 800px;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
}
@media (max-width: 465px) {
  .tabs .tab,
  .tabs label {
    order: initial;
  }
  .tabs label {
    width: 100%;
    margin-left: 50px;
  }
}
.btn-important {
  background: darkseagreen;
  order: 1;
}

.wrapper-label {
  display: flex;
  flex-direction: column;
}

.full {
  flex-basis: 100%;
}

@media (max-width: 767px) {
  .hidden-mobile {
    display: none !important;
  }
  .hidden-mobile.active {
    display: flex !important;
  }
}
@media (min-width: 769px) {
  .visible-mobile {
    display: none !important;
  }
}
.description {
  font-size: 0.8em;
}

input, select {
  border: none;
}

button.btn-valid:not(:disabled) {
  background-color: var(--valid-color) !important;
  border: 1px solid var(--valid-color);
}
button.btn-valid:not(:disabled):hover {
  border-color: var(--border-color);
}

button.btn-danger {
  background-color: var(--danger-color) !important;
}

.danger {
  color: var(--danger-color);
}

.shepherd-target {
  border: 1px solid var(--success-background);
}

  fieldset[disabled] .multiselect {
    pointer-events: none;
  }

  .multiselect__spinner {
    position: absolute;
    right: 1px;
    top: 1px;
  width: 40px;
  height: 38px;
    background: #fff;
    display: block;
  }

  .multiselect__spinner::before,
  .multiselect__spinner::after {
    position: absolute;
    content: "";
    top: 50%;
    left: 50%;
    margin: -8px 0 0 -8px;
    width: 16px;
    height: 16px;
    border-radius: 100%;
    border-color: #41b883 transparent transparent;
    border-style: solid;
    border-width: 2px;
    box-shadow: 0 0 0 1px transparent;
  }

  .multiselect__spinner::before {
    animation: spinning 2.4s cubic-bezier(0.41, 0.26, 0.2, 0.62);
    animation-iteration-count: infinite;
  }

  .multiselect__spinner::after {
    animation: spinning 2.4s cubic-bezier(0.51, 0.09, 0.21, 0.8);
    animation-iteration-count: infinite;
  }

  .multiselect__loading-enter-active,
  .multiselect__loading-leave-active {
    transition: opacity 0.4s ease-in-out;
    opacity: 1;
  }

  .multiselect__loading-enter,
  .multiselect__loading-leave-active {
    opacity: 0;
  }

  .multiselect,
  .multiselect__input,
  .multiselect__single {
    font-family: inherit;
    font-size: 16px;
    touch-action: manipulation;
  }

  .multiselect {
    box-sizing: content-box;
    display: block;
    position: relative;
    width: 100%;
    min-height: 40px;
    text-align: left;
    color: #35495e;
  }

  .multiselect * {
    box-sizing: border-box;
  }

  .multiselect:focus {
    outline: none;
  }

  .multiselect--disabled {
    background: #ededed;
    pointer-events: none;
    opacity: 0.6;
  }

  .multiselect--active {
    z-index: 50;
  }

  .multiselect--active:not(.multiselect--above) .multiselect__current,
  .multiselect--active:not(.multiselect--above) .multiselect__input,
  .multiselect--active:not(.multiselect--above) .multiselect__tags {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }

  .multiselect--active .multiselect__select {
    transform: rotateZ(180deg);
  }

  .multiselect--above.multiselect--active .multiselect__current,
  .multiselect--above.multiselect--active .multiselect__input,
  .multiselect--above.multiselect--active .multiselect__tags {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
  }

  .multiselect__input,
  .multiselect__single {
    position: relative;
    display: inline-block;
    min-height: 20px;
    line-height: 20px;
    border: none;
    border-radius: 5px;
    background: #fff;
    padding: 0 0 0 5px;
    width: calc(100%);
    transition: border 0.1s ease;
    box-sizing: border-box;
    margin-bottom: 8px;
    vertical-align: top;
  }

  .multiselect__input::placeholder {
    color: #35495e;
  }

  .multiselect__tag ~ .multiselect__input,
  .multiselect__tag ~ .multiselect__single {
    width: auto;
  }

  .multiselect__input:hover,
  .multiselect__single:hover {
    border-color: #cfcfcf;
  }

  .multiselect__input:focus,
  .multiselect__single:focus {
    border-color: #a8a8a8;
    outline: none;
  }

  .multiselect__single {
    padding-left: 5px;
    margin-bottom: 8px;
  }

  .multiselect__tags-wrap {
    display: inline;
  }

  .multiselect__tags {
    min-height: 40px;
    display: block;
    padding: 8px 40px 0 8px;
    border-radius: 5px;
    border: 1px solid #e8e8e8;
    background: #fff;
    font-size: 14px;
  }

  .multiselect__tag {
    position: relative;
    display: inline-block;
    padding: 4px 26px 4px 10px;
    border-radius: 5px;
    margin-right: 10px;
    color: #fff;
    line-height: 1;
    background: #41b883;
    margin-bottom: 5px;
    white-space: nowrap;
    overflow: hidden;
    max-width: 100%;
    text-overflow: ellipsis;
  }

  .multiselect__tag-icon {
    cursor: pointer;
    margin-left: 7px;
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    font-weight: 700;
    font-style: initial;
    width: 22px;
    text-align: center;
    line-height: 22px;
    transition: all 0.2s ease;
    border-radius: 5px;
  }

  .multiselect__tag-icon::after {
    content: "";
    color: #266d4d;
    font-size: 14px;
  }

  /* // Remove these lines to avoid green closing button
  //.multiselect__tag-icon:focus,
  //.multiselect__tag-icon:hover {
  //  background: #369a6e;
  //} */

  .multiselect__tag-icon:focus::after,
  .multiselect__tag-icon:hover::after {
    color: white;
  }

  .multiselect__current {
    line-height: 16px;
    min-height: 40px;
    box-sizing: border-box;
    display: block;
    overflow: hidden;
    padding: 8px 12px 0;
    padding-right: 30px;
    white-space: nowrap;
    margin: 0;
    text-decoration: none;
    border-radius: 5px;
    border: 1px solid #e8e8e8;
    cursor: pointer;
  }

  .multiselect__select {
    line-height: 16px;
    display: block;
    position: absolute;
    box-sizing: border-box;
    width: 40px;
    height: 38px;
    right: 1px;
    top: 1px;
    padding: 4px 8px;
    margin: 0;
    text-decoration: none;
    text-align: center;
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  .multiselect__select::before {
    position: relative;
    right: 0;
    top: 65%;
    color: #999;
    margin-top: 4px;
    border-style: solid;
    border-width: 5px 5px 0 5px;
    border-color: #999 transparent transparent transparent;
    content: "";
  }

  .multiselect__placeholder {
    color: #adadad;
    display: inline-block;
    margin-bottom: 10px;
    padding-top: 2px;
  }

  .multiselect--active .multiselect__placeholder {
    display: none;
  }

  .multiselect__content-wrapper {
    position: absolute;
    display: block;
    background: #fff;
    width: 100%;
    max-height: 240px;
    overflow: auto;
    border: 1px solid #e8e8e8;
    border-top: none;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
    z-index: 50;
    -webkit-overflow-scrolling: touch;
  }

  .multiselect__content {
    list-style: none;
    display: inline-block;
    padding: 0;
    margin: 0;
    min-width: 100%;
    vertical-align: top;
  }

  .multiselect--above .multiselect__content-wrapper {
    bottom: 100%;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    border-bottom: none;
    border-top: 1px solid #e8e8e8;
  }

  .multiselect__content::-webkit-scrollbar {
    display: none;
  }

  .multiselect__element {
    display: block;
  }

  .multiselect__option {
    display: block;
    padding: 12px;
    min-height: 40px;
    line-height: 16px;
    text-decoration: none;
    text-transform: none;
    vertical-align: middle;
    position: relative;
    cursor: pointer;
    white-space: nowrap;
  }

  .multiselect__option::after {
    top: 0;
    right: 0;
    position: absolute;
    line-height: 40px;
    padding-right: 12px;
    padding-left: 20px;
    font-size: 13px;
  }

  .multiselect__option--highlight {
    background: #41b883;
    outline: none;
    color: white;
  }

  .multiselect__option--highlight::after {
    content: attr(data-select);
    background: #41b883;
    color: white;
  }

  .multiselect__option--selected {
    background: #f3f3f3;
    color: #35495e;
    font-weight: bold;
  }

  .multiselect__option--selected::after {
    content: attr(data-selected);
    color: silver;
  background: inherit;
  }

  .multiselect__option--selected.multiselect__option--highlight {
    background: #ff6a6a;
    color: #fff;
  }

  .multiselect__option--selected.multiselect__option--highlight::after {
    background: #ff6a6a;
    content: attr(data-deselect);
    color: #fff;
  }

  .multiselect--disabled .multiselect__current,
  .multiselect--disabled .multiselect__select {
    background: #ededed;
    color: #a6a6a6;
  }

  .multiselect__option--disabled {
    background: #ededed !important;
    color: #a6a6a6 !important;
    cursor: text;
    pointer-events: none;
  }

  .multiselect__option--group {
    background: #ededed;
    color: #35495e;
  }

  .multiselect__option--group.multiselect__option--highlight {
    background: #35495e;
    color: #fff;
  }

  .multiselect__option--group.multiselect__option--highlight::after {
    background: #35495e;
  }

  .multiselect__option--disabled.multiselect__option--highlight {
    background: #dedede;
  }

  .multiselect__option--group-selected.multiselect__option--highlight {
    background: #ff6a6a;
    color: #fff;
  }

  .multiselect__option--group-selected.multiselect__option--highlight::after {
    background: #ff6a6a;
    content: attr(data-deselect);
    color: #fff;
  }

  .multiselect-enter-active,
  .multiselect-leave-active {
    transition: all 0.15s ease;
  }

  .multiselect-enter,
  .multiselect-leave-active {
    opacity: 0;
  }

  .multiselect__strong {
    margin-bottom: 8px;
    line-height: 20px;
    display: inline-block;
    vertical-align: top;
  }

  *[dir="rtl"] .multiselect {
    text-align: right;
  }

  *[dir="rtl"] .multiselect__select {
    right: auto;
    left: 1px;
  }

  *[dir="rtl"] .multiselect__tags {
    padding: 8px 8px 0 40px;
  }

  *[dir="rtl"] .multiselect__content {
    text-align: right;
  }

  *[dir="rtl"] .multiselect__option::after {
    right: auto;
    left: 0;
  }

  *[dir="rtl"] .multiselect__clear {
    right: auto;
    left: 12px;
  }

  *[dir="rtl"] .multiselect__spinner {
    right: auto;
    left: 1px;
  }

  @keyframes spinning {
    from {
      transform: rotate(0);
    }

    to {
      transform: rotate(2turn);
    }
  }
.vue-simple-context-menu {
  background-color: #ecf0f1;
  border-bottom-width: 0px;
  border-radius: 4px;
  box-shadow: 0 3px 6px 0 rgba(51, 51, 51, 0.2);
  display: none;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  left: 0;
  list-style: none;
  margin: 0;
  padding: 0;
  position: absolute;
  top: 0;
  z-index: 1000000;
}
.vue-simple-context-menu--active {
  display: block;
}
.vue-simple-context-menu__item {
  align-items: center;
  color: #333;
  cursor: pointer;
  display: flex;
  padding: 5px 15px;
}
.vue-simple-context-menu__item:hover {
  background-color: #007aff;
  color: #fff;
}
.vue-simple-context-menu__divider {
  background-clip: content-box;
  background-color: #c0cdd1;
  box-sizing: content-box;
  height: 2px;
  padding: 4px 0;
  pointer-events: none;
}
.vue-simple-context-menu li:first-of-type {
  margin-top: 4px;
}
.vue-simple-context-menu li:last-of-type {
  margin-bottom: 4px;
}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
#main {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
@media (max-width: 767px) {
#main {
    padding-left: 30px;
    padding-right: 30px;
}
}
#main > a {
  margin-top: auto;
  margin-bottom: 30px;
}
.main-wrapper {
  margin-top: auto;
}
.main-wrapper.wide {
  align-self: stretch;
  margin-top: 0;
}
.options-switch {
  margin-top: auto;
  display: flex;
  align-self: stretch;
  justify-content: space-between;
  padding: 15px;
}
.options-switch > :last-child,
.options-switch > :first-child {
  flex-grow: 1;
  flex-basis: 0;
}
.options-switch :last-child {
  text-align: right;
}
.options-switch #theme-switch {
  display: flex;
  gap: 10px;
}
.options-switch #theme-switch > div {
  width: 20px;
  height: 20px;
  border-radius: 100%;
  outline: 3px solid var(--font-color);
}
.options-switch #theme-switch > div:hover {
  outline: 3px solid gold;
}
.options-switch #language-switch {
  height: auto;
  border-radius: 0;
}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
.small-wrapper {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.infos {
  align-items: center;
}
ul {
  padding: 0;
}
ul li {
  list-style: none;
}
#home {
  display: flex;
  flex: 1;
  flex-direction: column;
  gap: 30px;
  justify-content: center;
}
#home > .menu {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 10px;
}
@media (max-width: 767px) {
#home > .menu {
    display: flex;
    flex-direction: column;
    gap: 20px;
}
}
#home > .menu > div {
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 20px;
}
#home > .menu > div.logo-wrapper {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 15px;
}
@media (max-width: 767px) {
#home > .menu > div.logo-wrapper {
    order: -1;
}
}
#home > .menu > div.logo-wrapper > span {
  font-size: 1.5em;
}
#home > .menu > div.logo-wrapper > .logo {
  max-width: 100px;
  margin-bottom: 30px;
}
#home > .menu a {
  background: var(--button-background);
  color: var(--button-color);
  border-radius: 10px;
  padding: 10px;
}
#home > .menu a:hover {
  outline: 1px solid #646cff;
}
#home > .menu a:focus, #home > .menu a:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}
[data-v-85fa7177]:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker[data-v-85fa7177] {
  background: black;
}
[data-theme=light][data-v-85fa7177] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker[data-v-85fa7177] {
  background: white;
}
[data-theme=blue][data-v-85fa7177] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker[data-v-85fa7177] {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
#id_admin[data-v-85fa7177] {
  padding: 10px;
  text-align: center;
  border-radius: 10px;
  font-size: 0.9em;
  flex: 1;
}
@media (max-width: 767px) {
#id_admin[data-v-85fa7177] {
    flex-basis: 100%;
    font-size: 0.9em;
}
}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
.fade-enter-active > div,
.fade-leave-active > div {
  opacity: 1;
}
.fade-enter-from > div,
.fade-leave-to > div {
  opacity: 0;
}
#wrapper-message {
  display: flex;
  position: absolute;
  bottom: 30px;
  right: 30px;
}
#wrapper-message > div {
  margin: auto;
  padding: 15px;
  background: white;
  border-radius: 10px;
  color: black;
  transition: opacity 1s ease;
}.shepherd-button{background:#3288e6;border:0;border-radius:3px;color:hsla(0,0%,100%,.75);cursor:pointer;margin-right:.5rem;padding:.5rem 1.5rem;transition:all .5s ease}.shepherd-button:not(:disabled):hover{background:#196fcc;color:hsla(0,0%,100%,.75)}.shepherd-button.shepherd-button-secondary{background:#f1f2f3;color:rgba(0,0,0,.75)}.shepherd-button.shepherd-button-secondary:not(:disabled):hover{background:#d6d9db;color:rgba(0,0,0,.75)}.shepherd-button:disabled{cursor:not-allowed}
.shepherd-footer{border-bottom-left-radius:5px;border-bottom-right-radius:5px;display:flex;justify-content:flex-end;padding:0 .75rem .75rem}.shepherd-footer .shepherd-button:last-child{margin-right:0}
.shepherd-cancel-icon{background:transparent;border:none;color:hsla(0,0%,50%,.75);cursor:pointer;font-size:2em;font-weight:400;margin:0;padding:0;transition:color .5s ease}.shepherd-cancel-icon:hover{color:rgba(0,0,0,.75)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon{color:hsla(0,0%,50%,.75)}.shepherd-has-title .shepherd-content .shepherd-cancel-icon:hover{color:rgba(0,0,0,.75)}
.shepherd-title{color:rgba(0,0,0,.75);display:flex;flex:1 0 auto;font-size:1rem;font-weight:400;margin:0;padding:0}
.shepherd-header{align-items:center;border-top-left-radius:5px;border-top-right-radius:5px;display:flex;justify-content:flex-end;line-height:2em;padding:.75rem .75rem 0}.shepherd-has-title .shepherd-content .shepherd-header{background:#e6e6e6;padding:1em}
.shepherd-text{color:rgba(0,0,0,.75);font-size:1rem;line-height:1.3em;padding:.75em}.shepherd-text p{margin-top:0}.shepherd-text p:last-child{margin-bottom:0}
.shepherd-content{border-radius:5px;outline:none;padding:0}
.shepherd-element{background:#fff;border-radius:5px;box-shadow:0 1px 4px rgba(0,0,0,.2);max-width:400px;opacity:0;outline:none;transition:opacity .3s,visibility .3s;visibility:hidden;width:100%;z-index:9999}.shepherd-enabled.shepherd-element{opacity:1;visibility:visible}.shepherd-element[data-popper-reference-hidden]:not(.shepherd-centered){opacity:0;pointer-events:none;visibility:hidden}.shepherd-element,.shepherd-element *,.shepherd-element :after,.shepherd-element :before{box-sizing:border-box}.shepherd-arrow,.shepherd-arrow:before{height:16px;position:absolute;width:16px;z-index:-1}.shepherd-arrow:before{background:#fff;content:"";transform:rotate(45deg)}.shepherd-element[data-popper-placement^=top]>.shepherd-arrow{bottom:-8px}.shepherd-element[data-popper-placement^=bottom]>.shepherd-arrow{top:-8px}.shepherd-element[data-popper-placement^=left]>.shepherd-arrow{right:-8px}.shepherd-element[data-popper-placement^=right]>.shepherd-arrow{left:-8px}.shepherd-element.shepherd-centered>.shepherd-arrow{opacity:0}.shepherd-element.shepherd-has-title[data-popper-placement^=bottom]>.shepherd-arrow:before{background-color:#e6e6e6}.shepherd-target-click-disabled.shepherd-enabled.shepherd-target,.shepherd-target-click-disabled.shepherd-enabled.shepherd-target *{pointer-events:none}
.shepherd-modal-overlay-container{height:0;left:0;opacity:0;overflow:hidden;pointer-events:none;position:fixed;top:0;transition:all .3s ease-out,height 0ms .3s,opacity .3s 0ms;width:100vw;z-index:9997}.shepherd-modal-overlay-container.shepherd-modal-is-visible{height:100vh;opacity:.5;transform:translateZ(0);transition:all .3s ease-out,height 0s 0s,opacity .3s 0s}.shepherd-modal-overlay-container.shepherd-modal-is-visible path{pointer-events:all}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
.tutorial-help {
  display: flex;
  flex-direction: column;
  gap: 30px;
  margin: 30px auto;
}
.tutorial-help .tuto-text {
  background: var(--background-card-color);
  padding: 15px;
  border-radius: 15px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.tutorial-help .logo-wrapper {
  width: 100px;
  align-self: center;
}
.tutorial-help h1 {
  font-size: 2.5em;
  margin-bottom: 0;
}
.tutorial-help strong {
  display: inline-flex;
  align-items: baseline;
  gap: 3px;
  border-radius: 10px;
  border: 1px solid white;
  padding: 6px;
}
.tutorial-help strong:before {
  align-self: flex-end;
}

:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
#player-list {
  display: flex;
  flex-direction: column;
}
#player-list .player {
  border: 1px solid black;
  display: flex;
  flex-direction: column;
}
#tab-characters-content {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  align-items: flex-end;
  justify-content: space-between;
}
#tab-characters-content input:not(.multiselect__input) {
  padding: 0.6em 1.2em;
  border: var(--select-border);
}
#tab-characters-content .multiselect__tags {
  border: var(--select-border);
}
.summary {
  text-align: left;
}
#character-list {
  flex-basis: 100%;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
  grid-gap: 3px;
  grid-auto-rows: minmax(100px, auto);
  font-size: 13px;
  word-break: break-word;
}
#character-list > .character {
  display: flex;
  flex-direction: column;
  gap: 3px;
  padding: 3px 6px 6px 6px;
  border: 1px solid var(--border-color);
  background: var(--background-card-color);
  border-radius: 8px;
  color: var(--font-color);
  user-select: none;
  transition: scale 1s ease, transform 1s ease, opacity 1s ease-in-out;
  transform-origin: top left;
}
#character-list > .character.centered {
  opacity: 1 !important;
  z-index: 100;
}
#character-list > .character:not(.connected) {
  opacity: 0.6;
}
#character-list > .character.picked {
  border: 3px solid var(--character-picked);
}
#character-list > .character.result-success {
  background: var(--success-background);
}
#character-list > .character.result-failure {
  background: var(--failure-background);
}
#character-list > .character.dead {
  position: relative;
  opacity: 0.5;
}
#character-list > .character.dead:before {
  content: "";
  position: absolute;
  top: 13px;
  bottom: 0;
  left: 0;
  right: 0;
  font-size: 68px;
  opacity: 0.6;
  text-shadow: 7px 12px rgba(0, 0, 0, 0.6);
  transition: all 0.2s ease-in-out;
}
#character-list > .character > .stats, #character-list > .character .gauges {
  display: flex;
  flex-direction: column;
}
#character-list > .character > .stats > span, #character-list > .character .gauges > span {
  display: flex;
  justify-content: space-between;
}
#character-list > .character .character-names {
  display: flex;
  flex-direction: column;
  margin-bottom: 6px;
}
#character-list > .character .character-names .character-name {
  font-size: 1.2em;
  font-weight: bold;
}
.clear-selection {
  margin-left: auto;
}
.filter-data {
  display: flex;
  flex: 1;
  gap: 15px;
  flex-direction: row;
  align-items: flex-end;
}
.filter-data > div {
  display: flex;
  flex-direction: column;
}
.result-challenge {
  color: yellow;
}
.result-challenge.failure {
  color: var(--failure-background);
}
.result-challenge.success {
  color: var(--success-background);
}
.dual-button {
  display: flex;
  flex-direction: row !important;
}
.dual-button > button:first-child {
  border-radius: 8px 0 0 8px;
  border-right: 1px dotted white;
}
.dual-button > button:last-child {
  border-radius: 0 8px 8px 0;
}
.dual-button button.active.success-button {
  background: var(--success-background) !important;
}
.dual-button button.active.failure-button {
  background: var(--failure-background) !important;
}
.badge {
  position: relative;
}
.badge > span {
  position: absolute;
  top: -15px;
  right: 4px;
  border-radius: 8px;
  color: black;
  padding: 5px;
  font-size: 0.7em;
  z-index: 1;
}
.badge.success-button > span {
  background: var(--success-background);
}
.badge.failure-button > span {
  background: var(--failure-background);
}
.no-found {
  grid-column: 1/-1;
  font-size: 1rem;
}
.tags {
  gap: 3px;
  margin-top: auto;
}
.tags > .tag {
  border-radius: 10px;
  padding: 1px 5px;
  display: flex;
  align-items: center;
  gap: 2px;
  justify-content: center;
}
.tags > .tag .label-name {
  display: flex;
  align-items: center;
  gap: 3px;
}
.tags > .tag .label-name:before {
  display: block;
  content: "";
  width: 15px;
  height: 15px;
  border-radius: 100%;
}.rcp,.rcp button,.rcp div{-webkit-touch-callout:none;-webkit-tap-highlight-color:transparent;-webkit-user-select:none;-moz-user-select:none;user-select:none;box-sizing:border-box}.rcp{display:block;overflow:hidden;width:280px;height:280px;position:relative;transform:scale(1.001);transition:transform .15s cubic-bezier(.68, 0, .47, 2)}.rcp:focus{outline:0}.rcp:hover .rcp__knob{box-shadow:0 0 20px rgba(0,0,0,.19),0 0 10px rgba(0,0,0,.24)}.rcp.dragging{transform:scale(1.04)}.rcp.disabled{cursor:not-allowed;transform:scale(.96)}.rcp.dragging .rcp__rotator{z-index:1}.rcp__palette{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;background-size:100% 100%;background-image:conic-gradient(red,#ff0,#0f0,#0ff,#00f,#ff00ff,red);-webkit-mask-image:radial-gradient(circle at 50% 50%,transparent 53.5%,black 54%);mask-image:radial-gradient(circle at 50% 50%,transparent 53.5%,black 54%);border-radius:50%;overflow:hidden;will-change:transform,opacity;transition:transform .5s cubic-bezier(.35, 0, .25, 1),opacity .5s cubic-bezier(.35, 0, .25, 1)}.rcp__palette.in{transform:scale(1);opacity:1}.rcp__palette.out{transform:scale(0);opacity:0}.disabled .rcp__palette{filter:contrast(.25)}.rcp__rotator{width:100%;height:100%;position:absolute;transform:rotate(var(--rcp-initial-angle))}.rcp__knob{box-shadow:0 0 10px rgba(0,0,0,.12),0 0 5px rgba(0,0,0,.16);border-radius:50%;position:absolute;width:7%;height:7%;top:2.5%;left:46.5%;background-color:#fff;transition:transform .4s cubic-bezier(.35, 0, .25, 1);outline:0;border-style:none}.rcp__knob.in{transform:scale(1)}.rcp__knob.out{transform:scale(0)}.disabled .rcp__knob{box-shadow:none;pointer-events:none}.rcp__well{position:absolute;width:25%;height:25%;top:37.5%;left:37.5%;padding:0;margin:0;border-radius:50%;background-color:red;outline:0;cursor:pointer;overflow:visible;border:6px solid #fff;box-shadow:0 0 0 1px #b2b2b2}.rcp__well::-moz-focus-inner{border:0}.rcp__well:hover{box-shadow:0 0 1px 1px #333}.rcp__well:focus{box-shadow:0 0 1px 2px #b2b2b2}.rcp__well.pressed{animation:rcp-beat .4s cubic-bezier(.35,0,.25,1) forwards}.disabled .rcp__well{background-color:#bfbfbf!important;pointer-events:none}.rcp__ripple{width:20%;height:20%;border-radius:50%;border:red solid 8px;opacity:0;position:absolute;top:40%;left:40%;z-index:-1}.rcp__ripple.rippling{z-index:0;animation:rcp-ripple .5s cubic-bezier(.35,0,.25,1) forwards}@keyframes rcp-ripple{0%{transform:scale(1);opacity:.3}50%{opacity:.1}100%{opacity:0;border-width:0;transform:scale(3.8)}}@keyframes rcp-beat{0%{transform:scale(1)}25%{transform:scale(.8)}50%{transform:scale(1)}100%{transform:scale(1)}}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
.group-tag {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
  background: var(--background-card-color);
  border: 1px solid var(--border-color);
  border-radius: 10px;
  padding: 10px 15px;
}
.group-tag button {
  display: flex;
  align-items: center;
  gap: 10px;
}
.group-tag .group-label {
  display: flex;
  gap: 10px;
}
.group-tag .actions {
  flex: 0;
  margin-left: auto;
}
.group-tag .actions > label {
  white-space: nowrap;
}
.group-tag > label:first-child {
  align-self: center;
}
.group-tag > button {
  margin-left: auto;
  align-self: center;
}
.group-tag > label {
  align-items: center;
  display: flex;
  gap: 5px;
}
.group-tag .multiselect {
  flex: 1 0 100%;
}
.group-tag .multiselect .multiselect__input {
  position: relative !important;
  border: none;
  right: unset;
  top: unset;
  text-align: left;
}
.group-tag .multiselect .multiselect__tags {
  border-radius: 5px;
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag {
  padding: 6px 10px;
  align-items: flex-start;
  display: flex;
  gap: 3px;
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag button {
  align-self: baseline;
  padding: 0;
  color: var(--font-color);
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag > div {
  display: flex;
  flex-direction: column;
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag > div .label-name {
  font-size: 1.2em;
  font-weight: bold;
  display: flex;
  align-items: center;
  gap: 3px;
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag > div .label-name:before {
  display: block;
  content: "";
  width: 20px;
  height: 20px;
  border-radius: 100%;
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag > div .hover-only {
  opacity: 0;
  position: absolute;
  display: none;
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag:hover {
  cursor: pointer;
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag:hover .label-name:before {
  opacity: 0;
}
.group-tag .multiselect .multiselect__tags-wrap .multiselect__tag:hover span.hover-only {
  opacity: 1;
  display: block;
}
.color-picker {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  width: 100vw;
  height: 100vh;
  display: none;
  opacity: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 10000;
  transition: all 0.3s ease-in-out;
}
.color-picker.show {
  display: flex;
  opacity: 1;
}
.color-picker > .rcp {
  margin: auto;
  z-index: 1000;
}
[data-v-7d13a1fc]:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker[data-v-7d13a1fc] {
  background: black;
}
[data-theme=light][data-v-7d13a1fc] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker[data-v-7d13a1fc] {
  background: white;
}
[data-theme=blue][data-v-7d13a1fc] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker[data-v-7d13a1fc] {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,AAEAAAALAIAAAwAwT1MvMg8SBfQAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZoIYGEIAAAF4AAAHKGhlYWQmCLzRAAAIoAAAADZoaGVhB9MD4QAACNgAAAAkaG10eCIdAAAAAAj8AAAALGxvY2EGLAfgAAAJKAAAABhtYXhwABAAgQAACUAAAAAgbmFtZZlKCfsAAAlgAAABhnBvc3QAAwAAAAAK6AAAACAAAwPEAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAD/wAAAA8AAAgAANzkBAAAAAAEAAP/AAAADwAACAAA3OQEAAAAAAQAA/8AAAAPAAAIAADc5AQAAAAADAAD/wAQAA8AAGwA3ADoAAAEiBw4BBwYVFBceARcWMzI3PgE3NjU0Jy4BJyYDIicuAScmNTQ3PgE3NjMyFx4BFxYVFAcOAQcGAxElAgBqXV6LKCgoKIteXWpqXV6LKCgoKIteXWpjWFeCJiYmJoJXWGNjWFeCJiYmJoJXWOcBjQPAKCiLXl1qal1eiygoKCiLXl1qal1eiygo/CAmJoJXWGNjWFeCJiYmJoJXWGNjWFeCJiYCxf415gAAAAQAAP/ABAADwAAdADwAXQBiAAAFIicuAScmNTQ3PgE3NjMyFx4BFxYVMRQHDgEHBiMRIgcOAQcGFRQXHgEXFjMyNz4BNzY1MTQnLgEnJiMxEyM1MzI2NTQmIyIGFTEjNDc+ATc2MzIXHgEXFhUUBgcjBzMVIzUCAGpdXosoKCgoi15dampdXosoKCgpi11dalhOTnQhIiIhdE5OWFhOTnQhIiIic05OWCtWKzVLSzU1S1UQETonJywsJyc6ERBgSQFWVlZAKCiLXl1qal1eiygoKCiLXl1qal1diykoA6siIXROTlhYTk50ISIiIXROTlhYTk5zIiL9qqtLNTVLSzUsJyc6ERAQETonJyxNdQ+vVVUAAAIAAP/AA9sDwAAcAD0AAAExJicmIgcGBwYHBhQXFhcWFxYyNzY3Njc2NCcmAzIWFRQGKwEVFAYjIiY9ASMiJjU0NjsBNTQ2MzIWHQEzA2pLXl/EX15LSyYlJSZLS15fxF9eS0smJSUmqQwREQzvEQwMEe8MEREM7xEMDBHvAypLJiUlJktLXl/EX15LSyYlJSZLS15fxF9e/v4RDAwR7wwREQzvEQwMEe8MEREM7wAAAQAA/8AEEQPAAGQAAAEiBw4BBwYVFBceARcWFxY2NTQmNQYmMS4BMSY2MR4BMRY2Nz4BNyYnLgEnJjU0NjcuATcwFhc+ATMxMhYXPgExFgYHHgEVFAcOAQcGBx4BFRQGFRQWNzY3PgE3NjU2Jy4BJyYjAglsX1+NKSkbGl9BQk0UEAFtQhIoJCcoKSNeFgQSCysrKkMVFR0YAw0WREsdQiMhQh9LRRUMBBkcFRREKyosDhYBEBNOQUFfGxoBKSmNX19sA8ApKY9fYG1XT0+CMDEaBBMKCTghGFYuHxgIAzM8BgoaIwoEDQ05MDBMK0YcCUw2AzMICQkIMwM2TAkcRitMMDA5DQwFDS8mNE8NChMEGjEwgk9PV21gX48pKQAAAwAA/8AEAAPAABsAHwBUAAABIgcOAQcGFRQXHgEXFjMyNz4BNzY1NCcuAScmBwUhJQExFAYjISImNRE0NjUFOAEzFDIxHgEXMDIxMhYzMTgBMTI2MzAyMT4BNzAyNTIwMSUUFhURAgBqXV6LKCgoKIteXWpqXV6LKCgoKIteXWoBL/2iAS8BMyAX/ggXIAEBIgEBAQQBAQIDAgIDAgEBBAEBAQEiAQPAKCiLXl1qal1eiygoKCiLXl1qal1eiygotL29/hYXICAXASEDBAO1AQEBAQEBAQEBAbUDBAP+3wACAAD/wAQAA8AAYQB+AAABMSYiDwEuASc1NCYrASIGHQEOAQcnJiIPAQYUHwEOAQcjIgYdARQWOwEeARcHBhQfARYyPwEeARcVFBY7ATI2PQE+ATcXFjI/ATY0LwE+ATczMjY9ATQmKwEuASc3NjQvAQUyFx4BFxYVFAcOAQcGIyInLgEnJjU0Nz4BNzYzA08PKQ82FjAZHRVoFB4aMRc7DikPSQ8PNg4WCFMVHR0VTAYTDDsPD0kPKQ82FjAZHRVoFB4aMRc7DioOSg4ONw4WCFMVHR0VTAYTDDsPD0n+sSomJTcQEBAQNyUmKiomJTcQEBAQNyUmKgNFDw82DhYIUxUdHRVMBhMMOw8PSQ8pDzYWMBkdFWgUHhoxFjwOKQ9JDw82DhYIUxUdHRVMBhMMOw8PSQ8pDzYWMBkdFWgUHhoxFzsOKQ9JuRAQNyUmKiomJTcQEBAQNyUmKiomJTcQEAAAAAQAAP/ABAgDwAAPAD8ATwBUAAABLgEjIgYPARc3PgE1NCYnJSEVISIGBw4BFREUFhceATMhMjY3PgE1ETMRFAYHDgEjISImJy4BNRE0Njc+ATMxAQ4BBw4BBw4BBwY2PwIXJwEXAScDiQcNCAgOBT2rPQYFBgb8SgGm/o4CBQIBAwMBAgUCAuECBQICAm0LCQoZD/y3DxkJCgsLCgkaDgIDESMQESIRKC0FBAUKKwOpagEIq/71qAO1BgUGBj+mQQUPBwgOBk5tAgICBQL9HwIFAgICAgICBQIBY/5pDhoJCgsLCgkaDgNJDxkKCQv9tQYLBQYLBg0OAQImJqMEqOkBEqX+66gAAAEAAAABAAAOMGG9Xw889QALBAAAAAAA4Ww8KgAAAADhbDwqAAD/wAQRA8AAAAAIAAIAAAAAAAAAAQAAA8D/wAAABBUAAAAABBEAAQAAAAAAAAAAAAAAAAAAAAsEAAAAAAAAAAAAAAACAAAABAAAAAQAAAAEAAAABBUAAAQAAAAEAAAABAgAAAAAAAAACgAUAB4AfAEGAV4B7gJeAxADlAABAAAACwB/AAQAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEABwAAAAEAAAAAAAIABwBgAAEAAAAAAAMABwA2AAEAAAAAAAQABwB1AAEAAAAAAAUACwAVAAEAAAAAAAYABwBLAAEAAAAAAAoAGgCKAAMAAQQJAAEADgAHAAMAAQQJAAIADgBnAAMAAQQJAAMADgA9AAMAAQQJAAQADgB8AAMAAQQJAAUAFgAgAAMAAQQJAAYADgBSAAMAAQQJAAoANACkaWNvbW9vbgBpAGMAbwBtAG8AbwBuVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwaWNvbW9vbgBpAGMAbwBtAG8AbwBuaWNvbW9vbgBpAGMAbwBtAG8AbwBuUmVndWxhcgBSAGUAZwB1AGwAYQByaWNvbW9vbgBpAGMAbwBtAG8AbwBuRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
#tab-settings-content[data-v-7d13a1fc] {
  flex-direction: row;
}
.wrapper-settings[data-v-7d13a1fc] {
  gap: 15px;
  display: flex;
  flex-direction: row;
  flex: 1;
  background: var(--background-card-color);
  padding: 30px;
  flex-wrap: wrap;
  align-items: center;
  align-content: flex-start;
}
.wrapper-settings input[type=number][data-v-7d13a1fc] {
  max-width: 60px;
  height: 40px;
}
h2[data-v-7d13a1fc] {
  margin: 0;
}
.wrapper-title[data-v-7d13a1fc] {
  display: flex;
  flex-basis: 100%;
  justify-content: space-between;
  margin-bottom: 30px;
}
.wrapper-list[data-v-7d13a1fc] {
  display: flex;
  flex-direction: column;
  gap: 15px;
  flex: 1;
}
.wrapper-gauge-title[data-v-7d13a1fc] {
  display: flex;
  flex-wrap: wrap;
  text-align: left;
  gap: 0 10px;
}
.wrapper-gauge-title .gauge-name[data-v-7d13a1fc] {
  font-weight: bold;
  flex-basis: 100%;
}
.wrapper-gauge-title span[data-v-7d13a1fc]:not(.gauge-name) {
  font-size: 0.9em;
}
.list-item[data-v-7d13a1fc] {
  display: flex;
  gap: 10px;
  align-items: center;
}
.action[data-v-7d13a1fc] {
  margin-left: auto;
  display: flex;
  gap: 10px;
}
.action-group[data-v-7d13a1fc] {
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: space-between;
}
.action-group button[data-v-7d13a1fc]:first-of-type {
  margin-left: auto;
}
.temp-stat-group[data-v-7d13a1fc] {
  display: flex;
  gap: 15px;
}
.list-item[data-v-7d13a1fc] {
  flex-basis: 100%;
  justify-content: space-between;
}
.list-item[data-v-7d13a1fc]:first-of-type {
  margin-top: auto;
}
.list-item input[data-v-7d13a1fc] {
  align-self: stretch;
}
.list-item button[data-v-7d13a1fc] {
  white-space: nowrap;
}
.list-item .btn-valid[data-v-7d13a1fc] {
  margin-left: auto;
}
[data-v-7e3c4dd5]:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker[data-v-7e3c4dd5] {
  background: black;
}
[data-theme=light][data-v-7e3c4dd5] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker[data-v-7e3c4dd5] {
  background: white;
}
[data-theme=blue][data-v-7e3c4dd5] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker[data-v-7e3c4dd5] {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,d09GRgABAAAAAAtUAAsAAAAACwgAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIF9GNtYXAAAAFoAAAAVAAAAFQXVtKNZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAABygAAAcoghgYQmhlYWQAAAjsAAAANgAAADYmCLzRaGhlYQAACSQAAAAkAAAAJAfTA+FobXR4AAAJSAAAACwAAAAsIh0AAGxvY2EAAAl0AAAAGAAAABgGLAfgbWF4cAAACYwAAAAgAAAAIAAQAIFuYW1lAAAJrAAAAYYAAAGGmUoJ+3Bvc3QAAAs0AAAAIAAAACAAAwAAAAMDxAGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QYDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkG//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAA/8AAAAPAAAIAADc5AQAAAAABAAD/wAAAA8AAAgAANzkBAAAAAAEAAP/AAAADwAACAAA3OQEAAAAAAwAA/8AEAAPAABsANwA6AAABIgcOAQcGFRQXHgEXFjMyNz4BNzY1NCcuAScmAyInLgEnJjU0Nz4BNzYzMhceARcWFRQHDgEHBgMRJQIAal1eiygoKCiLXl1qal1eiygoKCiLXl1qY1hXgiYmJiaCV1hjY1hXgiYmJiaCV1jnAY0DwCgoi15dampdXosoKCgoi15dampdXosoKPwgJiaCV1hjY1hXgiYmJiaCV1hjY1hXgiYmAsX+NeYAAAAEAAD/wAQAA8AAHQA8AF0AYgAABSInLgEnJjU0Nz4BNzYzMhceARcWFTEUBw4BBwYjESIHDgEHBhUUFx4BFxYzMjc+ATc2NTE0Jy4BJyYjMRMjNTMyNjU0JiMiBhUxIzQ3PgE3NjMyFx4BFxYVFAYHIwczFSM1AgBqXV6LKCgoKIteXWpqXV6LKCgoKYtdXWpYTk50ISIiIXROTlhYTk50ISIiInNOTlgrVis1S0s1NUtVEBE6JycsLCcnOhEQYEkBVlZWQCgoi15dampdXosoKCgoi15dampdXYspKAOrIiF0Tk5YWE5OdCEiIiF0Tk5YWE5OcyIi/aqrSzU1S0s1LCcnOhEQEBE6JycsTXUPr1VVAAACAAD/wAPbA8AAHAA9AAABMSYnJiIHBgcGBwYUFxYXFhcWMjc2NzY3NjQnJgMyFhUUBisBFRQGIyImPQEjIiY1NDY7ATU0NjMyFh0BMwNqS15fxF9eS0smJSUmS0teX8RfXktLJiUlJqkMEREM7xEMDBHvDBERDO8RDAwR7wMqSyYlJSZLS15fxF9eS0smJSUmS0teX8RfXv7+EQwMEe8MEREM7xEMDBHvDBERDO8AAAEAAP/ABBEDwABkAAABIgcOAQcGFRQXHgEXFhcWNjU0JjUGJjEuATEmNjEeATEWNjc+ATcmJy4BJyY1NDY3LgE3MBYXPgEzMTIWFz4BMRYGBx4BFRQHDgEHBgceARUUBhUUFjc2Nz4BNzY1NicuAScmIwIJbF9fjSkpGxpfQUJNFBABbUISKCQnKCkjXhYEEgsrKypDFRUdGAMNFkRLHUIjIUIfS0UVDAQZHBUURCsqLA4WARATTkFBXxsaASkpjV9fbAPAKSmPX2BtV09PgjAxGgQTCgk4IRhWLh8YCAMzPAYKGiMKBA0NOTAwTCtGHAlMNgMzCAkJCDMDNkwJHEYrTDAwOQ0MBQ0vJjRPDQoTBBoxMIJPT1dtYF+PKSkAAAMAAP/ABAADwAAbAB8AVAAAASIHDgEHBhUUFx4BFxYzMjc+ATc2NTQnLgEnJgcFISUBMRQGIyEiJjURNDY1BTgBMxQyMR4BFzAyMTIWMzE4ATEyNjMwMjE+ATcwMjUyMDElFBYVEQIAal1eiygoKCiLXl1qal1eiygoKCiLXl1qAS/9ogEvATMgF/4IFyABASIBAQEEAQECAwICAwIBAQQBAQEBIgEDwCgoi15dampdXosoKCgoi15dampdXosoKLS9vf4WFyAgFwEhAwQDtQEBAQEBAQEBAQG1AwQD/t8AAgAA/8AEAAPAAGEAfgAAATEmIg8BLgEnNTQmKwEiBh0BDgEHJyYiDwEGFB8BDgEHIyIGHQEUFjsBHgEXBwYUHwEWMj8BHgEXFRQWOwEyNj0BPgE3FxYyPwE2NC8BPgE3MzI2PQE0JisBLgEnNzY0LwEFMhceARcWFRQHDgEHBiMiJy4BJyY1NDc+ATc2MwNPDykPNhYwGR0VaBQeGjEXOw4pD0kPDzYOFghTFR0dFUwGEww7Dw9JDykPNhYwGR0VaBQeGjEXOw4qDkoODjcOFghTFR0dFUwGEww7Dw9J/rEqJiU3EBAQEDclJioqJiU3EBAQEDclJioDRQ8PNg4WCFMVHR0VTAYTDDsPD0kPKQ82FjAZHRVoFB4aMRY8DikPSQ8PNg4WCFMVHR0VTAYTDDsPD0kPKQ82FjAZHRVoFB4aMRc7DikPSbkQEDclJioqJiU3EBAQEDclJioqJiU3EBAAAAAEAAD/wAQIA8AADwA/AE8AVAAAAS4BIyIGDwEXNz4BNTQmJyUhFSEiBgcOARURFBYXHgEzITI2Nz4BNREzERQGBw4BIyEiJicuATURNDY3PgEzMQEOAQcOAQcOAQcGNj8CFycBFwEnA4kHDQgIDgU9qz0GBQYG/EoBpv6OAgUCAQMDAQIFAgLhAgUCAgJtCwkKGQ/8tw8ZCQoLCwoJGg4CAxEjEBEiESgtBQQFCisDqWoBCKv+9agDtQYFBgY/pkEFDwcIDgZObQICAgUC/R8CBQICAgICAgUCAWP+aQ4aCQoLCwoJGg4DSQ8ZCgkL/bUGCwUGCwYNDgECJiajBKjpARKl/uuoAAABAAAAAQAADjBhvV8PPPUACwQAAAAAAOFsPCoAAAAA4Ww8KgAA/8AEEQPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQVAAAAAAQRAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAAAEAAAABAAAAAQVAAAEAAAABAAAAAQIAAAAAAAAAAoAFAAeAHwBBgFeAe4CXgMQA5QAAQAAAAsAfwAEAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGljb21vb24AaQBjAG8AbQBvAG8AblZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGljb21vb24AaQBjAG8AbQBvAG8Abmljb21vb24AaQBjAG8AbQBvAG8AblJlZ3VsYXIAUgBlAGcAdQBsAGEAcmljb21vb24AaQBjAG8AbQBvAG8AbkZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
.vertical-wrapper > div[data-v-7e3c4dd5] {
  background: var(--background-card-color);
  padding: 10px;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.vertical-wrapper input[type=text][data-v-7e3c4dd5] {
  height: 40px;
}
.poll-choice[data-v-7e3c4dd5] {
  display: flex;
  gap: 10px;
  align-items: center;
}
.poll-choice > div[data-v-7e3c4dd5] {
  display: flex;
  gap: 10px;
  align-items: center;
}
.add-poll[data-v-7e3c4dd5] {
  text-align: left;
}
.list-polls[data-v-7e3c4dd5] {
  display: flex;
  gap: 10px;
}
.list-polls > .wrapper-title[data-v-7e3c4dd5] {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}
.list-polls > .wrapper-title > .title[data-v-7e3c4dd5] {
  font-weight: bold;
}
.list-polls .full_attendance[data-v-7e3c4dd5] {
  color: var(--success-color);
}
.list-polls.poll-active[data-v-7e3c4dd5] {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 10px;
  background: var(--background-card-color);
  border-radius: 10px;
  padding: 10px 15px;
  transition: all 0.5s ease-in-out;
  transform-origin: top right;
}
.list-polls.poll-active .results[data-v-7e3c4dd5] {
  flex-basis: 100%;
  filter: blur(10px);
  transition: all 1s ease;
}
.list-polls.poll-active.show .results[data-v-7e3c4dd5] {
  filter: blur(0px);
}
.list-polls.poll-past[data-v-7e3c4dd5] {
  flex-direction: column;
  align-items: stretch;
  gap: 15px;
}
.list-polls.poll-past .title[data-v-7e3c4dd5] {
  margin-right: auto;
}
.list-polls.poll-past > div[data-v-7e3c4dd5]:not(.wrapper-title) {
  display: none;
}
.list-polls.poll-past.open[data-v-7e3c4dd5] {
  background: var(--background-card-color);
  padding: 10px;
  border-radius: 10px;
}
.list-polls.poll-past.open > div[data-v-7e3c4dd5] {
  display: flex;
}
.list-polls.poll-past.open .see-more[data-v-7e3c4dd5] {
  display: none;
}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
#tab-challenge-content {
  counter-set: step-challenge;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  grid-gap: 15px;
}
#tab-challenge-content #chosen_stat {
  height: 40px;
}
#tab-challenge-content #chosen-targets {
  flex-direction: row;
}
#tab-challenge-content #chosen-targets > div {
  flex-direction: column;
  flex: 1;
}
#tab-challenge-content > div {
  display: flex;
  flex-basis: 100%;
  flex-direction: column;
  background: var(--background-card-color);
  border-radius: 10px;
  padding: 15px;
  align-items: center;
  justify-content: center;
  gap: 30px;
}
#tab-challenge-content > div > div {
  display: flex;
  align-items: center;
  gap: 10px;
}
#tab-challenge-content > div > div.inline {
  flex-wrap: wrap;
}
#tab-challenge-content > div > div .full {
  flex-basis: 100%;
}
#tab-challenge-content #summary-target {
  flex: 1;
}
#tab-challenge-content #summary-target > div {
  display: flex;
  flex-direction: column;
}
#tab-challenge-content #summary-target > div > div {
  display: flex;
  gap: 10px;
}
#tab-challenge-content #chosen-success,
#tab-challenge-content #chosen-failure {
  flex: 1;
}
#tab-challenge-content #chosen-success input[type=number],
#tab-challenge-content #chosen-failure input[type=number] {
  width: 46px;
  border-radius: 100%;
  text-align: center;
  height: 46px;
}
#tab-challenge-content #chosen-success > div,
#tab-challenge-content #chosen-failure > div {
  display: flex;
  align-items: center;
  gap: 30px;
}
#tab-challenge-content #chosen-success > div > div.modifiers-buttons,
#tab-challenge-content #chosen-failure > div > div.modifiers-buttons {
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1;
  gap: 10px;
  flex-wrap: wrap;
}
#tab-challenge-content #chosen-success > div > div.modifiers-buttons > div,
#tab-challenge-content #chosen-failure > div > div.modifiers-buttons > div {
  display: flex;
  gap: 5px;
  align-items: center;
}
#tab-challenge-content #chosen-success > div > div.modifiers-buttons > div > .modifier-value,
#tab-challenge-content #chosen-failure > div > div.modifiers-buttons > div > .modifier-value {
  flex: 1;
}
#tab-challenge-content #chosen-success > div > div.modifiers-buttons > div > button,
#tab-challenge-content #chosen-failure > div > div.modifiers-buttons > div > button {
  text-align: center;
  display: inline-block;
  border-radius: 100%;
  width: 30px;
  height: 28px;
  padding: 0;
  flex: 1;
}
#tab-challenge-content #chosen-success > div > div.modifiers-buttons > .modifier-label,
#tab-challenge-content #chosen-failure > div > div.modifiers-buttons > .modifier-label {
  flex-basis: 100%;
}
#tab-challenge-content .positive {
  border-color: lightgreen;
}
#tab-challenge-content .negative {
  border-color: lightcoral;
}
.slider-target {
  width: 100%;
}
.slider-tooltip {
  background: var(--background-card-color);
  border: 1px solid var(--font-color);
  color: var(--font-color);
}
.label-difficulty {
  color: var(--slider-connect-bg);
}
.summary {
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.select {
  height: 49px;
  background: var(--font-color);
  border-radius: 8px;
  color: var(--background-color);
  border: 1px solid var(--font-color);
}
.multiselect__placeholder {
  display: none;
}
:root {
  --slider-height: 40px;
}
[data-v-208e2001]:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker[data-v-208e2001] {
  background: black;
}
[data-theme=light][data-v-208e2001] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker[data-v-208e2001] {
  background: white;
}
[data-theme=blue][data-v-208e2001] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker[data-v-208e2001] {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
#tab-pick-content input[type=number][data-v-208e2001] {
  width: 60px;
  height: 60px;
  border-radius: 100%;
  text-align: center;
  background: white;
  color: black;
  font-size: 1.1em;
}
#tab-pick-content > div[data-v-208e2001] {
  flex: 1;
  flex-wrap: wrap;
  justify-content: flex-start;
  text-align: left;
  background: var(--background-card-color);
  padding: 15px;
  border-radius: 15px;
  gap: 15px;
}
#tab-pick-content > div .label-wrapper[data-v-208e2001] {
  flex-basis: 100%;
  font-weight: bold;
}
#tab-pick-content > div .modifiers[data-v-208e2001] {
  display: flex;
  align-items: center;
  gap: 30px;
}
#tab-pick-content > div .modifiers > .modifiers-buttons[data-v-208e2001] {
  text-align: center;
}
#admin_pick_button[data-v-208e2001] {
  align-self: flex-start;
}
.vertical-wrapper[data-v-208e2001] {
  flex-direction: row;
}
.multiselect[data-v-208e2001] {
  width: auto;
}
#consequences > div[data-v-208e2001] {
  display: flex;
  align-items: center;
  gap: 30px;
}
#consequences > div.full[data-v-208e2001] {
  flex-basis: 100%;
}
#consequences > div > div.modifiers-buttons[data-v-208e2001] {
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1;
  gap: 10px;
  flex-wrap: wrap;
}
#consequences > div > div.modifiers-buttons > div[data-v-208e2001] {
  display: flex;
  gap: 10px;
  align-items: center;
}
#consequences > div > div.modifiers-buttons > div > .modifier-value[data-v-208e2001] {
  flex: 1;
}
#consequences > div > div.modifiers-buttons > div > button[data-v-208e2001] {
  text-align: center;
  display: inline-block;
  border-radius: 100%;
  width: 30px;
  height: 30px;
  padding: 0;
  flex: 1;
}
#consequences > div > div.modifiers-buttons > .modifier-label[data-v-208e2001] {
  flex-basis: 100%;
  text-align: center;
}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
#admin-wrapper {
  margin-bottom: auto;
  align-self: stretch;
}
#admin-wrapper button {
  background-color: var(--button-background);
}
#admin-wrapper button.active {
  border: 1px solid #39c6ff;
}
#admin-wrapper .game-name {
  border-radius: 0;
  background: var(--font-color);
  color: var(--inverse-font-color);
}
#admin-wrapper #input-game-name {
  border-radius: 0;
  height: auto;
  text-align: center;
}
.multiselect {
  min-width: 200px;
  margin-top: 20px;
  box-sizing: unset;
}
.multiselect:after {
  content: "";
  border-right: var(--border-input);
  height: 8px;
  position: absolute;
  right: 0;
  z-index: 1000;
  width: 20px;
  display: block;
  top: -5px;
}
.multiselect .multiselect__option--group {
  text-align: center;
  background: black !important;
  color: white !important;
}
.multiselect .multiselect__option--group.multiselect__option--highlight.multiselect__option--group-selected:after {
  content: "-";
}
.multiselect .multiselect__option--group.multiselect__option--highlight:after {
  content: "+";
}
.multiselect .multiselect__input {
  position: absolute;
  top: -21px;
  right: 0;
  width: auto;
  min-width: 140px;
  margin: var(--margin-multiselect);
  text-align: center;
  color: black;
  border: var(--multiselect-border);
  border-bottom: 1px solid white;
  border-radius: 5px 5px 0 0;
}
.multiselect .multiselect__tags {
  position: relative;
  padding: 4px;
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
  align-items: center;
  font-size: 0.8em;
  background: var(--background-select);
  border: var(--border-input);
  border-radius: 5px 0 5px 5px;
}
.multiselect.left-multiselect {
  width: auto;
}
.multiselect.left-multiselect .multiselect__input {
  left: 0;
}
.multiselect.left-multiselect .multiselect__tags {
  border-radius: 0 5px 5px 5px;
}
.multiselect.multiselect--active .multiselect__tags {
  border-top-right-radius: 0;
  border-top-left-radius: 0;
}
.multiselect .multiselect__tags-wrap {
  display: flex;
  align-items: flex-start;
  flex-wrap: wrap;
  gap: 5px;
}
.multiselect .multiselect__tag {
  display: flex;
  padding: 6px;
  align-items: center;
  margin: 0;
  background: var(--tag-color);
}
.multiselect .multiselect__tag-icon::after {
  display: flex;
  position: relative;
}
.multiselect .multiselect__tag-icon {
  position: relative;
  width: auto;
  margin: 0;
}
.multiselect .multiselect__tag-icon:after {
  font-size: 2em;
  color: var(--button-color);
}
.tabs {
  display: flex;
  flex-wrap: wrap;
  align-content: flex-start;
  margin-bottom: 0;
}
.tabs > .tab-label {
  display: flex;
  margin-bottom: auto;
  justify-content: center;
  align-items: center;
  padding: 15px 20px;
  cursor: pointer;
  font-weight: 500;
  border-bottom: 1px solid var(--font-color);
}
@media (max-width: 1023px) {
.tabs > .tab-label {
    padding: 15px 10px;
}
}
.tabs > .tab-label.open {
  position: relative;
}
.tabs > .tab-label.open:before {
  position: absolute;
  content: "";
  border-left: 1px solid var(--tab-border-color);
  border-right: 1px solid var(--tab-border-color);
  border-bottom: 2px solid var(--background-color);
  width: 100%;
  height: 100%;
  left: 0;
}
.tabs > .tab-label.open:first-of-type:before {
  border-left: none;
}
.tabs > .tab-details {
  border-bottom: 1px solid var(--font-color);
  display: flex;
  flex: 1;
  justify-content: flex-end;
}
.tabs > .tab-details > button {
  display: flex;
  align-items: center;
  border-radius: 0;
  gap: 10px;
}
.tabs-content {
  margin-bottom: auto;
}
.tabs-content .tab {
  display: none;
  padding: 30px;
  flex-grow: 1;
}
.tabs-content .tab.open {
  display: block;
}
.tabs-content .tab.open#tab-tags {
  display: flex;
  justify-content: unset;
  flex-direction: column;
  gap: 15px;
  text-align: left;
}
.tabs-content .tab > div:first-child {
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.actions {
  display: flex;
  gap: 15px;
  flex-basis: 100%;
  align-items: center;
}
@media (max-width: 767px) {
.actions {
    flex-wrap: wrap;
}
}
.actions > label {
  display: flex;
  align-items: center;
}
.actions.secondary > button:first-of-type {
  margin-left: auto;
}
.actions:not(.secondary) > button:first-of-type {
  margin-right: auto;
}
.attention {
  background-color: black;
  color: white;
  animation-name: color;
  animation-duration: 2s;
  animation-iteration-count: infinite;
}
.attention:before {
  border-radius: 100%;
  animation-name: invert-color;
  animation-duration: 2s;
  animation-iteration-count: infinite;
}
.vue-simple-context-menu {
  font-size: 14px;
}
.vue-simple-context-menu li {
  padding-top: 0;
}
@keyframes color {
0% {
    background-color: var(--success-background);
}
50% {
    background-color: black;
}
100% {
    background-color: var(--success-background);
}
}
@keyframes invert-color {
0% {
    background-color: black;
}
50% {
    background-color: var(--success-background);
}
100% {
    background-color: black;
}
}
[data-v-4d20dbba]:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker[data-v-4d20dbba] {
  background: black;
}
[data-theme=light][data-v-4d20dbba] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker[data-v-4d20dbba] {
  background: white;
}
[data-theme=blue][data-v-4d20dbba] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker[data-v-4d20dbba] {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
input[data-v-4d20dbba] {
  height: auto;
}
.game-wait[data-v-4d20dbba] {
  color: white;
}
.game-name[data-v-4d20dbba] {
  font-size: 1.2em;
  margin-top: 20px;
}
#player-sheet[data-v-4d20dbba] {
  display: flex;
  border-radius: 10px;
  color: var(--background-card-color);
  flex-direction: column;
  gap: 10px;
  margin-top: 20px;
  background: var(--font-color);
  padding: 10px;
  align-items: center;
  justify-content: center;
}
#player-sheet input[data-v-4d20dbba] {
  border: 1px solid var(--border-color);
}
#player-sheet .character-names[data-v-4d20dbba] {
  display: flex;
  flex-direction: column;
  text-align: center;
}
#player-sheet .character-names .character-name[data-v-4d20dbba] {
  font-size: 1.5em;
}
#player-sheet .tags[data-v-4d20dbba] {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
#player-sheet .tags > span[data-v-4d20dbba] {
  border-radius: 10px;
  background: var(--background-color);
  color: var(--font-color);
  padding: 5px;
  text-align: center;
}
#player-sheet #sheet[data-v-4d20dbba] {
  width: 90%;
}
#player-sheet #sheet > div[data-v-4d20dbba]:not(.tags) {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
#player-sheet #sheet > div:not(.tags) > span[data-v-4d20dbba] {
  display: flex;
  justify-content: space-between;
  gap: 15px;
  align-items: center;
}
#player-sheet .indicator[data-v-4d20dbba] {
  padding: 5px;
  border-radius: 100%;
  border: 1px solid black;
  background: black;
  color: white;
  width: 24px;
}
#player-sheet.disabled[data-v-4d20dbba] {
  background: none;
  border: none;
}
#player-sheet.disabled .vertical-wrapper[data-v-4d20dbba] {
  display: none;
}
#player-sheet.disabled .lds-ripple[data-v-4d20dbba] {
  display: inline-block;
}
#player-sheet .lds-ripple[data-v-4d20dbba] {
  display: none;
  position: relative;
  width: 80px;
  height: 80px;
}
#player-sheet .lds-ripple div[data-v-4d20dbba] {
  position: absolute;
  border: 4px solid #fff;
  opacity: 1;
  border-radius: 50%;
  animation: lds-ripple-4d20dbba 1s cubic-bezier(0, 0.2, 0.8, 1) infinite;
}
#player-sheet .lds-ripple div[data-v-4d20dbba]:nth-child(2) {
  animation-delay: -0.5s;
}
@keyframes lds-ripple-4d20dbba {
0% {
    top: 36px;
    left: 36px;
    width: 0;
    height: 0;
    opacity: 0;
}
4.9% {
    top: 36px;
    left: 36px;
    width: 0;
    height: 0;
    opacity: 0;
}
5% {
    top: 36px;
    left: 36px;
    width: 0;
    height: 0;
    opacity: 1;
}
100% {
    top: 0px;
    left: 0px;
    width: 72px;
    height: 72px;
    opacity: 0;
}
}
.poll-wrapper[data-v-4d20dbba] {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 10px;
}
.poll-wrapper > .poll-content[data-v-4d20dbba] {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 10px;
}
.poll-wrapper > .poll-content > span[data-v-4d20dbba] {
  display: flex;
  align-items: center;
}
.poll-wrapper > .poll-content > .title[data-v-4d20dbba] {
  font-weight: bold;
  align-self: center;
}
.poll-wrapper > div[data-v-4d20dbba], .poll-wrapper > span[data-v-4d20dbba] {
  border: 1px solid black;
  padding: 15px;
}
.group-choice select[data-v-4d20dbba] {
  -webkit-appearance: none;
  -moz-appearance: none;
  background: transparent;
  background-image: url("data:image/svg+xml;utf8,<svg fill='black' height='24' viewBox='0 0 24 24' width='24' xmlns='http://www.w3.org/2000/svg'><path d='M7 10l5 5 5-5z'/><path d='M0 0h24v24H0z' fill='none'/></svg>");
  background-repeat: no-repeat;
  background-position-x: 100%;
  margin-right: 2rem;
  padding-right: 2rem;
  border: 1px solid var(--border-color);
}
[data-v-88819342]:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker[data-v-88819342] {
  background: black;
}
[data-theme=light][data-v-88819342] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker[data-v-88819342] {
  background: white;
}
[data-theme=blue][data-v-88819342] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker[data-v-88819342] {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
.continue-game[data-v-88819342] {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  align-items: center;
  gap: 15px;
}
.continue-game input[type=text][data-v-88819342] {
  padding: 10px;
  text-align: center;
  border-radius: 10px;
  font-size: 0.9em;
  flex: 1;
}
@media (max-width: 767px) {
.continue-game input[type=text][data-v-88819342] {
    flex-basis: 100%;
    font-size: 0.9em;
}
}
.continue-game label[data-v-88819342] {
  flex: 1;
  text-align: left;
}
.continue-game button[data-v-88819342] {
  flex-basis: 100%;
}
.continue-game button.btn-valid[data-v-88819342] {
  margin-top: 30px;
}
.game[data-v-88819342] {
  display: grid;
  grid-template-columns: 1fr 1fr 2fr;
  align-items: center;
  gap: 20px 60px;
  text-align: left;
  background: var(--background-card-color);
  border-radius: 10px;
  padding: 10px;
}
.game > div[data-v-88819342] {
  display: flex;
  gap: 15px;
}
.game > div.title[data-v-88819342] {
  flex-direction: column;
  gap: 0;
}
.game > div.title .date[data-v-88819342] {
  font-size: 0.8em;
}
@media (max-width: 767px) {
.game[data-v-88819342] {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
}
.game .hidden-mobile[data-v-88819342],
  .game .visible-mobile[data-v-88819342] {
    flex-basis: 100%;
    justify-content: space-between;
}
.game .hidden-mobile .btn-valid[data-v-88819342],
  .game .visible-mobile .btn-valid[data-v-88819342] {
    flex: 1;
}
}
.delete-all[data-v-88819342] {
  margin-top: 30px;
  align-self: center;
}
:root {
  font-family: Helvetica, system-ui, Avenir, Inter, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-size: clamp(16px, 0.8vw, 1.2vw);
  color-scheme: light dark;
  --main-font: "Ubuntu";
  --font-color: white;
  --inverse-font-color: black;
  --input-font-color: white;
  --link-color: #90B494;
  --link-hover-color: #57A773;
  --background-color: black;
  --button-color: white;
  --background-card-color: #222;
  --border-input: none;
  --border-color: #777;
  --failure-background: #8c3232;
  --success-background: #277e27;
  --success-color: #3ec23e;
  --danger-color: #8c3232;
  --valid-color: #266226;
  --tag-color: #1c1a1a;
  --background-select: white;
  --poll-background: #242424;
  --button-background: #0b6488;
  --select-border: none;
  --margin-multiselect: 0;
  --tab-border-color: white;
  --character-picked: gold;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}
[data-theme=dark].picker {
  background: black;
}
[data-theme=light] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: black;
  --background-color: white;
  --button-background: black;
  --button-color: white;
  --background-card-color: #90c0ff;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --tab-border-color: black;
  --character-picked: black;
  --select-border: 1px solid black;
}
[data-theme=light].picker {
  background: white;
}
[data-theme=blue] {
  --font-color: black;
  --inverse-font-color: white;
  --input-font-color: white;
  --background-color: #5858c4;
  --background-card-color: #87BCDE;
  --button-background: black;
  --button-color: white;
  --content-background: rgba(0,0,0,0.1);
  --border-color: #777;
  --warning-background: #804200;
  --valid-color: #379634;
  --danger-color: #A63A50;
  --tab-border-color: black;
}
[data-theme=blue].picker {
  background: #5858c4;
}
@font-face {
  font-family: "icomoon";
  src: url("data:font/ttf;base64,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") format("truetype"), url("data:font/woff;base64,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") format("woff"), url("/assets/icomoon-b7df5fa7.svg?677nr0#icomoon") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 400;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 500;
  font-style: normal;
}
@font-face {
  font-family: "Ubuntu";
  font-weight: 600;
  font-style: normal;
}
.qr-code {
  border: 3px solid white;
  display: inline-block;
}
</style>
    </head>
    <body>
        
        <div id="app">
        </div>
    </body>
</html>

